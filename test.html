#!/bin/bash

INSTALL_TXT=./SRC/install.txt
LAST_TYPE=""
LAST_SCHEMA=""
PREV_SCHEMA=""
LAST_SQL_FILE=""
SQL_FILES=()
SQL_SCHEMAS=()
LAST_LANG=""
LAST_FILE_NAME=""
LAST_FILE_PATH=""
LAST_FILE_EXT=""
ALLOWED_TYPES="SQL"
FCJ_SERVER="\${JENKINS_USER}@\${FCJ_SERVER}"
FCJ_KEY_FILE="\${JENKINS_KEY_FILE}"
JENKINS_USER="\${JENKINS_USER}"
ENVIRONMENT_FOLDER="\${ENV_FOLDER}"
JENKINS_FOLDER_BACKUP=/home/${JENKINS_USER}/backup
JENKINS_FOLDER_BUFFER=/home/${JENKINS_USER}/buffer
PATCH_FOLDER=${1}/install
APP_EXIST_FLAG=""


BACKUP_SCRIPT="backupScript.sh"
> $BACKUP_SCRIPT
RESTORE_SCRIPT="restoreScript.sh"
> $RESTORE_SCRIPT
INSTALL_SCRIPT="installScript.sh"
> $INSTALL_SCRIPT
SQL_INSTALL_SCRIPT="sqlInstallScript.sh"
> $SQL_INSTALL_SCRIPT
BUFFER_SCRIPT="bufferScript.sh"
> $BUFFER_SCRIPT
PATCH_SCRIPT="patchScript.sh"
> $PATCH_SCRIPT
MAIN_INSTALL_SCRIPT="install.sh"
> $MAIN_INSTALL_SCRIPT


echo "set -e" >> $INSTALL_SCRIPT
echo "set -e" >> $BACKUP_SCRIPT
echo "set -e" >> $PATCH_SCRIPT
echo "set -e" >> $BUFFER_SCRIPT
echo "set -e" >> $RESTORE_SCRIPT


echo "rm -rf $JENKINS_FOLDER_BACKUP/**" >> $BACKUP_SCRIPT
echo "ssh -i $FCJ_KEY_FILE -o StrictHostKeychecking=no $FCJ_SERVER \"rm -rf $JENKINS_FOLDER_BUFFER/**\"" >> $BUFFER_SCRIPT
echo "mkdir -p $PATCH_FOLDER" >> $PATCH_SCRIPT
echo "cp $INSTALL_TXT $PATCH_FOLDER$(sed 's/.*\(\/.*\)/\1/g;' <<<$INSTALL_TXT)" >> $PATCH_SCRIPT
echo "cp $MAIN_INSTALL_SCRIPT $PATCH_FOLDER/$MAIN_INSTALL_SCRIPT" >> $PATCH_SCRIPT

cat "$INSTALL_TXT"

readarray linesArr a < $INSTALL_TXT
for line in ${linesArr[*]}
do  
    if [[ $line = *"SCHEMA="* ]]; then
        LAST_SCHEMA=$(echo ${line#*=} | tr '[:upper:]' '[:lower:]') 
        LAST_SCHEMA="$(sed 's/[^A-Za-z0-9._\/\-]//g' <<<"${LAST_SCHEMA}")"
            
        echo exit | sqlplus $DB_CREDENTIALS_USR[$LAST_SCHEMA]/$DB_CREDENTIALS_PSW@$DB_SERVER | grep Connected > /dev/null
        if [ ! $? -eq 0 ]; then
                        printf "\n>>>>>> Error: invalid credentials: $LAST_SCHEMA\n"
            exit 1
        fi
    fi

    if [[ $line = *"TYPE="* ]]; then
        LAST_TYPE="$(sed 's/[^A-Za-z0-9._\/\-]//g' <<<"${line#*=}")"
        
        if ! echo $ALLOWED_TYPES | grep -w $LAST_TYPE > /dev/null; then
                printf "\n>>>>>> Error: unknown type in Install.txt: $LAST_TYPE\n"
                                    exit 1
        fi
    fi

    if [[ $line = *"LANG="* ]]; then
        LAST_LANG="$(sed 's/[^A-Za-z0-9._\/\-]//g' <<<"${line#*=}")"
        echo "mkdir -p $UIXML_FOLDER/$LAST_LANG" >> $INSTALL_SCRIPT
    fi
  
    if [[ $line = "#@"* ]]; then
      continue
    fi

    if [[ $line = *"@"* ]]; then
      PATCH_FILE_PATH="$(sed 's/\\/\//g; s/\@\.\///g; s/\@\"\.\///g; s/\"//g; s/\@\///g; s/\@//g; s/[^A-Za-z0-9._\/\-]//g' <<<"$line")"
      GIT_FILE_PATH=SRC/"$PATCH_FILE_PATH"
      FILE_NAME=${PATCH_FILE_PATH##*'/'}
      FILE_NAME_WITHOUT_EXT="$(cut -d '.' -f 1 <<< "$FILE_NAME")"
      PATCH_FOLDER_NAME="$(sed  's/\(.*\)\/.*/\1/' <<<$PATCH_FILE_PATH)"
      #ABS_PATCH_FILE_PATH=$WORKSPACE/$PATCH_FOLDER/$PATCH_FILE_PATH

      if [ ! -f $GIT_FILE_PATH ]; then 
        printf "\n>>>>>> Error: file not found: $GIT_FILE_PATH\n"
        exit 1
      fi
    
      # Begin check charset block
      chrst=$(file -bi "${GIT_FILE_PATH}" | cut -d "=" -f 2)
      if [[ $chrst =~ 'unknown' ]]; then
        echo "${GIT_FILE_PATH} >>>>>> Error! unknown charset: (${chrst})"
        exit 1
      elif [ $chrst != 'utf-8' ] && [ $chrst != 'binary' ]; then
        rus_text=$(cat "$GIT_FILE_PATH" | iconv -f windows-1251 | grep -E '[А-Яа-яёЁ]' || true)
        if [ ${#rus_text} -ne 0 ]; then
          echo "${GIT_FILE_PATH} >>>>>> Error! wrong charset: (windows-1251)"
          exit 1
        fi
        rus_text=''
        rus_text=$(cat "$GIT_FILE_PATH" | iconv -f $chrst | grep -E '[А-Яа-яёЁ]' || true)
        if [ ${#rus_text} -ne 0 ]; then
          echo "${GIT_FILE_PATH} >>>>>> Error! wrong charset: (${chrst})"
          exit 1
        fi
      else
        if [ "`head -c 3 -- "$GIT_FILE_PATH"`" == $'\xef\xbb\xbf' ]
        then
        echo "${GIT_FILE_PATH} >>>>>> Error!: found BOM"
          exit 1
        fi
      fi
      # End check charset block
    
      if [[ $PATCH_FOLDER_NAME != $PATCH_FILE_PATH ]]; then 
        echo "mkdir -p $PATCH_FOLDER/$PATCH_FOLDER_NAME" >> $PATCH_SCRIPT
      fi
      echo "cp $GIT_FILE_PATH $PATCH_FOLDER/$PATCH_FILE_PATH" >> $PATCH_SCRIPT
    
      if [[ $LAST_TYPE = "SQL" ]] || [[ $LAST_TYPE = "JAVA_DB" ]]; then
        if [[ $PREV_SCHEMA != $LAST_SCHEMA ]]; then        # Is it necessary to start new file?
          LAST_SQL_FILE="install_db_${LAST_SCHEMA}.sql"  # Select spare name
          FILE_NUM=1
        
          while [ 1 = 1 ] 
          do
            V_EXIST_FILE='N'
            for i in ${SQL_FILES[@]}; 
            do
              if [[ $LAST_SQL_FILE = $i ]]; then
                V_EXIST_FILE='Y'
                let "FILE_NUM+=1"
                LAST_SQL_FILE="install_db_${LAST_SCHEMA}${FILE_NUM}.sql"
              fi
            done
            if [[ $V_EXIST_FILE = 'N' ]]; then
              break
            fi
          done
        
          SQL_LOG_FILE="$(cut -d '.' -f 1 <<< "$LAST_SQL_FILE").log"
          SQL_FILES+=($LAST_SQL_FILE)
          SQL_SCHEMAS+=($LAST_SCHEMA)
        
          echo "spool $SQL_LOG_FILE
                WHENEVER OSERROR EXIT 9;
                WHENEVER SQLERROR EXIT SQL.SQLCODE
                set timing on
                set serveroutput on
                set define off
                set sqlblanklines on
                alter session set nls_numeric_characters='.,';
                alter session set nls_date_format = 'DD-MON-YYYY';

               " >> $LAST_SQL_FILE
        fi
      
        PREV_SCHEMA=$LAST_SCHEMA
        if [[ $LAST_TYPE = "SQL" ]]; then
          echo "@${PATCH_FILE_PATH}" >> $LAST_SQL_FILE
        fi
        
      fi       
    fi    
done

# Constant part
cat << 'EOF2' >> $MAIN_INSTALL_SCRIPT

#!/bin/sh

err() {
    echo "Error: $*" >>/dev/stderr
}

#check_var varname positional_value is_password
check_var() {
      local command=$(cat <<'EOF'
if [[ -z $VARNAME ]]
then
      VARNAME='VALUE'
      
      if [[ -z $VARNAME ]]
      then
            if [[ -t 0 ]]
            then #Interactive console (0 is stdin)
                  read -PARAM 'Enter VARNAME: ' VARNAME
            fi
            
            if [[ -z $VARNAME ]]
            then
                  err "VARNAME is not set!"
                  exit 1
            fi
      fi
fi
EOF
)

      command=$(echo "$command" | sed "s/VARNAME/$1/g")
      command=$(echo "$command" | sed "s/VALUE/$2/g")
      if [[ -z $3 ]]
      then
            command=$(echo "$command" | sed "s/PARAM/p/g")
      else
            command=$(echo "$command" | sed "s/PARAM/sp/g")
      command="${command}
      echo ' '"
      fi
      
      eval "$command"
}
EOF2


# SQL part exists
if [[ ${#SQL_FILES[@]} > 0 ]]; then
  echo "set -e
export NLS_LANG=AMERICAN_AMERICA.AL32UTF8" >> $SQL_INSTALL_SCRIPT
  for i in ${!SQL_FILES[@]};
  do
    echo "commit;
spool off;"  >> "${SQL_FILES[$i]}"
    echo "sqlplus -l \$1[${SQL_SCHEMAS[$i]}]\/\$2@\$3 <<EOF
WHENEVER OSERROR EXIT 9;
WHENEVER SQLERROR EXIT SQL.SQLCODE
@${SQL_FILES[$i]}
EOF
" >> $SQL_INSTALL_SCRIPT
    echo "cp ${SQL_FILES[$i]} $PATCH_FOLDER/${SQL_FILES[$i]}" >> $PATCH_SCRIPT
  done
  echo "cp sqlInstallScript.sh $PATCH_FOLDER/sqlInstallScript.sh" >> $PATCH_SCRIPT
  echo "cp jenkins/recompile_invalids.sh $PATCH_FOLDER/recompile_invalids.sh" >> $PATCH_SCRIPT
  echo "cp jenkins/recompile_invalids.sql $PATCH_FOLDER/recompile_invalids.sql" >> $PATCH_SCRIPT
  
  echo "check_var fcj_login \"\$1\"
check_var fcj_pass \"\$2\" 1
check_var fcj_db \"\$3\"
echo exit | sqlplus \$fcj_login/\$fcj_pass@\$fcj_db | grep Connected > /dev/null
if [ ! \$? -eq 0 ]; then
        printf \"\\n>>>>>> Error: invalid DB credentials!\\n\"
  exit 1
fi

set -e

sh sqlInstallScript.sh \$fcj_login \$fcj_pass \$fcj_db
sh recompile_invalids.sh \$fcj_login[fcj]/\$fcj_pass \$fcj_db
" >> $MAIN_INSTALL_SCRIPT
fi

printf "\n>>>>>> Debug: buffer script\n"
cat "$BUFFER_SCRIPT"

printf "\n>>>>>> Debug: backup script\n"
cat "$BACKUP_SCRIPT"

printf "\n>>>>>> Debug: app install script\n"
cat "$INSTALL_SCRIPT"

printf "\n>>>>>> Debug: sqlInstall script\n"
cat "$SQL_INSTALL_SCRIPT"

printf "\n>>>>>> Debug: restore script\n"
cat "$RESTORE_SCRIPT"

for i in ${SQL_FILES[@]}; 
do
  printf "\n>>>>>> Debug: sql script $i\n\n"
    cat "$i"
done

printf "\n>>>>>> Debug: patch script\n"
cat "$PATCH_SCRIPT"

printf "\n>>>>>> Debug: main install script\n"
cat "$MAIN_INSTALL_SCRIPT"
