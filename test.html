CREATE OR REPLACE PACKAGE BODY FCCUCB.LH_REP2361_v6 as

 /*------------------------------------------------------------------------------------------------------
  CHANGE HISTORY

  Changed By         : Dmitry Shatskiy, 16/08/2021
  Search Line        : #INC000720388
  Change Description : 1. S.Golovan: Если дата отчета больше чем дата Maturity, то текущая (не просроченная) задолженность по кредиту (%% и ОД) всегда нулевая.
                       2. По 01460122RURRA11001 данные из cltb_event_entries перемещены в cltb_event_entries_arch.

  Changed By         : Dmitry Shatskiy, 20/10/2021
  Search Line        : #INC000729554_First_row_for_migrated_loans
  Change Description : First row for migrated loans

  Changed By         : Dmitry Shatskiy, 27/01/2022
  Search Line        : #INC000746822
  Change Description : Wrong filtering of reversed payment in CLTB_AMOUNT_PAID
                       Wrong formula for INT_EXPECTED_TOTAL. Переписка  10.02.22, 2361 Формирования данных для отчета Вер 19 draft.xlsx

  Changed By         : Dmitry Shatskiy, 25/03/2022
  Search Line        : #MULTIPLE_HOLIDAYS
  Change Description : Support or multiple holidays
  
  Changed By         : Polishchuk, 12/12/2022
  Search Line        : #SALH1
  Change Description : FCJ-683 SALH1

-------------------------------------------------------------------------------------------------------*/

v_event_entries  event_entries_tbl_t;
v_AMOUNT_PAID    AMOUNT_PAID_tbl_t;

TYPE event_entries_loans_t IS TABLE OF NUMBER INDEX BY VARCHAR2(100);
v_loans_ee event_entries_loans_t; -- List of loans with collected event_entries

TYPE STSH_reverse_row_t is record (
     REV_AMOUNT                NUMBER
    ,ERROR_DESC                varchar2(4000)
    ,ADD_INFO                  varchar2(4000)
);

FUNCTION fn_get_all_holiday_details(P_ACCOUNT_NUMBER IN VARCHAR2 := NULL) --#MULTIPLE_HOLIDAYS
RETURN t_all_holiday_details PIPELINED IS
    v_res     t_rec_all_holiday_details;
begin
    for i in (select st.account_number
                   , st.BRANCH_CODE
                   , st.restruct_type
                   , st.restruct_type_dt restr_date
                   , st.restruct_event_dt hol_start
                   , ed.restruct_event_dt hol_end
                   , d.today
                   , l.currency
                   , l.product_category
                   , (select distinct 'Y'
                        from fcc.CLTB_LOAN_RESTRUCT_EVENT rl
                       where rl.account_number = l.account_number
                         and st.branch_code = rl.branch_code
                         and st.restruct_type = rl.restruct_type
                          and st.restruct_type_dt = rl.restruct_type_dt
                          and restruct_event = 'E16') CAPITALIZATION_FLAG
                   , row_number() over (partition by st.account_number order by st.restruct_event_dt) hol_no
                   , lag(st.restruct_event_dt) over (partition by st.account_number order by st.restruct_event_dt) prev_hol_start
                from fcc.cltb_account_master l
                join fcc.CLTB_LOAN_RESTRUCT_EVENT st on l.account_number = st.account_number
                                                    and l.branch_code = st.branch_code
                join fcc.CLTB_LOAN_RESTRUCT_EVENT ed on st.account_number = ed.account_number
                                                    and st.BRANCH_CODE = ed.BRANCH_CODE
                                                    and st.restruct_type = ed.restruct_type
                                                    and st.restruct_type_dt = ed.restruct_type_dt
                                                    and st.restruct_event = 'E12' -- Start date
                                                    and ed.restruct_event = 'E13' -- End date
                join fcc.sttm_dates d on d.branch_code = l.branch_code
               where 1=1
                 and st.restruct_type in ('R41', 'R43') -- Mrtg Holidays completed, Credit Holidays COVID-19 completed
                 and (P_ACCOUNT_NUMBER is null or st.account_number = P_ACCOUNT_NUMBER)
                 and not exists -- Without rollback
                           (select *
                              from fcc.CLTB_LOAN_RESTRUCT_EVENT rl
                             where l.account_number = rl.account_number
                               and l.branch_code = rl.branch_code
                               and st.restruct_type = rl.restruct_type       -- Holiday - Rollback - Holiday, 24.11.20
                               and st.restruct_type_dt = rl.restruct_type_dt -- Holiday - Rollback - Holiday, 24.11.20
                               and rl.restruct_event in ('E14'  -- Rollback
                                                        ,'E15'))-- Rollback 120
               order by st.account_number, st.restruct_event_dt
             )
    loop
        v_res := null;
        v_res.account_number      := i.account_number;
        v_res.res_type            := i.restruct_type;
        v_res.product_category    := i.product_category;
        v_res.hol_start           := i.hol_start;
        v_res.hol_end             := i.hol_end;
        v_res.today               := i.today;
        v_res.currency            := i.currency;
        v_res.BRANCH_CODE         := i.BRANCH_CODE;
        v_res.CAPITALIZATION_FLAG := i.CAPITALIZATION_FLAG;
        v_res.hol_no              := i.hol_no;
        v_res.prev_hol_start      := i.prev_hol_start;

        if P_ACCOUNT_NUMBER is not null or 1=1 then -- for performance purposes
            declare
                V_TECH_LOAN_QTY number;
            begin
                select max(case when TECH_LOAN_TYPE = 'H1' then TECH_LOAN end)
                     , max(case when TECH_LOAN_TYPE = 'HA' then TECH_LOAN end)
                     , max(case when TECH_LOAN_TYPE = 'O1' then TECH_LOAN end)
                     , max(case when TECH_LOAN_TYPE = 'OA' then TECH_LOAN end)
                     , count(*)
                  into v_res.LOAN_H1, v_res.LOAN_HA, v_res.LOAN_O1, v_res.LOAN_OA, V_TECH_LOAN_QTY
                  from CLTB_HOL_TECH_LOANS_LINK
                 where PARENT_LOAN = i.account_number
                   and HOL_START = i.hol_start
                     ;
                if V_TECH_LOAN_QTY = 0 then
                    declare
                        H1_QTY number;
                        HA_QTY number;
                        O1_QTY number;
                        OA_QTY number;
                    begin
                        select min(case when tech_loan_type = 'H1' then t.account_number end) h1_loan
                             , min(case when tech_loan_type = 'HA' then t.account_number end) ha_loan
                             , min(case when tech_loan_type = 'O1' then t.account_number end) o1_loan
                             , min(case when tech_loan_type = 'OA' then t.account_number end) oa_loan
                             , count(case when tech_loan_type = 'H1' then t.account_number end) h1_qty
                             , count(case when tech_loan_type = 'HA' then t.account_number end) ha_qty
                             , count(case when tech_loan_type = 'O1' then t.account_number end) o1_qty
                             , count(case when tech_loan_type = 'OA' then t.account_number end) oa_qty
                          into v_res.LOAN_H1, v_res.LOAN_HA, v_res.LOAN_O1, v_res.LOAN_OA
                             , H1_QTY, HA_QTY, O1_QTY, OA_QTY
                          from table(GET_TECH_LOANS(i.account_number)) t
                             ;

                        if H1_QTY > 1 or HA_QTY > 1 or O1_QTY > 1 or OA_QTY > 1 then
                            v_res.LOAN_H1   := null;
                            v_res.LOAN_HA   := null;
                            v_res.LOAN_O1   := null;
                            v_res.LOAN_OA   := null;
                            v_res.error_msg := 'Can''t define tech.loans';
                        end if;
                    end;
                end if;
            end;
        end if;

        PIPE ROW(v_res);

    end loop;
end;

function GET_CAPITALIZATION_FLAG (pAcc in varchar2, pDate in date) return varchar2 -- #MULTIPLE_HOLIDAYS
as
    v_res varchar2(1);
begin
    for i in (select * from table(fn_get_all_holiday_details (pAcc)) where pDate between hol_start and hol_end)
    loop
        v_res := i.CAPITALIZATION_FLAG;
    end loop;
    return nvl(v_res, 'N');
end;

function GET_HOL_TYPE (pAcc in varchar2, pDate in date) return varchar2 -- #MULTIPLE_HOLIDAYS
as
    v_res varchar2(50);
begin
    for i in (select * from table(fn_get_all_holiday_details (pAcc)) where pDate between hol_start and hol_end)
    loop
        v_res := i.res_type;
    end loop;
    return nvl(v_res, '-');
end;

procedure COLLECT_EVENT_ENTRIES (pLoan in varchar2)
as
    v_start_time date := sysdate;
    v_tmp_event_entries event_entries_tbl_t;
    v_tmp_AMOUNT_PAID AMOUNT_PAID_tbl_t;
begin
    if not (v_loans_ee.exists(pLoan)) then
        select event_entries_row_t(  e.EVENT_SEQ_NO
                                    ,e.EVENT_CODE
                                    ,e.COMPONENT_NAME
                                    ,e.VALUE_DATE
                                    ,e.AMOUNT
                                    ,e.DR_ACC
                                    --,e.CR_ACC
                                    ,e.ACCOUNT_NUMBER
                                    ,e.AMOUNT_TAG
                                    ,e.DR_ACC_ROLE
                                    ,e.CR_ACC_ROLE
                                    ,e.STTL_ACC
                                  )
          bulk collect into /*v_event_entries*/ v_tmp_event_entries --  Splitted in two steps
          from table(GET_ALL_LOANS (pLoan)) l
          join fcc.cltb_event_entries e on e.account_number = l.account_number
         where 1=2 -- include only required events
            or e.AMOUNT_TAG like '%_DLIQ'
            or e.AMOUNT_TAG like '%_OLIQ'
            or e.AMOUNT_TAG like '%_NORM_REAL'
            or e.AMOUNT_TAG like '%_NRM2_REAL'
            or e.EVENT_CODE in ('STSH', 'DSBR')
            or e.AMOUNT_TAG in ('PRINCIPAL_INCR' , 'INT_ON_OVD_P_LIQD')
            or (AMOUNT < 0 and (DR_ACC_ROLE = 'DR_SETTL_BRIDGE' or CR_ACC_ROLE = 'CR_SETTL_BRIDGE'))
             ;

--        dbms_output.put_line('cltb_event_entries:' || SQL%rowcount);
        if SQL%rowcount = 0 then -- #INC000720388
            select event_entries_row_t(  e.EVENT_SEQ_NO
                                        ,e.EVENT_CODE
                                        ,e.COMPONENT_NAME
                                        ,e.VALUE_DATE
                                        ,e.AMOUNT
                                        ,e.DR_ACC
                                        --,e.CR_ACC
                                        ,e.ACCOUNT_NUMBER
                                        ,e.AMOUNT_TAG
                                        ,e.DR_ACC_ROLE
                                        ,e.CR_ACC_ROLE
                                        ,e.STTL_ACC
                                      )
              bulk collect into /*v_event_entries*/ v_tmp_event_entries --  Splitted in two steps
              from table(GET_ALL_LOANS (pLoan)) l
              join fcc.cltb_event_entries_arch e on e.account_number = l.account_number
             where 1=2 -- include only required events
                or e.AMOUNT_TAG like '%_DLIQ'
                or e.AMOUNT_TAG like '%_OLIQ'
                or e.AMOUNT_TAG like '%_NORM_REAL'
                or e.AMOUNT_TAG like '%_NRM2_REAL'
                or e.EVENT_CODE in ('STSH', 'DSBR')
                or e.AMOUNT_TAG in ('PRINCIPAL_INCR' , 'INT_ON_OVD_P_LIQD')
                or (AMOUNT < 0 and (DR_ACC_ROLE = 'DR_SETTL_BRIDGE' or CR_ACC_ROLE = 'CR_SETTL_BRIDGE'))
                 ;
--            dbms_output.put_line('cltb_event_entries_arch:' || SQL%rowcount);
        end if;

        select event_entries_row_t(  e.EVENT_SEQ_NO  -- Second step to join CLTB_LIQ
                                    ,e.EVENT_CODE
                                    ,e.COMPONENT_NAME
                                    ,e.VALUE_DATE
                                    ,e.AMOUNT
                                    ,e.DR_ACC
                                    --,e.CR_ACC
                                    ,e.ACCOUNT_NUMBER
                                    ,e.AMOUNT_TAG
                                    ,e.DR_ACC_ROLE
                                    ,e.CR_ACC_ROLE
                                    ,e.STTL_ACC
                                  )
          bulk collect into v_event_entries
          from table(v_tmp_event_entries) e
          left join fcc.CLTB_LIQ q on e.account_number = q.account_number
                                  and e.EVENT_SEQ_NO = q.EVENT_SEQ_NO
         where 1=1
           and nvl(q.payment_status, '-') <> 'V'
             ;

        select AMOUNT_PAID_row_t(  a.ACCOUNT_NUMBER
                                  ,a.PAID_DATE
                                  ,a.DUE_DATE
                                  ,a.EXEC_DATE
                                  ,a.COMPONENT_NAME
                                  ,a.ROWID
                                  ,a.EVENT_SEQ_NO
                                  ,a.AMOUNT_PAID
                                  ,a.AMOUNT_WAIVED
                                  ,null -- settle_acc
                                  )
          bulk collect into v_tmp_AMOUNT_PAID
          from table(GET_ALL_LOANS (pLoan)) l
          join fcc.cltb_AMOUNT_PAID a on a.account_number = l.account_number
         where 1=1
             ;

        select AMOUNT_PAID_row_t(  a.ACCOUNT_NUMBER
                                  ,a.PAID_DATE
                                  ,a.DUE_DATE
                                  ,a.EXEC_DATE
                                  ,a.COMPONENT_NAME
                                  ,a.ROW_ID
                                  ,a.EVENT_SEQ_NO
                                  ,a.AMOUNT_PAID
                                  ,a.AMOUNT_WAIVED
                                  ,s.settle_acc
                                  )
          bulk collect into v_AMOUNT_PAID
          from table(v_tmp_AMOUNT_PAID) a
          LEFT join fcc.CLTB_LIQ_SETTLEMENTS s on a.account_number = s.account_number -- S.Golovan, 29.04.2021
                                              and a.event_seq_no = s.event_seq_no
                                              and s.settle_amount is not null
         where 1=1
--           AND nvl(REVERSED, '-') <> 'Y'
           AND (REVERSED = 'N' or (REVERSED is null and s.account_number is not null)) -- #INC000746822
             ;

        -- Mark parent & tech. loans as collected
        v_loans_ee.Delete();
        for i in (select pLoan loan from dual
                  union all select account_number from table(GET_TECH_LOANS (pLoan)))
        loop
            v_loans_ee(i.Loan) := 1;
            dbms_output.put_line(i.Loan||' collected');
        end loop;
        dbms_output.put_line((sysdate-v_start_time)*24*60*60||' sec.');
    else
        dbms_output.put_line(pLoan||' ee exist');
    end if;
    dbms_output.put_line(' ');
end;

function GET_FIRST_INT_RATE (pLoan in varchar2) return number
as
    v_int_rate number;
begin
    SELECT UDE_VALUE
      into v_int_rate
      from fcc.CLTB_ACCOUNT_UDE_VALUES u
     WHERE u.ACCOUNT_NUMBER = pLoan
       AND u.UDE_ID ='INTEREST_RATE'
       and u.EFFECTIVE_DATE = (SELECT MIN(EFFECTIVE_DATE)
                                 from fcc.CLTB_ACCOUNT_UDE_VALUES m
                                WHERE m.ACCOUNT_NUMBER = u.ACCOUNT_NUMBER
                                  AND m.UDE_ID ='INTEREST_RATE'
                                  and m.UDE_VALUE <> 0)
                 ;
    return v_int_rate;
end;

function GET_DSBR (pLoan in varchar2) return number
as
    v_dsbr number;
begin
    select AMOUNT
      into v_dsbr
      FROM table(v_event_entries)
     WHERE ACCOUNT_NUMBER = pLoan
       and EVENT_CODE = 'DSBR' and EVENT_SEQ_NO < 5
         ;
    return v_dsbr;
end;

-- Copy of BODEV.CALC_DEBT_CREDIT_AGR.FNACCRUEDINTEREST
FUNCTION fnAccruedInterest (pOutAmount     IN NUMBER,
                            pStartDate     IN DATE,
                            pEndDate       IN DATE,
                            pPercentYear   IN NUMBER,
                            pBASIS         IN VARCHAR2 DEFAULT 'ANNUAL') RETURN NUMBER
IS
    vStartYear        NUMBER;
    vEndYear          NUMBER;
    vLoopYear         NUMBER;
    vDiffYear         NUMBER;
    nNumDayInPeriod   NUMBER;
    nNumDayInYear     NUMBER;
    i                 NUMBER;                                --Счетчик годов
    -----------------
    nRetSum   NUMBER;
    nCalcRetSum    NUMBER:=0;
BEGIN
    --Определяем начальные условия для вычисления
    --Сначала разбираемся с годами
    vStartYear := TO_NUMBER (TO_CHAR (pStartDate, 'yyyy'));
    vEndYear := TO_NUMBER (TO_CHAR (pEndDate, 'yyyy'));
    vDiffYear := vEndYear - vStartYear;

    --Сравниваем года начала и окончания сделки
    IF vStartYear = vEndYear
    THEN                                            --Если год один и тот-же
        nNumDayInPeriod := pEndDate - pStartDate;
        nNumDayInYear :=
                        TO_DATE ('01.01.' || TO_CHAR (vStartYear + 1, '9999'),
                        'dd.MM.yyyy')
                        - TO_DATE ('01.01.' || TO_CHAR (vStartYear, '9999'),
                        'dd.MM.yyyy');
        --Вместо запролнения таблицы возврат в переменную
        If pBASIS='ANNUAL' Then
            nRetSum:=pOutAmount*nNumDayInPeriod*pPercentYear/nNumDayInYear/100;
        Else
            nRetSum:=pOutAmount*nNumDayInPeriod*pPercentYear/100;
        End If;
    -----------------------------------------------------------------------
    ELSE              --Если начало сделки в одном году а окончание в другом
        FOR i IN 0 .. vDiffYear
        LOOP
            vLoopYear := vStartYear + i;

            --Вот и начинается мракобесие
            IF vStartYear = vLoopYear --Это первый кусок всего периода от начала до конца года выдачи
            THEN
                nNumDayInPeriod :=
                                    TO_DATE ('31.12.' || TO_CHAR (vLoopYear, '9999'),
                                    'dd.MM.yyyy')
                                    - pStartDate;
                nNumDayInYear :=
                                    TO_DATE ('01.01.' || TO_CHAR (vStartYear + 1, '9999'),
                                    'dd.MM.yyyy')
                                    - TO_DATE ('01.01.' || TO_CHAR (vStartYear, '9999'),
                                    'dd.MM.yyyy');
                --Вместо запролнения таблицы возврат в переменную
                If pBASIS='ANNUAL' Then
                    nCalcRetSum:=nCalcRetSum+(pOutAmount*nNumDayInPeriod*pPercentYear/nNumDayInYear/100);
                Else
                    nCalcRetSum:=nCalcRetSum+(pOutAmount*nNumDayInPeriod*pPercentYear/100);
                End If;
            -----------------------------------------------------------------
            ELSE
                IF vLoopYear = vEndYear --Это последний кусок всего периода от начала года до конца действия кредита
                THEN
                    nNumDayInPeriod :=
                                        pEndDate
                                        - TO_DATE ('31.12.' || TO_CHAR (vLoopYear - 1, '9999'),
                                        'dd.MM.yyyy');
                    nNumDayInYear :=
                                        TO_DATE ('01.01.' || TO_CHAR (vLoopYear + 1, '9999'),
                                        'dd.MM.yyyy')
                                        - TO_DATE ('01.01.' || TO_CHAR (vLoopYear, '9999'),
                                        'dd.MM.yyyy');
                    --Вместо запролнения таблицы возврат в переменную
                    If pBASIS='ANNUAL' Then
                        nCalcRetSum:=nCalcRetSum+(pOutAmount*nNumDayInPeriod*pPercentYear/nNumDayInYear/100);
                    Else
                        nCalcRetSum:=nCalcRetSum+(pOutAmount*nNumDayInPeriod*pPercentYear/100);
                    End If;
                    -----------------------------------------------------------------
                ELSE    --А это в случае рассчетов по целому году
                    nNumDayInPeriod :=
                                        TO_DATE ('31.12.' || TO_CHAR (vLoopYear, '9999'),
                                        'dd.MM.yyyy')
                                        - TO_DATE ('31.12.' || TO_CHAR (vLoopYear - 1, '9999'),
                                        'dd.MM.yyyy');
                    nNumDayInYear :=
                                        TO_DATE ('31.12.' || TO_CHAR (vLoopYear, '9999'),
                                        'dd.MM.yyyy')
                                        - TO_DATE ('31.12.' || TO_CHAR (vLoopYear - 1, '9999'),
                                        'dd.MM.yyyy');
                    --Вместо запролнения таблицы возврат в переменную
                    If pBASIS='ANNUAL' Then
                        nCalcRetSum:=nCalcRetSum+(pOutAmount*nNumDayInPeriod*pPercentYear/nNumDayInYear/100);
                    Else
                        nCalcRetSum:=nCalcRetSum+(pOutAmount*nNumDayInPeriod*pPercentYear/100);
                    End If;
                    -----------------------------------------------------------------
                END IF;
            END IF;
            nRetSum:=nCalcRetSum;
        END LOOP;
    END IF;

    RETURN nRetSum;
END fnAccruedInterest;

function GET_LOAN_DETAILS (pLoan in varchar2) return LOAN_DETAILS_row_t
as
    res LOAN_DETAILS_row_t;
begin

    res.ACCOUNT_NUMBER := pLoan;

    select VALUE_DATE, MATURITY_DATE, DATE_TYPE, today, AUTH_STAT, PARENT_LOAN
      into res.VALUE_DATE, res.MATURITY_DATE, res.DATE_TYPE, res.TODAY, res.AUTH_STAT, res.PARENT_LOAN
      from (-- First row for migrated loan
            SELECT nvl( -- 00956774RURRA00001 -- no INTEREST_RATE, D.Shatskiy, 20/04/2021
                   (SELECT MIN(EFFECTIVE_DATE)-1
                      FROM fcc.CLTB_ACCOUNT_UDE_VALUES u
                     WHERE u.ACCOUNT_NUMBER = l.ACCOUNT_NUMBER
                       and UDE_ID ='INTEREST_RATE' and UDE_VALUE <> 0)
                    ,  l.VALUE_DATE) VALUE_DATE
                 , MATURITY_DATE, 'First migrated' DATE_TYPE, branch_code
                 , l.FIELD_CHAR_5 PARENT_LOAN
              from fcc.CLTB_ACCOUNT_APPS_MASTER l
             WHERE 1=1
               and ALT_ACC_NO <> l.ACCOUNT_NUMBER
               and l.ACCOUNT_NUMBER = pLoan
            union all
            -- First row for non-migrated loan
            SELECT l.VALUE_DATE, MATURITY_DATE, 'First' DATE_TYPE, branch_code, l.FIELD_CHAR_5 PARENT_LOAN
              FROM fcc.CLTB_ACCOUNT_APPS_MASTER l
             WHERE l.ACCOUNT_NUMBER  = pLoan
               and nvl(ALT_ACC_NO, l.ACCOUNT_NUMBER) = l.ACCOUNT_NUMBER
            ) x
      join fcc.sttm_dates d on d.branch_code = x.branch_code
         ;

    if not regexp_like(res.PARENT_LOAN, '\d{8}\D{3}\w{4}\d{3}') then
        res.PARENT_LOAN := null;
    end if;

    if substr(nvl(res.PARENT_LOAN, pLoan), 12, 2) = 'RM' then -- #MULTIPLE_HOLIDAYS
        res.LOAN_TYPE := 'MORTGAGE';
    else
        res.LOAN_TYPE := 'CONSUMER/CAR';
    end if;

    begin
        select case when BLMV_EVENT_REQUIRED = 'N' and child_product like 'R%H%' then 'H1' -- Transferred interest
                    when BLMV_EVENT_REQUIRED = 'Y' and child_product like 'R%H%' then 'HA' -- Transferred principal
                    when regexp_like(child_product, 'R.O\d') then 'O1'                     -- Transferred overdue interest
                    when regexp_like(child_product, 'R.O\D') then 'OA'                     -- Transferred overdue principal
               end TECH_LOAN_TYPE
          into res.TECH_LOAN_TYPE
          from fcc.CLTM_CHILD_LOAN_PRODUCT
         where child_product = substr(pLoan, 12, 4)
             ;
    exception
        when NO_DATA_FOUND then
            NULL;
    end;

    return res;
end;

function APPEND_TEXT (pExistText in varchar2, pNewText in varchar2) return varchar2
as

begin
    return pExistText
        || case when pExistText is not null and pNewText is not null then ', ' end
        || pNewText;
end;

procedure COLLECT_LOAN_DETAILS (pLoan in varchar2)
as
begin
    if nvl(v_loan_details.account_number, '-') <> pLoan then
        v_loan_details := GET_LOAN_DETAILS(pLoan);
    end if;
end;

function GET_STSH_reverse (pLoan in varchar2, pSTSH_date date, pSTSH_amt number, pComponent varchar2) return STSH_reverse_row_t
as -- Looking for reverses. S.Golovan, 26.01.2021
    res_row STSH_reverse_row_t;
    v_max_SEQ_NO number;
    v_test_AM number;
begin
    if pSTSH_amt > 0 then
        COLLECT_LOAN_DETAILS(pLoan);
        COLLECT_EVENT_ENTRIES (pLoan);

        Select sum(a.AMOUNT), max(r.EVENT_SEQ_NO)
          into res_row.REV_AMOUNT, v_max_SEQ_NO
          from table(v_event_entries) r
          join table(v_event_entries) a on r.account_number = a.account_number
                                       and r.EVENT_SEQ_NO = a.EVENT_SEQ_NO
                                       and a.AMOUNT_TAG = GET_COMPONENT(pComponent, v_loan_details.tech_loan_type)||'_DLIQ'
         where r.VALUE_DATE = pSTSH_date
           and r.AMOUNT_TAG =  GET_COMPONENT(pComponent, v_loan_details.tech_loan_type)||'_NORM_REAL'
           and r.AMOUNT < 0
           and r.account_number = pLoan
             ;

        if res_row.REV_AMOUNT <> 0 then
            res_row.ADD_INFO := 'Reverse='||res_row.REV_AMOUNT;

            -- check
            begin
            SELECT a.amount
              into v_test_AM
              FROM table(v_event_entries) a
              left JOIN fcc.CLTB_ACCOUNT_SCHEDULES s on 1=1
                                                   and a.COMPONENT_NAME = s.COMPONENT_NAME -- Odue in schedules
                                                   and a.account_number = s.account_number
                                                   and s.SCHEDULE_DUE_DATE = a.VALUE_DATE
             WHERE 1=1
               AND a.account_number = pLoan
               AND a.EVENT_SEQ_NO > v_max_SEQ_NO
               AND EVENT_CODE = 'STSH'
               AND s.SCHEDULE_DUE_DATE is null
               AND a.COMPONENT_NAME = GET_COMPONENT(pComponent, v_loan_details.tech_loan_type)
               AND a.amount = pSTSH_amt-res_row.REV_AMOUNT
                 ;
            exception
                when no_data_found then
                    res_row.error_desc := 'Reverse check: sum='||(pSTSH_amt-res_row.REV_AMOUNT)||' NO_DATA_FOUND';
                when too_many_rows then
                    res_row.error_desc := 'Reverse check: sum='||(pSTSH_amt-res_row.REV_AMOUNT)||' TOO_MANY_ROWS';
            end;
        end if;
    else
        res_row.REV_AMOUNT := 0;
    end if;
    return res_row;
exception
    when no_data_found then
        res_row.REV_AMOUNT := 0;
        return res_row;
end;

function GET_TECH_LOANS (pLoan in varchar2) return TECH_LOAN_tbl_t pipelined
as
    res_row TECH_LOAN_row_t;
begin
    for i in (SELECT a.ACCOUNT_NUMBER
                   , case when BLMV_EVENT_REQUIRED = 'N' and a.PRODUCT_CODE like 'R_H%' then 'H1' -- Transferred interest
                          when BLMV_EVENT_REQUIRED = 'Y' and a.PRODUCT_CODE like 'R_H%' then 'HA' -- Transferred principal
                          when regexp_like(child_product, 'R.O\d') then 'O1'                     -- Transferred overdue interest
                          when regexp_like(child_product, 'R.O\D') then 'OA'                     -- Transferred overdue principal
                     end TECH_LOAN_TYPE
                   , book_date -- #MULTIPLE_HOLIDAYS
                   , maturity_date
                FROM fcc.CLTB_ACCOUNT_APPS_MASTER a
                join fcc.CLTM_CHILD_LOAN_PRODUCT c on a.PRODUCT_CODE = c.child_product
               WHERE a.FIELD_CHAR_5 = pLoan
                 AND (a.PRODUCT_CODE like 'R_H%' or a.PRODUCT_CODE like 'R_O%')
                 AND a.ACCOUNT_NUMBER like substr(pLoan,1,11)||'%'
                 AND account_status <> 'V'
              UNION ALL
              SELECT distinct a.LOAN_ACC_1, 'R1' -- Restructured interest
                   , null book_date
                   , null maturity_date -- not needed yet
                FROM fcc.CLTB_LOAN_PAIR_LOG_CUSTOM a
               WHERE a.LOAN_ACC_2 = pLoan
                 and a.status = 'P'
             )
    loop
        res_row := null;
        res_row.ACCOUNT_NUMBER := i.ACCOUNT_NUMBER;
        res_row.TECH_LOAN_TYPE := i.TECH_LOAN_TYPE;
        res_row.MATURITY_DATE  := i.MATURITY_DATE;
        res_row.BOOK_DATE      := i.BOOK_DATE;
        pipe row(res_row);
    end loop;


end;

function GET_DAYS_IN_YEAR (pDate in date) return NUMBER
as
begin
    return (to_date('31.12.'||to_char(pDate, 'YYYY'), 'DD.MM.YYYY') - to_date('01.01.'||to_char(pDate, 'YYYY'), 'DD.MM.YYYY'))+1;
end;

function GET_ALL_LOANS (pLoan in varchar2) return TECH_LOAN_tbl_t pipelined
as
    res_row TECH_LOAN_row_t;
begin
    COLLECT_LOAN_DETAILS(pLoan);
    res_row.account_number := pLoan;
    res_row.tech_loan_type := null;
    res_row.maturity_date := v_loan_details.maturity_date;

    pipe row(res_row);

    for i in (select * from table(GET_TECH_LOANS (pLoan)))
    loop
        pipe row(i);
    end loop;
end;

function GET_LAST_DATES_OF_YEAR (pDateSt in date, pDateEn in date) return DATES_tbl_t pipelined
as
    date_row DATES_row_t;
begin
    for i in (  SELECT last_day
                  FROM (select add_months(to_date('31.12.'||to_char(pDateSt, 'YYYY'), 'DD.MM.YYYY'), (level-1)*12) last_day
                             , to_char(add_months(to_date('31.12.'||to_char(pDateSt, 'YYYY'), 'DD.MM.YYYY'), (level-1)*12) - add_months(to_date('01.01.'||to_char(pDateSt, 'YYYY'), 'DD.MM.YYYY'), (level-1)*12)+1) days_qty
                             , lead(to_char(add_months(to_date('31.12.'||to_char(pDateSt, 'YYYY'), 'DD.MM.YYYY'), (level-1)*12) - add_months(to_date('01.01.'||to_char(pDateSt, 'YYYY'), 'DD.MM.YYYY'), (level-1)*12)+1)) over (partition by 1 order by level) next_days_qty
                          from dual
                       connect by add_months(to_date('01.01.'||to_char(pDateSt, 'YYYY'), 'DD.MM.YYYY'), (level-1)*12)<=to_date('01.01.'||to_char(pDateEn, 'YYYY'), 'DD.MM.YYYY')
                       )
                 where days_qty<>next_days_qty
    )
    loop
        date_row := null;
        date_row.FROM_DATE := i.last_day;
--        date_row.DATE_TYPE := i.DATE_TYPE;
        pipe row(date_row);
    end loop;
exception
    when others then
        fcc.dbg.error(to_date(pDateSt, 'dd.mm.yyyy')||'-'||to_date(pDateEn, 'dd.mm.yyyy')||' ERR:' || SQLCODE || ' ' || SQLERRM, 'FCCUCB.LH_REP2361_v6.GET_LAST_DATES_OF_YEAR');
        raise;
end;

function GET_DATES (pLoan in varchar2, pDate in date) return DATES_tbl_t pipelined
as
    date_row DATES_row_t;
begin
    COLLECT_LOAN_DETAILS(pLoan);
    COLLECT_EVENT_ENTRIES (pLoan);

    for i in (select * from (
                select v_loan_details.VALUE_DATE FROM_DATE, v_loan_details.DATE_TYPE DATE_TYPE from dual
                union all
                -- Schedules
                SELECT c.SCHEDULE_DUE_DATE FROM_DATE, 'Schedules' -- Underline important for group function min()
                  FROM fcc.CLTB_ACCOUNT_SCHEDULES c
                 WHERE c.ACCOUNT_NUMBER = pLoan
                   AND C.COMPONENT_NAME = 'MAIN_INT'
                   AND c.SCHEDULE_DUE_DATE <= nvl(pDate, v_loan_details.today)
                union all
                -- Partial prepayment
                SELECT UNIQUE PAID_DATE FROM_DATE, 'Partial prepayment'
                  FROM table(v_AMOUNT_PAID)
                 WHERE ACCOUNT_NUMBER = pLoan
                   AND COMPONENT_NAME  IN ('MAIN_INT','PRINCIPAL')
                   AND DUE_DATE > PAID_DATE
                   and PAID_DATE <= nvl(pDate, v_loan_details.today)
                 GROUP BY PAID_DATE HAVING SUM (AMOUNT_PAID) !=0
                union all
                -- Last day of the year when next year has different days quantity
                SELECT from_date, 'Last day of the year' from table(GET_LAST_DATES_OF_YEAR(v_loan_details.VALUE_DATE, least(nvl(pDate,v_loan_details.TODAY),v_loan_details.maturity_date)))
                union all
                -- Principal increase
                SELECT VALUE_DATE
                     , Case when STTL_ACC like '%SALH1%' then 'Capitalization' -- S.Golovan, 20.05.21
                            else 'Principal increase'
                       end
                  FROM table(v_event_entries)
                 WHERE ACCOUNT_NUMBER = pLoan
                   AND AMOUNT_TAG = 'PRINCIPAL_INCR'
                   and VALUE_DATE <= nvl(pDate, v_loan_details.today)
                 GROUP BY VALUE_DATE
                     , Case when STTL_ACC like '%SALH1%' then 'Capitalization'
                            else 'Principal increase'
                       end
                 having SUM(AMOUNT) <> 0
                union all
                -- Interest rate change
                SELECT (EFFECTIVE_DATE - 1), 'Interest rate change'
                  FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                 WHERE ACCOUNT_NUMBER = pLoan
                   AND UDE_ID ='INTEREST_RATE'
                   and (EFFECTIVE_DATE - 1) > v_loan_details.VALUE_DATE
                   and (EFFECTIVE_DATE - 1) <= nvl(pDate, v_loan_details.today)
                union all
                -- Last date
                select least(nvl(pDate, v_loan_details.today), v_loan_details.maturity_date)
                           , 'Last date'
                          || decode(least(nvl(pDate, v_loan_details.today), v_loan_details.maturity_date)
                                   , v_loan_details.maturity_date, '-Maturity'
                                   , v_loan_details.today, '-Today')
                  from dual
                union all
                -- Holiday start&end #MULTIPLE_HOLIDAYS
                select hol_start, 'Holiday start '||row_number() over (partition by account_number order by hol_start)
                  from table(fn_get_all_holiday_details(pLoan))
                 where hol_start <= nvl(pDate, v_loan_details.today)
                union all
                select hol_end, 'Holiday end '||row_number() over (partition by account_number order by hol_start)
                  from table(fn_get_all_holiday_details(pLoan))
                 where hol_end <= nvl(pDate, v_loan_details.today)
                -- Prepay H1
                union all
                SELECT PAID_DATE
                     , 'Prepay H1'
                  FROM table(GET_TECH_LOANS(pLoan)) l
                  join table(v_AMOUNT_PAID) p on l.ACCOUNT_NUMBER = p.ACCOUNT_NUMBER
                 where 1=1
                   AND DUE_DATE > PAID_DATE
                   AND COMPONENT_NAME = 'PRINCIPAL'
                   AND PAID_DATE <= pDate
                   AND tech_loan_type in ('H1')
                 GROUP BY PAID_DATE
                HAVING SUM (AMOUNT_PAID) !=0
              ) order by FROM_DATE
    )
    loop
        date_row := null;
        date_row.FROM_DATE := i.FROM_DATE;
        date_row.DATE_TYPE := i.DATE_TYPE;
        pipe row(date_row);
    end loop;
end;

function GET_TECH_LOANS_REPAYMENTS (pLoan in varchar2, pDate in date) return LOAN_REPAYMENT_CALC_tbl_t pipelined
as
    res_row                     LOAN_REPAYMENT_CALC_row_t;
begin
    COLLECT_EVENT_ENTRIES (pLoan);
    for i in (with s as (SELECT l.ACCOUNT_NUMBER
                              , a.SCHEDULE_DUE_DATE TO_DATE
                              , case when tech_loan_type in ('H1', 'R1') then AMOUNT_DUE end INT_DUE
                              , case when tech_loan_type in ('HA') then AMOUNT_DUE end PRPL_DUE
                              , 0  PREPAID_INT_CHILD
                              , 0  PREPAID_PRPL_CHILD
                              , 'Scheduled payments '||tech_loan_type dtType
                           FROM (select * from table(GET_TECH_LOANS(pLoan)) where tech_loan_type not like 'O%') l
                           join fcc.CLTB_ACCOUNT_SCHEDULES a on l.ACCOUNT_NUMBER = a.ACCOUNT_NUMBER
                          WHERE 1=1
                            AND a.COMPONENT_NAME = 'PRINCIPAL'
                            AND a.SCHEDULE_DUE_DATE <= pDate
                         union all
                         SELECT l.ACCOUNT_NUMBER
                              , PAID_DATE, null, null
                              , sum(case when tech_loan_type in ('H1', 'R1') then AMOUNT_PAID end) PREPAID_INT_CHILD
                              , sum(case when tech_loan_type in ('HA') then AMOUNT_PAID end) PREPAID_PRPL_CHILD
                              , 'Prepayments '||tech_loan_type dtType
                           FROM (select * from table(GET_TECH_LOANS(pLoan)) where tech_loan_type not like 'O%') l
                           join table(v_AMOUNT_PAID) p on l.ACCOUNT_NUMBER = p.ACCOUNT_NUMBER
                          where 1=1
                            AND DUE_DATE > PAID_DATE
                            AND COMPONENT_NAME = 'PRINCIPAL'
                            AND PAID_DATE <= pDate
                          GROUP BY l.ACCOUNT_NUMBER, PAID_DATE, tech_loan_type HAVING SUM (AMOUNT_PAID) !=0
                        )
              select min(ACCOUNT_NUMBER) ACCOUNT_NUMBER -- Interest loan H1 first of all
                   , TO_DATE
                   , sum(INT_DUE) INT_DUE
                   , sum(PRPL_DUE) PRPL_DUE
                   , sum(PREPAID_INT_CHILD) PREPAID_INT_CHILD
                   , sum(PREPAID_PRPL_CHILD) PREPAID_PRPL_CHILD
                   , min(dtType) dtType
                from s
               group by TO_DATE
               order by TO_DATE
             )
    loop
        res_row := null;
        res_row.PARENT_ACCOUNT_NUMBER := pLoan;
        res_row.ACCOUNT_NUMBER        := i.ACCOUNT_NUMBER;
        res_row.TO_DATE               := i.TO_DATE;
        res_row.INT_DUE_FCC           := i.INT_DUE;
        res_row.INT_DUE_AGR           := i.INT_DUE;
        res_row.PRPL_DUE              := i.PRPL_DUE;
        res_row.PREPAID_INT_CHILD     := i.PREPAID_INT_CHILD;
        res_row.PREPAID_PRPL_CHILD    := i.PREPAID_PRPL_CHILD;
        res_row.ADD_INFO              := i.dtType;

        pipe row(res_row);
    end loop;
end;


function GET_LOAN_REPAYMENT_CALC (pLoan in varchar2, pDate in date) return LOAN_REPAYMENT_CALC_tbl_t pipelined
as
    res_row                     LOAN_REPAYMENT_CALC_row_t;
    v_loan_details              LOAN_DETAILS_row_t := GET_LOAN_DETAILS(pLoan);
    v_prev_PRPL_EXPECTED        number             := 0;
    v_prev_PREPAID_PRPL_PARENT  number             := 0;
    v_prev_PRPL_DUE             number             := 0;
    v_prev_PRPL_INCR            number             := 0;
    v_prev_HOL_FLAG             varchar2(1);
    v_prev_PRPL_EXPECTED_TOTAL  number             := 0;
    v_prev_INT_EXPECTED_TOTAL   number             := 0;
    v_prev_PREPAID_INT_PARENT   number             := 0; --#INC000746822_INT_EXPECTED_TOTAL
    v_prev_PREPAID_INT_CHILD    number             := 0; --#INC000746822_INT_EXPECTED_TOTAL
    v_sum_ACCR_INT              number             := 0;
    v_sum_PREPAID_INT_PARENT    number             := 0;
    v_prev_POSTP_INT            number             := 0;
    v_prev_INT_DUE_AGR          number             := 0;
    v_HOL_count                 number;
    v_hol_no                    number;
    v_var                       number;
    v_tech_repayments           LOAN_REPAYMENT_CALC_tbl_t;
BEGIN

    COLLECT_LOAN_DETAILS(pLoan);
    COLLECT_EVENT_ENTRIES (pLoan);

    if pDate < v_loan_details.value_date then
        res_row.ERROR_DESC := 'Report_date < Value_date';
        pipe row(res_row);
        return;
    elsif v_loan_details.AUTH_STAT <> 'A' then
        res_row.ERROR_DESC := 'Loan is under construction';
        pipe row(res_row);
    end if;

    -- Collect repayments for technical loans
    select *
      bulk collect into v_tech_repayments
      from table(GET_TECH_LOANS_REPAYMENTS(pLoan, least(nvl(pDate, v_loan_details.today), v_loan_details.maturity_date)))
         ;

    -- #INC000729554_First_row_for_migrated_loans Start
    if v_loan_details.DATE_TYPE = 'First migrated' then
        declare
            migr_row LOAN_REPAYMENT_CALC_row_t  ;
        begin
            SELECT MIN(schedule_st_date)
              into migr_row.FROM_DATE
              FROM FCC.CLTBS_ACCOUNT_SCHEDULES t
             WHERE t.ACCOUNT_NUMBER = pLoan
               and t.COMPONENT_NAME = 'PRINCIPAL'
                 ;

            if migr_row.FROM_DATE < v_loan_details.value_date then
                migr_row.PARENT_ACCOUNT_NUMBER     := pLoan;
                migr_row.ACCOUNT_NUMBER            := pLoan;
                migr_row.TO_DATE                   := v_loan_details.value_date;
                migr_row.INT_RATE                  := GET_FIRST_INT_RATE (pLoan);
                migr_row.PRPL_EXPECTED             := GET_DSBR (pLoan);
                migr_row.PRPL_EXPECTED_TOTAL       := migr_row.PRPL_EXPECTED;
                migr_row.ACCR_INT                  := fnAccruedInterest(migr_row.PRPL_EXPECTED
                                                                       ,migr_row.FROM_DATE
                                                                       ,migr_row.TO_DATE
                                                                       ,migr_row.INT_RATE);
                migr_row.INT_EXPECTED_TOTAL        := round(migr_row.ACCR_INT,2);
                migr_row.ADD_INFO                  := 'Before migration';

                pipe row(migr_row);
            end if;
        end;
    end if;
    -- #INC000729554_First_row_for_migrated_loans End

    -- Parent loan
    for i in (select FROM_DATE
                   , lead(FROM_DATE) over (order by FROM_DATE) TO_DATE
                   , case when date_type like 'First%' then date_type
                          else lead(date_type) over (order by FROM_DATE)
                     end date_type -- Transfer date_type from next record
                from (select FROM_DATE
--                           , min(date_type) date_type -- 'Last date' and 'First%' in priority
                           , LISTAGG (date_type , ', ')
                              WITHIN GROUP (ORDER BY FROM_DATE desc) date_type
                        from table(GET_DATES (pLoan, pDate))
                       group by FROM_DATE)
               order by FROM_DATE)
    loop
        res_row := null;

        -- Skip last row
        if i.TO_DATE is null then
            continue;
        end if;


        res_row.PARENT_ACCOUNT_NUMBER := pLoan;
        res_row.ACCOUNT_NUMBER        := pLoan;
        res_row.FROM_DATE             := i.FROM_DATE;
        res_row.TO_DATE               := i.TO_DATE;
        res_row.ADD_INFO              := i.date_type;

        for i in (select * from table(fn_get_all_holiday_details(pLoan)) where res_row.TO_DATE between hol_start and hol_end) loop -- #MULTIPLE_HOLIDAYS
            res_row.HOL_FLAG := 'Y';
            res_row.LOAN_H1  := i.LOAN_H1;
        end loop;

        if i.date_type = 'First migrated' then
            -- INT_RATE
            res_row.INT_RATE := GET_FIRST_INT_RATE (pLoan);
            -- PRPL_EXPECTED
            res_row.PRPL_EXPECTED := GET_DSBR(pLoan);
        elsif i.date_type = 'First' then
            -- INT_RATE
            SELECT UDE_VALUE
              into res_row.INT_RATE
              from fcc.CLTB_ACCOUNT_UDE_VALUES u
             WHERE ACCOUNT_NUMBER = pLoan
               AND UDE_ID ='INTEREST_RATE'
               and EFFECTIVE_DATE = v_loan_details.VALUE_DATE
                 ;
            -- PRPL_EXPECTED
            SELECT a.AMOUNT
              into res_row.PRPL_EXPECTED
              FROM table(v_event_entries)  a
             WHERE a.ACCOUNT_NUMBER  = pLoan
               AND a.COMPONENT_NAME='PRINCIPAL'
               AND a.VALUE_DATE = v_loan_details.VALUE_DATE
               AND EVENT_CODE ='DSBR'
               and EVENT_SEQ_NO < 5
                 ;
        else
            SELECT UDE_VALUE
              into res_row.INT_RATE
              from fcc.CLTB_ACCOUNT_UDE_VALUES u
             WHERE ACCOUNT_NUMBER = pLoan
               AND UDE_ID ='INTEREST_RATE'
               and EFFECTIVE_DATE <= res_row.TO_DATE
               and not exists (select 1
                                 from fcc.CLTB_ACCOUNT_UDE_VALUES x
                                where u.ACCOUNT_NUMBER = x.ACCOUNT_NUMBER
                                  and u.UDE_ID = x.UDE_ID
                                  and x.EFFECTIVE_DATE <= res_row.TO_DATE
                                  and u.EFFECTIVE_DATE < x.EFFECTIVE_DATE)
                 ;
        end if;

        -- EMI_AMOUNT
        begin
            SELECT a.EMI_AMOUNT
              into res_row.EMI_AMOUNT_FCC
              FROM fcc.CLTB_ACCOUNT_SCHEDULES a
             WHERE a.ACCOUNT_NUMBER = pLoan
               AND a.SCHEDULE_DUE_DATE = res_row.TO_DATE
               AND a.SCHEDULE_DUE_DATE < v_loan_details.MATURITY_DATE
               AND a.COMPONENT_NAME = 'MAIN_INT'
                 ;
        exception
            when no_data_found then
                null;
        end;

        -- PREPAID_INT_PARENT PREPAID_PRPL_PARENT
        SELECT SUM(case when COMPONENT_NAME='PRINCIPAL' then AMOUNT_PAID end) PREPAID_PRPL_PARENT
             , SUM(case when COMPONENT_NAME='MAIN_INT' then AMOUNT_PAID end) PREPAID_INT_PARENT
          into res_row.PREPAID_PRPL_PARENT, res_row.PREPAID_INT_PARENT
          FROM table(v_AMOUNT_PAID) p
         WHERE p.ACCOUNT_NUMBER = pLoan
           AND PAID_DATE = res_row.TO_DATE
           AND DUE_DATE > PAID_DATE
           AND nvl(settle_acc, '-') NOT LIKE '%SALH1%' -- Exclude transfer to tech.loan
             ;

        -- PRPL_INCR
        SELECT SUM(AMOUNT) AMOUNT
          into res_row.PRPL_INCR
          FROM table(v_event_entries)
         WHERE ACCOUNT_NUMBER = pLoan
           AND AMOUNT_TAG = 'PRINCIPAL_INCR'
           AND VALUE_DATE = res_row.TO_DATE
             ;

        -- INT_TO_H1, S.Golovan. 21.04.21, 18.05.21
        -- #MULTIPLE_HOLIDAYS, New rules, S.Golovan's letter, 29.03.2022
        select sum(amount)
          into res_row.INT_TO_H1
          from table(v_event_entries) e
         where e.account_number = pLoan
           and e.event_code = 'MLIQ'
           and Amount_Tag = 'MAIN_INT_DLIQ'
           and Sttl_Acc like '%SALH1%'
           and e.value_date = res_row.TO_DATE
           and (exists (select * from table(fn_get_all_holiday_details(pLoan)) where CAPITALIZATION_FLAG = 'Y' and res_row.TO_DATE between hol_end-20 and hol_end+20) -- Holidays with capitalization
                or v_loan_details.LOAN_TYPE = 'CONSUMER/CAR'
               )
             ;



        if i.date_type like 'First%' then
            -- ACCR_INT
            res_row.ACCR_INT := res_row.PRPL_EXPECTED
                                * res_row.INT_RATE / 100
                                * (res_row.TO_DATE-res_row.FROM_DATE) / GET_DAYS_IN_YEAR(res_row.TO_DATE);

            v_prev_PRPL_EXPECTED_TOTAL := res_row.PRPL_EXPECTED; -- S.Golovan, 19/03/21
            v_prev_INT_EXPECTED_TOTAL  := 0;

            if res_row.EMI_AMOUNT_FCC is not null then
                if ROUND(res_row.ACCR_INT,2) > res_row.EMI_AMOUNT_FCC then
                    res_row.POSTP_INT      := ROUND(res_row.ACCR_INT,2) - res_row.EMI_AMOUNT_FCC;
                    res_row.INT_DUE_FCC    := res_row.EMI_AMOUNT_FCC;
                    res_row.PRPL_DUE       := 0;
                    res_row.INT_DUE_AGR    := res_row.INT_DUE_FCC;
                    res_row.EMI_AMOUNT_AGR := res_row.EMI_AMOUNT_FCC;
                else
                    res_row.POSTP_INT   := 0;
                    res_row.INT_DUE_FCC := ROUND(res_row.ACCR_INT,2);
                    res_row.PRPL_DUE    := res_row.EMI_AMOUNT_FCC - res_row.INT_DUE_FCC;
                    res_row.EMI_AMOUNT_AGR := res_row.EMI_AMOUNT_FCC - v_sum_PREPAID_INT_PARENT;
                    res_row.INT_DUE_AGR    := res_row.INT_DUE_FCC - nvl(res_row.INT_TO_H1, 0);
                end if;
            else -- EMI_AMOUNT is null - technical row
                v_sum_ACCR_INT           := v_sum_ACCR_INT + res_row.ACCR_INT;
                v_sum_PREPAID_INT_PARENT := v_sum_PREPAID_INT_PARENT + nvl(res_row.PREPAID_INT_PARENT, 0);
            end if;
            v_prev_POSTP_INT           := nvl(res_row.POSTP_INT,0);
        elsif i.date_type like '%Last date%' and (res_row.EMI_AMOUNT_FCC is not null or res_row.TO_DATE = v_loan_details.MATURITY_DATE) then
            res_row.PRPL_EXPECTED := nvl(v_prev_PRPL_EXPECTED, 0) - nvl(v_prev_PREPAID_PRPL_PARENT, 0) + nvl(v_prev_PRPL_INCR, 0) - nvl(v_prev_PRPL_DUE, 0); -- S.Golovan, 14.01.21
            res_row.PRPL_EXPECTED := greatest(res_row.PRPL_EXPECTED, 0); -- HOL_FLAG=H in the end of loan life
            -- ACCR_INT
            res_row.ACCR_INT := res_row.PRPL_EXPECTED
                                * res_row.INT_RATE / 100
                                * (res_row.TO_DATE-res_row.FROM_DATE) / GET_DAYS_IN_YEAR(res_row.TO_DATE);
            v_var := v_sum_ACCR_INT + res_row.ACCR_INT + v_prev_POSTP_INT;
            res_row.INT_DUE_FCC   := ROUND(v_var - v_sum_PREPAID_INT_PARENT, 2);
            if res_row.TO_DATE = v_loan_details.MATURITY_DATE then
                res_row.PRPL_DUE  := res_row.PRPL_EXPECTED;
            elsif res_row.INT_DUE_FCC > res_row.EMI_AMOUNT_FCC then  -- S.Glovan letter, 13.01.2021
                res_row.POSTP_INT   := res_row.INT_DUE_FCC-res_row.EMI_AMOUNT_FCC;
                res_row.INT_DUE_FCC := res_row.EMI_AMOUNT_FCC;
                res_row.INT_DUE_AGR := res_row.EMI_AMOUNT_AGR;
                res_row.PRPL_DUE    := 0;
            else
                res_row.PRPL_DUE := res_row.EMI_AMOUNT_FCC - v_sum_PREPAID_INT_PARENT - res_row.INT_DUE_FCC;
            end if;
        else -- n-row
            res_row.PRPL_EXPECTED := nvl(v_prev_PRPL_EXPECTED, 0) - nvl(v_prev_PREPAID_PRPL_PARENT, 0) + nvl(v_prev_PRPL_INCR, 0) - nvl(v_prev_PRPL_DUE, 0); -- S.Golovan, 14.01.21
            res_row.PRPL_EXPECTED := greatest(res_row.PRPL_EXPECTED, 0); -- HOL_FLAG=H in the end of loan life
            -- ACCR_INT
            res_row.ACCR_INT := res_row.PRPL_EXPECTED
                                * res_row.INT_RATE / 100
                                * (res_row.TO_DATE-res_row.FROM_DATE) / GET_DAYS_IN_YEAR(res_row.TO_DATE);

            if res_row.EMI_AMOUNT_FCC is not null then
                res_row.EMI_AMOUNT_AGR := res_row.EMI_AMOUNT_FCC - v_sum_PREPAID_INT_PARENT - nvl(res_row.INT_TO_H1, 0); -- INT_TO_H1, S.Golovan. 21.04.21
                v_var := v_sum_ACCR_INT + res_row.ACCR_INT + v_prev_POSTP_INT;

                if v_var > res_row.EMI_AMOUNT_FCC then
                    res_row.INT_DUE_FCC := res_row.EMI_AMOUNT_FCC;
                    res_row.INT_DUE_AGR := res_row.EMI_AMOUNT_AGR;
                    res_row.POSTP_INT   := v_var - res_row.INT_DUE_FCC;
                    res_row.PRPL_DUE    := 0;
                else
                    res_row.INT_DUE_FCC := round(v_var, 2);
                    res_row.INT_DUE_AGR := round(v_var - v_sum_PREPAID_INT_PARENT - nvl(res_row.INT_TO_H1, 0),2);
                    -- EMI_AMOUNT in FC increased by PREPAID_INT
                    res_row.PRPL_DUE := res_row.EMI_AMOUNT_AGR - res_row.INT_DUE_AGR;
                end if;

--                Похоже эти строки нужно убрать. S.Golovan 11.01.2021
--                if res_row.PREPAID_PRPL_PARENT > res_row.PRPL_DUE then
--                    res_row.PREPAID_PRPL_PARENT := res_row.PREPAID_PRPL_PARENT - res_row.PRPL_DUE;
--                else
--                    res_row.PREPAID_PRPL_PARENT := 0;
--                end if;

                -- Checks
                if v_sum_PREPAID_INT_PARENT > 0 and mod(res_row.EMI_AMOUNT_FCC-v_sum_PREPAID_INT_PARENT,1)>0 -- non-integer
                then
                    res_row.ERROR_DESC := res_row.ERROR_DESC || 'EMI_AMOUNT-PREPAID_INTEREST is non-integer: '||to_char(res_row.EMI_AMOUNT_FCC-v_sum_PREPAID_INT_PARENT);
                end if;

                v_sum_ACCR_INT           := 0;
                v_sum_PREPAID_INT_PARENT := 0;
                v_prev_POSTP_INT         := nvl(res_row.POSTP_INT,0);
            else -- EMI_AMOUNT is null - technical row
                v_sum_ACCR_INT           := v_sum_ACCR_INT + res_row.ACCR_INT;
                v_sum_PREPAID_INT_PARENT := v_sum_PREPAID_INT_PARENT + nvl(res_row.PREPAID_INT_PARENT, 0);

                if v_sum_PREPAID_INT_PARENT > 0 and v_sum_PREPAID_INT_PARENT <> round(nvl(v_sum_ACCR_INT, 0) + nvl(v_prev_POSTP_INT, 0), 2) then
                    res_row.ERROR_DESC := res_row.ERROR_DESC || 'PREPAID_INT <> ACCR_INT+POSTP_INT ('||v_sum_PREPAID_INT_PARENT||'<>'||round(nvl(v_sum_ACCR_INT, 0) + nvl(v_prev_POSTP_INT, 0), 2)||')';
                end if;
            end if;
        end if;

        -- RESTR_DATE. S.Golovan, 20.05.21
        -- #MULTIPLE_HOLIDAYS. S.Golovan, 29.03.22
        for i in (select *
                    from table(fn_get_all_holiday_details(pLoan))
                   where res_row.TO_DATE between hol_start and hol_end
                     and nvl(CAPITALIZATION_FLAG, '-') <> 'Y'
                     and res_row.HOL_FLAG = 'Y'                -- conditions from pl/sql
                     and nvl(res_row.EMI_AMOUNT_FCC, 0) <> 0
                     and v_loan_details.LOAN_TYPE = 'MORTGAGE'
                 )
        loop
            if nvl(v_hol_no, 0) <> i.hol_no then
                v_hol_no    := i.hol_no;
                v_HOL_count := 1;
            end if;

            begin
                select schedule_due_date
                  into res_row.RESTR_DATE
                  from (select s.schedule_due_date
                             , row_number() over (partition by s.COMPONENT_NAME order by schedule_no) rn
                          from fcc.CLTB_ACCOUNT_SCHEDULES s
                         where s.ACCOUNT_NUMBER = i.loan_h1
                           AND s.COMPONENT_NAME = 'PRINCIPAL')
                  where rn = v_HOL_count
                      ;
            exception
                when no_data_found then
                    null;
            end;
            v_HOL_count := v_HOL_count + 1;
        end loop;



        -- Checks
        if i.date_type like '%Last date%' then
            declare
                v_fc_principal      number;
                v_fc_prcpl_prepaid  number;
            begin
                SELECT SUM(AMOUNT_DUE)
                  into v_fc_principal
                  FROM fcc.CLTB_ACCOUNT_SCHEDULES
                 WHERE ACCOUNT_NUMBER = pLoan
                   AND COMPONENT_NAME ='PRINCIPAL'
                   AND SCHEDULE_DUE_DATE >= least(nvl(pDate, v_loan_details.today), v_loan_details.maturity_date)
                     ;

                SELECT SUM(AMOUNT_PAID)
                  into v_fc_prcpl_prepaid
                  FROM table(v_AMOUNT_PAID)
                 WHERE ACCOUNT_NUMBER = pLoan
                   AND COMPONENT_NAME ='PRINCIPAL'
                   AND PAID_DATE >= least(nvl(pDate, v_loan_details.today), v_loan_details.maturity_date)
                   AND DUE_DATE > PAID_DATE
                     ;

                if res_row.PRPL_EXPECTED/*-nvl(res_row.PRPL_DUE, 0)*/ <> nvl(v_fc_principal,0)+nvl(v_fc_prcpl_prepaid,0) then
                    res_row.ERROR_DESC := res_row.ERROR_DESC || 'Report principal <> FC principal ('||to_char(res_row.PRPL_EXPECTED/*-nvl(res_row.PRPL_DUE, 0)*/) ||'<>'|| to_char(nvl(v_fc_principal,0)+nvl(v_fc_prcpl_prepaid,0))||'). ';
                else
                    res_row.ERROR_DESC := res_row.ERROR_DESC || 'Report principal = FC principal ('||to_char(res_row.PRPL_EXPECTED/*-nvl(res_row.PRPL_DUE, 0)*/) ||'='|| to_char(nvl(v_fc_principal,0)+nvl(v_fc_prcpl_prepaid,0))||') ';
                end if;

            end;
        end if;

        -- Updates amounts from technical loans
        if v_tech_repayments.count > 0 then
            for i in v_tech_repayments.first..v_tech_repayments.last loop
                if v_tech_repayments(i).to_date = res_row.to_date then
                    res_row.HOL_FlAG := 'H';
                    res_row.ACCOUNT_NUMBER := NULL; -- S.Golovan, 15/04/2021 v_tech_repayments(i).ACCOUNT_NUMBER;
                    v_tech_repayments(i).HOL_FlAG := 'H'; -- Mark as processed

                    if nvl(res_row.INT_DUE_FCC, 0) <> 0 then
                        res_row.ERROR_DESC := res_row.ERROR_DESC || 'Parent INT_DUE_FCC=' || res_row.INT_DUE_FCC || '. ';
                    end if;

                    res_row.INT_DUE_FCC := nvl( res_row.INT_DUE_FCC, 0) + nvl(v_tech_repayments(i).INT_DUE_FCC, 0);

                    if nvl(res_row.INT_DUE_AGR, 0) <> 0 then
                        res_row.ERROR_DESC := res_row.ERROR_DESC || 'Parent INT_DUE_AGR=' || res_row.INT_DUE_AGR || '. ';
                    end if;

                    res_row.INT_DUE_AGR := nvl(res_row.INT_DUE_AGR, 0) + nvl(v_tech_repayments(i).INT_DUE_AGR, 0);

                    if nvl(res_row.PRPL_DUE, 0) <> 0 then
                        res_row.ERROR_DESC := res_row.ERROR_DESC || 'Parent PRPL_DUE=' || res_row.PRPL_DUE || '. ';
                    end if;

                    res_row.PRPL_DUE := nvl(res_row.PRPL_DUE, 0) + nvl(v_tech_repayments(i).PRPL_DUE, 0);

                    res_row.PREPAID_INT_CHILD := v_tech_repayments(i).PREPAID_INT_CHILD;
                    res_row.PREPAID_PRPL_CHILD := v_tech_repayments(i).PREPAID_PRPL_CHILD;

                end if;
            end loop;
        end if;

        -- S.Golovan, 04/05/2021
        -- #MULTIPLE_HOLIDAYS
        for i in (select *
                    from table(fn_get_all_holiday_details (pLoan))
                   where res_row.FROM_DATE = HOL_END
                     and res_row.EMI_AMOUNT_AGR = 0 AND res_row.EMI_AMOUNT_FCC <> 0 -- conditions from pl/sql
                 )
        loop
            res_row.add_info := append_text(res_row.add_info, 'Accrual after Holidays');
        end loop;

        -- S.Golovan, 19/03/2021
        IF v_prev_HOL_FLAG = 'Y' -- One schedule shift
           and v_loan_details.LOAN_TYPE <> 'CONSUMER/CAR' -- S.Golovan. 21.04.21
           and GET_CAPITALIZATION_FLAG(pLoan, res_row.TO_DATE) <> 'Y' -- S.Golovan. 04.05.21 -- #MULTIPLE_HOLIDAYS
        then
            res_row.PRPL_EXPECTED_TOTAL := nvl(v_prev_PRPL_EXPECTED_TOTAL, 0) - nvl(v_prev_PREPAID_PRPL_PARENT, 0) + nvl(v_prev_PRPL_INCR, 0); -- Without PRPL_DUE
            -- Если ипотека, то в период каникул INT_DUE_AGR = 0 всегда. S.Golovan, 05.05.21
            res_row.INT_EXPECTED_TOTAL  := round(nvl(v_prev_INT_EXPECTED_TOTAL, 0) + nvl(res_row.ACCR_INT, 0) /*+ nvl(v_prev_POSTP_INT2, 0)*/ - nvl(v_prev_PREPAID_INT_PARENT, 0) - nvl(v_prev_PREPAID_INT_CHILD, 0) --#INC000746822_INT_EXPECTED_TOTAL
                                                 - case when i.date_type like '%Capitalization%' then nvl(res_row.INT_TO_H1, 0) else 0 end  -- S.Golovan's letter. 10.06.22
                                                , 2);
        else
            res_row.PRPL_EXPECTED_TOTAL := nvl(v_prev_PRPL_EXPECTED_TOTAL, 0) - nvl(v_prev_PREPAID_PRPL_PARENT, 0) + nvl(v_prev_PRPL_INCR, 0) - nvl(v_prev_PRPL_DUE, 0)
--                                           - case when res_row.ACCOUNT_NUMBER<>res_row.PARENT_ACCOUNT_NUMBER then res_row.PRPL_DUE else 0 end -- PRPL_DUE in tech.loan
                                      ;
            res_row.INT_EXPECTED_TOTAL  := round(nvl(v_prev_INT_EXPECTED_TOTAL, 0) + nvl(res_row.ACCR_INT, 0) /*+ nvl(v_prev_POSTP_INT2, 0)*/ - nvl(v_prev_PREPAID_INT_PARENT, 0) - nvl(v_prev_PREPAID_INT_CHILD, 0) - nvl(v_prev_INT_DUE_AGR, 0) -- Without INT_DUE_AGR; --#INC000746822_INT_EXPECTED_TOTAL
                                                 - case when i.date_type like '%Capitalization%' then nvl(res_row.INT_TO_H1, 0) else 0 end  -- S.Golovan's letter. 10.06.22
                                                , 2);
        end if;

        if res_row.PRPL_EXPECTED >= 0 then
            v_prev_PRPL_EXPECTED        := res_row.PRPL_EXPECTED;
        end if;
        v_prev_PREPAID_PRPL_PARENT  := res_row.PREPAID_PRPL_PARENT;
        v_prev_PRPL_DUE             := res_row.PRPL_DUE;
        v_prev_PRPL_INCR            := res_row.PRPL_INCR;

        v_prev_PRPL_EXPECTED_TOTAL  := res_row.PRPL_EXPECTED_TOTAL;
        v_prev_INT_EXPECTED_TOTAL   := res_row.INT_EXPECTED_TOTAL;
        v_prev_INT_DUE_AGR          := res_row.INT_DUE_AGR;
        v_prev_HOL_FLAG             := res_row.HOL_FLAG;
        --v_prev_POSTP_INT2           := res_row.POSTP_INT; -- Not required. S.Golovan, 04/05/21
        v_prev_PREPAID_INT_PARENT   := res_row.PREPAID_INT_PARENT; --#INC000746822_INT_EXPECTED_TOTAL
        v_prev_PREPAID_INT_CHILD    := res_row.PREPAID_INT_CHILD;  --#INC000746822_INT_EXPECTED_TOTAL

        pipe row(res_row);
    end loop;

    -- Show unmarked Tech loans repayments
    if v_tech_repayments.count > 0 then
        for i in v_tech_repayments.first..v_tech_repayments.last loop
            if nvl(v_tech_repayments(i).HOL_FlAG, '-') <> 'H' then
                res_row := null;
                res_row.ACCOUNT_NUMBER        := v_tech_repayments(i).ACCOUNT_NUMBER;
                res_row.PARENT_ACCOUNT_NUMBER := pLoan;
                res_row.TO_DATE               := v_tech_repayments(i).TO_DATE;
                res_row.HOL_FlAG              := 'H';
                res_row.INT_DUE_FCC           := v_tech_repayments(i).INT_DUE_FCC;
                res_row.INT_DUE_AGR           := v_tech_repayments(i).INT_DUE_AGR;
                res_row.PRPL_DUE              := v_tech_repayments(i).PRPL_DUE;
                res_row.PREPAID_INT_CHILD     := v_tech_repayments(i).PREPAID_INT_CHILD;
                res_row.PREPAID_PRPL_CHILD    := v_tech_repayments(i).PREPAID_PRPL_CHILD;
                res_row.ADD_INFO              := v_tech_repayments(i).ADD_INFO;
                res_row.ERROR_DESC            := 'No schedule in parent loan';

                pipe row(res_row);
            end if;
        end loop;
    end if;

END;

function GET_LOAN_REPAYMENT_ACTUAL (pLoan in varchar2) return LOAN_REPAYMENT_ACTUAL_tbl_t pipelined
as
    res_row LOAN_REPAYMENT_ACTUAL_row_t;
begin

    COLLECT_EVENT_ENTRIES (pLoan);

    for i in (select p.ACCOUNT_NUMBER
                   , p.PAID_DATE
                   , p.loan_type
                   , sum(p.PAID_INTEREST) PAID_INTEREST
                   , sum(p.PAID_PRINCIPAL) PAID_PRINCIPAL
                   , count(*) - count(distinct row_id) multipl_flag -- If several records with same account_number+event_seq_no exist in CLTB_LIQ_SETTLEMENTS. S.Golovan, 25.02.21
                   , count(case when settle_acc LIKE '%SALH1%' and nvl(p.PAID_INTEREST, 0) <> 0 then 1 end) INTEREST_TECH_FLAG
                   , count(case when settle_acc LIKE '%SALH1%' and nvl(p.PAID_PRINCIPAL, 0) <> 0 then 1 end) PRINCIPAL_TECH_FLAG
                from (select a.ACCOUNT_NUMBER
                           , PAID_DATE
                           , case when COMPONENT_NAME = 'PRINCIPAL' and tech_loan_type in ('H1', 'R1', 'O1')  then AMOUNT_PAID
                                  when COMPONENT_NAME = 'MAIN_INT' and tech_loan_type is null then AMOUNT_PAID
                             end PAID_INTEREST
                           , case when COMPONENT_NAME = 'PRINCIPAL' and tech_loan_type in ('HA', 'OA') then AMOUNT_PAID
                                  when COMPONENT_NAME = 'PRINCIPAL' and tech_loan_type is null then AMOUNT_PAID
                             end PAID_PRINCIPAL
                           , a.row_id
                           , a.event_seq_no
                           , tech_loan_type loan_type
                           , settle_acc
                        FROM (select * from table(GET_ALL_LOANS(pLoan)) /*where tech_loan_type not like 'O%' S.Golovan. 24.03.21*/) l
                        join table(v_AMOUNT_PAID) a on l.ACCOUNT_NUMBER = a.ACCOUNT_NUMBER
                       where not (nvl(tech_loan_type, '-') = 'O1' and a.due_date = l.maturity_date) -- Исключение реструктурированного долга  по компоненте INT_ON_OVD_P
                         AND COMPONENT_NAME in ('MAIN_INT', 'PRINCIPAL')
                     ) p
               group by p.ACCOUNT_NUMBER, p.PAID_DATE, p.loan_type
              having sum(p.PAID_INTEREST) <> 0 or sum(p.PAID_PRINCIPAL) <> 0 -- #INC000746822
               order by p.PAID_DATE, p.ACCOUNT_NUMBER
             )
    loop
        res_row := null;

        res_row.PARENT_ACCOUNT_NUMBER := pLoan;
        res_row.ACCOUNT_NUMBER        := i.ACCOUNT_NUMBER;
        res_row.PAID_DATE             := i.PAID_DATE;
        res_row.PAID_INTEREST         := i.PAID_INTEREST;
        res_row.PAID_PRINCIPAL        := i.PAID_PRINCIPAL;
        res_row.INTEREST_TECH_FLAG    := i.INTEREST_TECH_FLAG;
        res_row.PRINCIPAL_TECH_FLAG   := i.PRINCIPAL_TECH_FLAG;
        res_row.LOAN_TYPE             := i.LOAN_TYPE;
        if nvl(i.multipl_flag, 0) > 0 then
            res_row.ADD_INFO          := 'Can''t compile report correctly, many records in CLTB_LIQ_SETTLEMENTS: '||i.multipl_flag;
        end if;

        pipe row(res_row);
    end loop;
end;

function GET_COMPONENT (pComponent in varchar2, pTechLoanType in varchar2) return varchar2
as
begin
    return case when pTechLoanType is null and pComponent = 'MAIN_INT' then pComponent
                else 'PRINCIPAL'
           end;
end;

function GET_PENALTY_DATES (pLoan in varchar2, pDate in date, pComponent in varchar2, pUDE_ID in varchar2) return DATES_tbl_t pipelined
as
    date_row DATES_row_t;
begin

    COLLECT_EVENT_ENTRIES (pLoan);
    COLLECT_LOAN_DETAILS(pLoan);

    for i in (select *
                from (-- Overdue
                      SELECT schedule_due_date FROM_DATE -- S.Golovan, 06.05.21
                           , 'Overdue' DATE_TYPE
                           , nvl(amount_due, 0) - nvl(sum(p.amount_paid), 0) amt
                        FROM fcc.CLTB_ACCOUNT_SCHEDULES s
                        left join table(v_AMOUNT_PAID) p
                                             on s.account_number    = p.account_number
                                            AND s.COMPONENT_NAME    = p.COMPONENT_NAME
                                            and s.schedule_due_date = p.due_date
                                            and ((p.due_date >= p.paid_date and pComponent = 'MAIN_INT')
                                                  or
                                                 (p.due_date = p.paid_date and pComponent = 'PRINCIPAL'))
                       WHERE 1=1
                         AND s.account_number = pLoan
                         AND s.COMPONENT_NAME = GET_COMPONENT(pComponent, v_loan_details.tech_loan_type)
                         AND schedule_due_date < least(pDate, v_loan_details.today)
                         AND nvl(v_loan_details.tech_loan_type, '-') not like 'O_'
                       group by schedule_due_date, amount_due
                      having nvl(amount_due, 0) - nvl(sum(p.amount_paid), 0) > 0
                      -- Overdue payment
                      UNION ALL
                      SELECT /*case when PAID_DATE >=  DUE_DATE then PAID_DATE
                                  else DUE_DATE
                             end*/
                             PAID_DATE FROM_DATE -- S.Golovan, 07.05.2021
                           , 'Overdue payment' DATE_TYPE
                           , sum(AMOUNT_PAID)
                        FROM table(v_AMOUNT_PAID) p
                       WHERE p.account_number = pLoan
                         AND p.COMPONENT_NAME = GET_COMPONENT(pComponent, v_loan_details.tech_loan_type)
                         /*AND case when PAID_DATE >=  DUE_DATE then PAID_DATE
                                  else DUE_DATE
                             end <= nvl(pDate, v_loan_details.today)
                         AND EXEC_DATE >  DUE_DATE -- Overdue payment*/
                         AND EXEC_DATE >= PAID_DATE
                         AND PAID_DATE > DUE_DATE
                         AND nvl(settle_acc, '-') NOT LIKE '%SALH1%' -- Exclude transfer to tech.loan
                         AND (v_loan_details.TECH_LOAN_TYPE is null
                              or (v_loan_details.TECH_LOAN_TYPE in ('HA','OA') and pComponent = 'PRINCIPAL')
                              or (v_loan_details.TECH_LOAN_TYPE in ('H1','O1') and pComponent = 'MAIN_INT'))
                         AND NOT (nvl(v_loan_details.TECH_LOAN_TYPE, '-') = 'O1' and DUE_DATE = v_loan_details.maturity_date) -- Погашение просрочки платежа, дата которого совпадвет с датой Maturity кредита O1 должно игнорироваться. S.Golovan, 23.04.21
                         AND NOT (nvl(v_loan_details.TECH_LOAN_TYPE, '-') = 'O1' and GET_HOL_TYPE(pLoan, PAID_DATE) = 'R43' and GET_CAPITALIZATION_FLAG(pLoan, PAID_DATE) <> 'Y') -- Restructuring ODUE_INT->INT. S.Golovan, 14.05.21 -- #MULTIPLE_HOLIDAYS
                         AND PAID_DATE < least(pDate, v_loan_details.today) -- #INC000720388
                       GROUP BY PAID_DATE
                                /*case when PAID_DATE >=  DUE_DATE then PAID_DATE
                                     else DUE_DATE
                                end*/
                      HAVING SUM (AMOUNT_PAID) !=0
                      -- Last day of the year when next year has different days quantity
                      union all
                      SELECT from_date, 'Last day of the year', null from table(GET_LAST_DATES_OF_YEAR(v_loan_details.VALUE_DATE, nvl(pDate,v_loan_details.TODAY)))
                      -- Penalty rate change
                      union all
                      SELECT (EFFECTIVE_DATE - 1) FROM_DATE, 'Penalty rate change', null
                        FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                       WHERE ACCOUNT_NUMBER = pLoan
                         AND UDE_ID = pUDE_ID
                         AND (EFFECTIVE_DATE - 1) <= nvl(pDate, v_loan_details.today)
                         AND v_loan_details.TECH_LOAN_TYPE is null -- Поиск значений штрафных ставок (из родительского кредита). S.Golovan 23.04.2021
                      -- Поиск значений ставок из кредита ОА - в период каникул. S.Golovan, 23.04.21 -- #MULTIPLE_HOLIDAYS
                      union all
                      SELECT (EFFECTIVE_DATE - 1) FROM_DATE, 'Penalty rate change', null
                        FROM fcc.CLTB_ACCOUNT_UDE_VALUES u
                        join table(fn_get_all_holiday_details(v_loan_details.parent_loan)) h on EFFECTIVE_DATE - 1 between hol_start-1 and hol_end
                       WHERE u.ACCOUNT_NUMBER = pLoan
                         AND UDE_ID = 'INT_OVD_RATE'
                         AND (EFFECTIVE_DATE - 1) <= nvl(pDate, v_loan_details.today)
                         AND v_loan_details.TECH_LOAN_TYPE = 'OA'
                      -- Holiday start&end #MULTIPLE_HOLIDAYS
                      union all
                      select hol_start-1, 'Holiday start-1 '||row_number() over (partition by account_number order by hol_start), null
                        from table(fn_get_all_holiday_details(pLoan))
                       where hol_start <= nvl(pDate, v_loan_details.today)
                      union all
                      select hol_end, 'Holiday end '||row_number() over (partition by account_number order by hol_start), null
                        from table(fn_get_all_holiday_details(pLoan))
                       where hol_end <= nvl(pDate, v_loan_details.today)
                      -- Last date
                      union all
                      select nvl(pDate, v_loan_details.today), 'Last date', null
                        from dual
                      )
               order by FROM_DATE
             )
    loop
        date_row := null;
        date_row.FROM_DATE := i.FROM_DATE;
        date_row.DATE_TYPE := i.DATE_TYPE;
        date_row.amt       := i.amt;

        pipe row(date_row);
    end loop;
exception
    when others then
        fcc.dbg.error(pLoan||' ERR:' || SQLCODE || ' ' || SQLERRM, 'FCCUCB.LH_REP2361_v6.GET_PENALTY_DATES');
        raise;
end;

function GET_LOAN_INT_ON_OVD_P_CALC2 (pLoan in varchar2, pDate in date) return LOAN_INT_ON_OVD_P_tbl_t pipelined
as
begin

    COLLECT_EVENT_ENTRIES (pLoan);
    COLLECT_LOAN_DETAILS(pLoan);

    for t in (select x.account_number o1_loan, x.maturity_date
                from table(GET_TECH_LOANS(pLoan)) x
               where tech_loan_type = 'O1')
    loop

        declare -- #MULTIPLE_HOLIDAYS. D.Shatskiy, 20/04/2022
            v_bullet_amt    number;
            v_paid_qty      number :=0;
            res_row         LOAN_INT_ON_OVD_P_row_t;
        begin

            res_row.PARENT_ACCOUNT_NUMBER := pLoan;
            res_row.ACCOUNT_NUMBER        := t.o1_loan;

            for s in (select * -- Get amount from bullet schedule in O1 loan
                        from (select amount_due
                                   , row_number() over (partition by account_number order by schedule_due_date desc) rn
                                from fcc.cltb_account_schedules
                               where account_number = t.o1_loan
                                 and component_name = 'PRINCIPAL')
                       order by rn)
            loop
                if s.rn = 1 and nvl(s.amount_due, 0) <> 0 then -- Bullet schedule
                    v_bullet_amt := s.amount_due;
                elsif s.rn = 2 then -- If amount_due in bullet schedule = 0, than default on loan have been. In this case we take amount_due from last but one schedule.
                    v_bullet_amt := s.amount_due;
                else
                    exit; -- analyze only 2 last schedules
                end if;
            end loop;

            --First row
            begin
                SELECT sum(AMOUNT_PAID) AMOUNT_DUE, DUE_DATE
                  into res_row.AMOUNT_DUE, res_row.FROM_DATE
                  FROM table(v_AMOUNT_PAID)
                 WHERE ACCOUNT_NUMBER = pLoan
                   AND COMPONENT_NAME = 'INT_ON_OVD_P'
                   AND DUE_DATE in (SELECT VALUE_DATE D1
                                      FROM table(v_event_entries)
                                     WHERE ACCOUNT_NUMBER = pLoan
                                       AND AMOUNT_TAG = 'INT_ON_OVD_P_LIQD'
                                       AND DR_ACC LIKE '%SALH1%') -- #MULTIPLE_HOLIDAYS. D.Shatskiy, 20/04/2022 --FCJ-683 SALH1

                 group by DUE_DATE
                having sum(AMOUNT_PAID) = v_bullet_amt -- If bullet_amt are equal in 2 loans, than we will come up with new slution
                     ;
            exception
                when no_data_found then
                    res_row.ERROR_DESC := 'Can''t find First AMOUNT_DUE and FROM_DATE. no_data_found. o1_loan='||t.o1_loan||', v_bullet_amt='||v_bullet_amt;
                    pipe row(res_row);
                    return;
                when too_many_rows then
                    res_row.ERROR_DESC := 'Can''t find First AMOUNT_DUE and FROM_DATE. too_many_rows. o1_loan='||t.o1_loan||', v_bullet_amt='||v_bullet_amt;
                    pipe row(res_row);
                    return;
                when others then
                    res_row.ERROR_DESC := 'Can''t find First AMOUNT_DUE and FROM_DATE. others. o1_loan='||t.o1_loan||', v_bullet_amt='||v_bullet_amt;
                    pipe row(res_row);
                    return;
            end;

            if res_row.FROM_DATE > pDate then
                continue;
            end if;

            for i in (SELECT ACCOUNT_NUMBER
                           , PAID_DATE
                           , sum(AMOUNT_PAID) AMOUNT_PAID
                        FROM table(v_AMOUNT_PAID)
                       WHERE ACCOUNT_NUMBER = t.o1_loan
                         AND COMPONENT_NAME = 'PRINCIPAL'
                         AND DUE_DATE = t.maturity_date
                         and PAID_DATE <= pDate
                       GROUP BY ACCOUNT_NUMBER, PAID_DATE
                       order by PAID_DATE)

            loop
                res_row.to_date     := i.PAID_DATE;
                res_row.AMOUNT_PAID := i.AMOUNT_PAID;
                pipe row(res_row);
                v_paid_qty := v_paid_qty + 1;

                res_row.from_date   := res_row.to_date;
                res_row.AMOUNT_DUE  := nvl(res_row.AMOUNT_DUE, 0) - nvl(res_row.AMOUNT_PAID, 0);
            end loop;

            if v_paid_qty = 0 then
                res_row.to_date     := pDate;
                pipe row(res_row);
            end if;

        end;

    end loop;
end;

function GET_LOAN_PENALTY_I_CALC (pLoan in varchar2, pDate in date) return LOAN_PENALTY_CALC_tbl_t pipelined
as
    v_component      varchar2(50)            := 'MAIN_INT';
    v_UDE_ID         varchar2(50)            := 'PENALTY_RATE';
begin
    for i in (select *
                from table(GET_LOAN_PENALTY_CALC(pLoan, pDate, v_component, v_UDE_ID))
               order by from_date
             )
    loop
        pipe row(i);
    end loop;
end;

function GET_LOAN_PENALTY_P_CALC (pLoan in varchar2, pDate in date) return LOAN_PENALTY_CALC_tbl_t pipelined
as
    v_component      varchar2(50)            := 'PRINCIPAL';
    v_UDE_ID         varchar2(50)            := 'PENALTY_RATE';
begin
    for i in (select *
                from table(GET_LOAN_PENALTY_CALC(pLoan, pDate, v_component, v_UDE_ID))
               order by from_date
             )
    loop
        pipe row(i);
    end loop;
end;

function GET_LOAN_INT_ON_OVD_P_CALC (pLoan in varchar2, pDate in date) return LOAN_PENALTY_CALC_tbl_t pipelined
as
    v_component      varchar2(50)            := 'PRINCIPAL';
    v_UDE_ID         varchar2(50)            := 'INT_OVD_RATE';
begin
    for i in (select *
                from table(GET_LOAN_PENALTY_CALC(pLoan, pDate, v_component, v_UDE_ID))
               order by from_date
             )
    loop
        pipe row(i);
    end loop;
end;

function GET_LOAN_PENALTY_CALC (pLoan in varchar2, pDate in date, pComponent in varchar2, pUDE_ID in varchar2) return LOAN_PENALTY_CALC_tbl_t pipelined
as
    res_row          LOAN_PENALTY_CALC_row_t;

    v_prev_OVD_AM         number;
    v_prev_OVD_PAID_AM    number;
begin
    if pDate < v_loan_details.value_date then
        res_row.ERROR_DESC := 'Report_date < Value_date';
        pipe row(res_row);
        return;
    elsif v_loan_details.AUTH_STAT <> 'A' then
        res_row.ERROR_DESC := 'Loan is under construction';
        pipe row(res_row);
    end if;

    COLLECT_LOAN_DETAILS(pLoan);
    -- Collect event_entries into variable for performance reason
    COLLECT_EVENT_ENTRIES (pLoan);

    for i in (with d as (select from_date
                              , date_type
                              , sum(amt) amt
                           from table(GET_ALL_LOANS (pLoan)) l
                           join table(GET_PENALTY_DATES(l.account_number, pDate, pComponent, pUDE_ID)) p on 1=1
                          where (TECH_LOAN_TYPE in ('H1','O1') and  pComponent = 'MAIN_INT')
                             or (TECH_LOAN_TYPE in ('HA','OA') and  pComponent = 'PRINCIPAL')
                             or (TECH_LOAN_TYPE is null)
                          group by from_date, date_type
                        )
              select FROM_DATE
                   , STSH_AMT
                   , lead(OVD_PAID_AMT) over (order by FROM_DATE) OVD_PAID_AMT -- Поиск OVD_PAID_AM вести для дат TO _DATE, а не для дат FROM _DATE. S.Golovan, 23.04.2021
                   , lead(FROM_DATE) over (order by FROM_DATE) TO_DATE
                   , date_type
                from (select FROM_DATE
                           , sum(case when date_type='Overdue' then amt end) STSH_AMT
                           , sum(case when date_type='Overdue payment' then amt end) OVD_PAID_AMT
                           , LISTAGG (date_type , ', ')
                              WITHIN GROUP (ORDER BY FROM_DATE desc) date_type
                        from d
                       where FROM_DATE >= (select min(FROM_DATE)
                                             from d
                                            where lower(date_type) like '%overdue%')
                       group by FROM_DATE)
               order by FROM_DATE)
    loop
        res_row := null;

        res_row.PARENT_ACCOUNT_NUMBER := pLoan;
        res_row.FROM_DATE             := i.FROM_DATE;
        res_row.TO_DATE               := i.TO_DATE;
        -- Do not skip last row -- S.Golovan, 25.03.2021
        if i.TO_DATE is null then
            res_row.TO_DATE := nvl(pDate, v_loan_details.today);
        end if;
        res_row.ADD_INFO              := i.date_type;
        res_row.STSH_AM               := i.STSH_AMT;
        res_row.OVD_PAID_AM           := i.OVD_PAID_AMT;

--        if nvl(v_loan_details.tech_loan_type, '-') not like 'O%' then
--            if res_row.STSH_AM > 0 then
--                -- Looking for reverses. S.Golovan, 26.01.2021
--                declare
--                    v_REV STSH_reverse_row_t;
--                begin
--                    v_REV := GET_STSH_reverse(pLoan, res_row.FROM_DATE, res_row.STSH_AM, pComponent);
--                    if nvl(v_REV.REV_AMOUNT,0) <> 0 then
--                        res_row.STSH_AM := res_row.STSH_AM - nvl(v_REV.REV_AMOUNT,0);
--                        res_row.ADD_INFO := APPEND_TEXT(res_row.ADD_INFO, v_REV.ADD_INFO);
--                    end if;
--                    res_row.error_desc := APPEND_TEXT(res_row.error_desc, v_REV.error_desc);
--                end;
--
--            end if;
--        end if;

        if i.date_type like '%Holiday start-1%' -- Restructuring ODUE_INT->INT. S.Golovan, 14.05.21
           and pComponent = 'MAIN_INT'
        then
            for i in (select * --#MULTIPLE_HOLIDAYS. D.Shatskiy, 21.04.2022
                        from table(fn_get_all_holiday_details(pLoan))
                       where res_row.TO_DATE between hol_start and hol_end
                         and RES_TYPE = 'R43'
                         and nvl(CAPITALIZATION_FLAG, '-') <> 'Y')
            loop
                declare
                    v_restr_odue_int number;
                begin
                    select sum(amount)
                      into v_restr_odue_int
                      from table(v_event_entries)
                     where account_number = pLoan
                       and event_code = 'MLIQ'
                       and AMOUNT_TAG = 'MAIN_INT_OLIQ'
                       and STTL_ACC LIKE '%SALH1%' -- FCJ-683 SALH1
                       and value_date <= i.hol_start
                       and value_date > nvl(i.prev_hol_start, to_date('01.01.2000','dd.mm.yyyy'))
                         ;
                    res_row.OVD_PAID_AM := nvl(res_row.OVD_PAID_AM, 0) + nvl(v_restr_odue_int, 0);
                    res_row.ADD_INFO := append_text(res_row.ADD_INFO, 'Restr.Odue_Int->Int:'||v_restr_odue_int);
                    if nvl(v_restr_odue_int, 0) <> nvl(v_prev_OVD_AM,0) then
                        res_row.error_desc := append_text(res_row.error_desc, 'Restr.Odue_Int<>OVD_AM ('||v_restr_odue_int||'<>'||v_prev_OVD_AM||')');
                    end if;
                end;
            end loop;
        end if;

        if v_prev_OVD_AM is null then -- First row
            res_row.OVD_AM := nvl(res_row.STSH_AM,0);
        else
            res_row.OVD_AM := v_prev_OVD_AM + nvl(res_row.STSH_AM,0) - nvl(v_prev_OVD_PAID_AM, 0);
        end if;

        begin
            SELECT UDE_VALUE
              into res_row.PEN_RATE
              from fcc.CLTB_ACCOUNT_UDE_VALUES u
             WHERE ACCOUNT_NUMBER = pLoan
               AND UDE_ID = pUDE_ID
               and EFFECTIVE_DATE <= res_row.TO_DATE
               and not exists (select 1
                                 from fcc.CLTB_ACCOUNT_UDE_VALUES x
                                where u.ACCOUNT_NUMBER = x.ACCOUNT_NUMBER
                                  and u.UDE_ID = x.UDE_ID
                                  and x.EFFECTIVE_DATE <= res_row.TO_DATE
                                  and u.EFFECTIVE_DATE < x.EFFECTIVE_DATE)
                 ;
        exception
            when NO_DATA_FOUND then
                res_row.PEN_RATE := null;
        end;

        if pUDE_ID = 'PENALTY_RATE' then
            SELECT FIELD_CHAR_3  RATE_BASIS
              into res_row.RATE_BASIS
              FROM fcc.CLTB_ACCOUNT_master
             WHERE ACCOUNT_NUMBER = pLoan
                 ;
        else -- INT_OVD_RATE
            res_row.RATE_BASIS := 'ANNUAL';

            begin -- из кредита ОА - в период каникул. S.Golovan, 23.04.2021
                SELECT UDE_VALUE
                  into res_row.PEN_RATE
                  from table(fn_get_all_holiday_details(pLoan)) h                          -- #MULTIPLE_HOLIDAYS
                  join fcc.CLTB_ACCOUNT_UDE_VALUES u on h.loan_oa = u.ACCOUNT_NUMBER
                                                    and res_row.FROM_DATE >= h.hol_start-1 -- #MULTIPLE_HOLIDAYS
                                                    and res_row.TO_DATE <= h.hol_end       -- #MULTIPLE_HOLIDAYS
                 WHERE 1=1
                   AND UDE_ID = pUDE_ID
                   and EFFECTIVE_DATE <= res_row.TO_DATE
                   and not exists (select 1
                                     from fcc.CLTB_ACCOUNT_UDE_VALUES x
                                    where u.ACCOUNT_NUMBER = x.ACCOUNT_NUMBER
                                      and u.UDE_ID = x.UDE_ID
                                      and x.EFFECTIVE_DATE <= res_row.TO_DATE
                                      and u.EFFECTIVE_DATE < x.EFFECTIVE_DATE)
                     ;
            exception
                when NO_DATA_FOUND then
                    null;
--                when TOO_MANY_ROWS then
--                    dbms_output.put_line('res_row.FROM_DATE='||res_row.FROM_DATE||', res_row.TO_DATE='||res_row.TO_DATE||', pLoan='||pLoan||', pUDE_ID='||pUDE_ID);
--                    raise;
            end;
        end if;

        res_row.AMOUNT_ACCR :=  round(res_row.OVD_AM
                                    * res_row.PEN_RATE/100
                                    * (res_row.TO_DATE-res_row.FROM_DATE)
                                    / case when res_row.RATE_BASIS = 'ANNUAL' then GET_DAYS_IN_YEAR(res_row.TO_DATE)
                                           else 1
                                      end
                                , 2);

        if res_row.ADD_INFO like '%Last date%'
        then
            for i in (select * -- Phone call with S.Golovan, 22.04.2022
                        from dual
                       where not (exists (select *
                                            from table(FCCUCB.LH_REP2361_v6.fn_get_all_holiday_details(pLoan)) h
                                           where res_type = 'R43' and nvl(CAPITALIZATION_FLAG, '-') <> 'Y'  -- Holidays exist
                                             and not exists(select *                                        -- But all of them R43 without capitalization
                                                              from table(FCCUCB.LH_REP2361_v6.fn_get_all_holiday_details(pLoan)) h
                                                             where not(res_type = 'R43' and nvl(CAPITALIZATION_FLAG, '-') <> 'Y')))
                                  and pComponent = 'MAIN_INT'
                                  and res_row.OVD_AM = 0))
            loop
                declare
                    v_BREAKUP_odue number;
                begin
                    SELECT sum(balance) -- Last OVD1+Last OVD2 - S.Golovan, 27.01.2020
                      into v_BREAKUP_odue
                      from (select balance
                                 , row_number() over (partition by b.account_number, STATUS_CODE order by creation_date desc) rn
                              FROM table(GET_ALL_LOANS(pLoan)) t
                              join fcc.CLTB_ACCOUNT_COMP_BAL_BREAKUP b on t.account_number = b.account_number
                             WHERE STATUS_CODE IN ('OVD1', 'OVD2')
                               AND GAAP_INDICATOR = 'AL'
                               AND component = GET_COMPONENT(pComponent, t.tech_loan_type)
                               AND CREATION_DATE <= res_row.TO_DATE
                               AND (t.TECH_LOAN_TYPE is null
                                    or (t.TECH_LOAN_TYPE in ('HA','OA') and pComponent = 'PRINCIPAL')
                                    or (t.TECH_LOAN_TYPE in ('H1','O1') and pComponent = 'MAIN_INT')))
                     where rn =1
                         ;
                    if res_row.OVD_AM <> v_BREAKUP_odue then
                        res_row.error_desc := res_row.error_desc||'OVD_AM<>CLTB_ACCOUNT_COMP_BAL_BREAKUP.BALANCE ('||res_row.OVD_AM||'<>'||v_BREAKUP_odue||')';
                    end if;
                exception
                    when NO_DATA_FOUND then
                        res_row.error_desc := res_row.error_desc||'No CLTB_ACCOUNT_COMP_BAL_BREAKUP data';
                end;
            end loop;
        end if;

        pipe row(res_row);

        v_prev_OVD_AM      := res_row.OVD_AM;
        v_prev_OVD_PAID_AM := res_row.OVD_PAID_AM;
    end loop;


end;

function GET_PENALTY_REPAY_ACTUAL (pLoan in varchar2, pComponent in varchar2) return LOAN_PENALTY_PAY_ACTUAL_tbl_t pipelined
as
    res_row   LOAN_PENALTY_PAY_ACTUAL_row_t;
begin
    COLLECT_EVENT_ENTRIES (pLoan);
    COLLECT_LOAN_DETAILS (pLoan);

    for i in (select p.account_number
                   , PAID_DATE
                   , sum(AMOUNT_PAID) AMOUNT_PAID
                   , sum(AMOUNT_WAIVED) AMOUNT_WAIVED
                   , count(case when settle_acc LIKE '%SALH1%' then 1 end) TECH_FLAG
                from (select account_number acc, tech_loan_type from table(GET_ALL_LOANS(pLoan))) l
                join table(v_AMOUNT_PAID) p on l.acc = p.account_number
               where 1=1
                 and (   (tech_loan_type is null and COMPONENT_NAME = pComponent)
                      or (Tech_Loan_Type like '_A' and pComponent in ('PENALTY_P', 'INT_ON_OVD_P') and COMPONENT_NAME = pComponent)
                      or (Tech_Loan_Type like '_1' and pComponent = 'PENALTY_I' and COMPONENT_NAME = pComponent)
                      or (Tech_Loan_Type =    'O1' and pComponent = 'INT_ON_OVD_P' AND COMPONENT_NAME = 'PRINCIPAL'AND DUE_DATE = v_loan_details.maturity_date) -- S.Golovan, 06.05.21
                     )
               group by PAID_DATE, p.account_number
              having sum(AMOUNT_PAID) <> 0 or sum(AMOUNT_WAIVED) <> 0
               order by PAID_DATE, p.account_number)
    loop
        res_row  := null;

        res_row.PARENT_ACCOUNT_NUMBER := pLoan;
        res_row.ACCOUNT_NUMBER        := i.account_number;
        res_row.PAID_DATE             := i.PAID_DATE;
        res_row.PAID_AMOUNT           := i.AMOUNT_PAID;
        res_row.WAIVED_AMOUNT         := i.AMOUNT_WAIVED;
        res_row.TECH_FLAG             := i.TECH_FLAG;

        pipe row(res_row);
    end loop;
end;

function GET_PENALTY_I_REPAY_ACTUAL (pLoan in varchar2) return LOAN_PENALTY_PAY_ACTUAL_tbl_t pipelined
as
    v_Component       varchar2(50) :=  'PENALTY_I';
begin
    for i in (select * from table(GET_PENALTY_REPAY_ACTUAL (pLoan, v_Component)))
    loop
        pipe row(i);
    end loop;
end;

function GET_PENALTY_P_REPAY_ACTUAL (pLoan in varchar2) return LOAN_PENALTY_PAY_ACTUAL_tbl_t pipelined
as
    v_Component       varchar2(50) :=  'PENALTY_P';
begin
    for i in (select * from table(GET_PENALTY_REPAY_ACTUAL (pLoan, v_Component)))
    loop
        pipe row(i);
    end loop;
end;

function GET_INT_ON_OVD_P_REPAY_ACTUAL (pLoan in varchar2) return LOAN_PENALTY_PAY_ACTUAL_tbl_t pipelined
as
    v_Component       varchar2(50) :=  'INT_ON_OVD_P';
begin
    for i in (select *
                from table(GET_PENALTY_REPAY_ACTUAL (pLoan, v_Component)))
    loop
        pipe row(i);
    end loop;
end;

function GET_STORNO (pLoan in varchar2) return LOAN_STORNO_tbl_t pipelined
as -- for single loan (parent or technical)
    res_row LOAN_STORNO_row_t;
begin
    COLLECT_EVENT_ENTRIES (pLoan);

    for i in (select *
                from table(v_event_entries)
               where 1=1
                 and account_number = pLoan
                 AND AMOUNT < 0
                 and ((DR_ACC_ROLE = 'DR_SETTL_BRIDGE' AND EVENT_code NOT IN ('DSBR', 'VAMI'))
                       or
                      (CR_ACC_ROLE = 'CR_SETTL_BRIDGE' AND EVENT_code IN ('DSBR', 'VAMI')))
             )
    loop
        res_row := null;
        res_row.PARENT_ACCOUNT_NUMBER  := null;
        res_row.ACCOUNT_NUMBER         := pLoan;
        res_row.COMPONENT_NAME         := i.COMPONENT_NAME;
        res_row.EVENT_CODE             := i.EVENT_CODE;
        res_row.STORNO_DATE            := i.value_date;
        res_row.STORNO_AMOUNT          := i.amount;
        pipe row(res_row);
    end loop;
end;

function GET_STORNO_ACTUAL (pLoan in varchar2) return LOAN_STORNO_tbl_t pipelined
as
begin
    COLLECT_LOAN_DETAILS(pLoan);
    COLLECT_EVENT_ENTRIES (pLoan);

    for i in (select *
                from (select * from table(GET_STORNO (pLoan))
                      union all
                      select p.*
                        from table(GET_TECH_LOANS (pLoan)) l
                        join table(GET_STORNO (l.account_number)) p on 1=1)
               where 1=1
                 and not exists (select * -- #MULTIPLE_HOLIDAYS
                                   from table(fn_get_all_holiday_details(pLoan))
                                  where STORNO_DATE between hol_start and hol_end)
               order by STORNO_DATE, account_number
             )
    loop
        i.parent_account_number := pLoan;
        pipe row(i);
    end loop;
end;

function GET_LOAN_DUE (pLoan in varchar2, pDate date) return LOAN_DUE_tbl_t pipelined
as
    v_res LOAN_DUE_row_t;
    v_PENALTY_P_paid number;
    v_PENALTY_I_paid number;
begin
    COLLECT_LOAN_DETAILS(pLoan);
    COLLECT_EVENT_ENTRIES (pLoan);

    v_res.ACCOUNT_NUMBER := pLoan;
    v_res.REP_DATE       := nvl(pDate, v_loan_details.today); -- least(nvl(pDate, v_loan_details.today), v_loan_details.maturity_date); --#INC000720388

    -- RESTR_ODUE_INTEREST -- S.Golovan, 14.05.21
    declare
        v_restr_odue_int number;
        v_paid_restr_int number;
    begin
        for hol in (select * -- #MULTIPLE_HOLIDAYS
                      from table(fn_get_all_holiday_details(pLoan))
                     where 1=1
                       and RES_TYPE = 'R43'
                       and nvl(CAPITALIZATION_FLAG, '-') <> 'Y')
        loop
            select nvl(v_restr_odue_int, 0) + sum(amount)
              into v_restr_odue_int
              from table(v_event_entries)
             where account_number = pLoan
               and event_code = 'MLIQ'
               and AMOUNT_TAG = 'MAIN_INT_OLIQ'
               and STTL_ACC LIKE '%SALH1%' -- FCJ-683 SALH1
               and value_date <= v_res.REP_DATE
               and value_date <= hol.hol_start
               and value_date > nvl(hol.prev_hol_start, to_date('01.01.2000','dd.mm.yyyy'))
                 ;

            select nvl(v_paid_restr_int, 0) + sum(amount_paid)
              into v_paid_restr_int
              from table(v_amount_paid) p
              join fcc.cltb_account_master l on p.account_number = l.account_number
             where 1=1
               and p.account_number = hol.loan_o1
               and component_name = 'PRINCIPAL'
               and due_date <> maturity_date
               and paid_date <= v_res.REP_DATE
                 ;
--             dbms_output.put_line(hol.hol_start||' v_restr_odue_int='||v_restr_odue_int||', v_paid_restr_int='||v_paid_restr_int);
        end loop;
        v_res.RESTR_ODUE_INTEREST := nvl(v_restr_odue_int, 0) - nvl(v_paid_restr_int, 0);
    end;

    if nvl(pDate, v_loan_details.today) > v_loan_details.maturity_date then -- #INC000720388
        v_res.PRINCIPAL_AMT  := 0;
        v_res.INTEREST_AMT   := 0;
    else
        declare
            v_PRPL           number;
            v_INT            number;
            v_tech_paid_PRPL number;
            --v_tech_paid_INT  number;
            v_S2             number;
            v_S3             number;
        begin
            select sum(case when to_date = v_res.REP_DATE then PRPL_EXPECTED_TOTAL end)
                 , sum(case when to_date = v_res.REP_DATE then INT_EXPECTED_TOTAL end)
                 , round(sum(case when LOAN_H1 is not null and ADD_INFO not like '%Holiday start%' and ADD_INFO not like '%Holiday end%' then INT_DUE_AGR end), 2) -- S.Golovan's letter, 09.06.2022
              into v_PRPL, v_INT, v_S2
              from table(GET_LOAN_REPAYMENT_CALC(pLoan, v_res.REP_DATE))
             where 1=1
                 ;

            select SUM(case when loan_type in ('HA') then PAID_PRINCIPAL end)
--                 , SUM(case when loan_type in ('H1') then PAID_INTEREST end)
              into v_tech_paid_PRPL--, v_tech_paid_INT
              from table(GET_LOAN_REPAYMENT_ACTUAL(pLoan))
             where ACCOUNT_NUMBER <> PARENT_ACCOUNT_NUMBER and PAID_DATE <= v_res.REP_DATE
                 ;

            select sum(nvl(Amount_Due, 0) - nvl(Amount_Settled, 0)) -- S.Golovan's letter, 08.06.2022
              into v_S3
              from fcc.cltb_account_schedules
             where 1=1
               and account_number in (select account_number from table(GET_TECH_LOANS(pLoan)) where tech_loan_type = 'H1')
               and schedule_due_date >= v_res.REP_DATE
                 ;

            v_res.PRINCIPAL_AMT  := v_PRPL - nvl(v_tech_paid_PRPL, 0);
            -- INTEREST_AMT  =  S = (S1 - S2) + S3. S.Golovan's letter, 08.06.2022
            v_res.INTEREST_AMT   := v_INT - nvl(v_S2, 0) + nvl(v_S3, 0);
            dbms_output.put_line('v_INT='||v_INT||' - v_S2='||v_S2||' + v_S3='||v_S3);
        end;
    end if;

    select sum(case when to_date = v_res.REP_DATE and add_info like '%Last date%' then OVD_AM end)
         , SUM(AMOUNT_ACCR)
      into v_res.PRINCIPAL_OVD_AMT, v_res.PRINCIPAL_PENALTY
      from table(GET_LOAN_PENALTY_P_CALC(pLoan, v_res.REP_DATE))
     where 1=1
         ;

    select sum(case when to_date = v_res.REP_DATE and add_info like '%Last date%' then OVD_AM end)
         , SUM(AMOUNT_ACCR)
      into v_res.INTEREST_OVD_AMT, v_res.INTEREST_PENALTY
      from table(GET_LOAN_PENALTY_I_CALC(pLoan, v_res.REP_DATE))
     where 1=1
         ;

    -- INT_ON_OVD_P
    -- S1
    select SUM(AMOUNT_ACCR)
      into v_res.INT_OVD_P_AMT
      from table(GET_LOAN_INT_ON_OVD_P_CALC(pLoan, v_res.REP_DATE))
     where 1=1
         ;

    -- S1-S2
    Select nvl(v_res.INT_OVD_P_AMT, 0) - SUM(PAID_AMOUNT)
      into v_res.INT_OVD_P_AMT
      From table(GET_INT_ON_OVD_P_REPAY_ACTUAL(pLoan))
     Where PAID_DATE <= v_res.REP_DATE
       and (nvl(tech_flag, 0) = 0
            or exists (select *
                         from table(fn_get_all_holiday_details(pLoan))
                        where paid_date between hol_start and hol_end
                          and capitalization_flag = 'Y')
           )
         ;

    declare
        v_s3    number;
    begin -- S1-S2+S3
--        select nvl(v_res.INT_OVD_P_AMT, 0)
--             + nvl(AMOUNT_DUE, 0) - nvl(AMOUNT_PAID, 0) -- #MULTIPLE_HOLIDAYS
--          into v_res.INT_OVD_P_AMT
--          from (select AMOUNT_DUE, AMOUNT_PAID
--                     , row_number() over(partition by account_number order by to_date desc) rn
--                  from table(GET_LOAN_INT_ON_OVD_P_CALC2(pLoan, v_res.REP_DATE))
--                 where TO_DATE <= v_res.REP_DATE)
--         where rn=1
--             ;
        select sum(INT_ON_OVD_P )   --  S.Golovan's letter, 08.06.2022
          into v_s3
          from (select t.account_number, nvl(a.AMOUNT_FINANCED,0)-nvl(sum(amount),0) INT_ON_OVD_P
                  from table(GET_TECH_LOANS(pLoan)) t
                  join table(fn_get_all_holiday_details(pLoan)) h on t.account_number = loan_o1
                                                                 and nvl(capitalization_flag, '-') <> 'Y' --  S.Golovan's letter, 20.06.2022
                  join fcc.cltb_account_master a on a.account_number = t.account_number
                                                and a.book_date <= v_res.REP_DATE
                  left join fcc.cltb_event_entries e on e.account_number = t.account_number
                                                    and t.book_date = e.value_date
                                                    and e.event_code = 'STSH'
                                                    and e.value_date <= v_res.REP_DATE
                 where tech_loan_type = 'O1'
                 group by t.account_number, a.AMOUNT_FINANCED)
             ;

        v_res.INT_OVD_P_AMT := nvl(v_res.INT_OVD_P_AMT, 0) + nvl(v_s3, 0);
    exception
        when no_data_found then
        null;
    end;

    select SUM(PAID_AMOUNT)
      into v_PENALTY_P_paid
      from table(GET_PENALTY_P_REPAY_ACTUAL(pLoan))
     where PAID_DATE <= v_res.REP_DATE
       and nvl(tech_flag, 0) = 0;

    v_res.PRINCIPAL_PENALTY := nvl(v_res.PRINCIPAL_PENALTY, 0) - nvl(v_PENALTY_P_paid, 0);

    select SUM(PAID_AMOUNT)
      into v_PENALTY_I_paid
      from table(GET_PENALTY_I_REPAY_ACTUAL(pLoan))
     where PAID_DATE <= v_res.REP_DATE
       and nvl(tech_flag, 0) = 0;

    v_res.INTEREST_PENALTY := nvl(v_res.INTEREST_PENALTY, 0) - nvl(v_PENALTY_I_paid, 0);

    pipe row(v_res);
end;

function GET_LOAN_REPAYMENT_CALC_BO (pLoan in varchar2, pDate in date) return LOAN_REPAYMENT_CALC_tbl_t pipelined
as
    v_row_to_group LOAN_REPAYMENT_CALC_row_t;
    v_grouped_row LOAN_REPAYMENT_CALC_row_t;
begin
    for i in (select * from table(GET_LOAN_REPAYMENT_CALC(pLoan, pDate)))
    loop
        if i.add_info like '%Accrual after Holidays%' then                       -- n row
            v_row_to_group := i;
        elsif v_row_to_group.from_date is not null then                          -- n+1 row
            if v_row_to_group.int_rate = i.int_rate and v_row_to_group.add_info not like '%Last day of the year%' then
                v_grouped_row := i;
                v_grouped_row.from_date := v_row_to_group.from_date;
                v_grouped_row.ACCR_INT := nvl(v_grouped_row.ACCR_INT, 0) + nvl(v_row_to_group.ACCR_INT, 0);
                v_grouped_row.add_info := append_text(v_grouped_row.add_info, v_row_to_group.add_info);
                pipe row(v_grouped_row);
            else -- No grouping
                pipe row(v_row_to_group);
                pipe row(i);
            end if;
            v_row_to_group := null;
            v_grouped_row := null;
        else                                                                     -- Other rows
            pipe row(i);
        end if;

    end loop;

end;

function GET_HOL_MSG (pLoan in varchar2) return varchar2
as
    v_message varchar2(4000);
begin
    for i in (Select hol_start, hol_end from table(fn_get_all_holiday_details(pLoan)))
    loop
        if v_message is null then
            v_message := 'Кредитные каникулы предоставлялись. Период каникул с '||to_char(i.hol_start, 'dd.mm.yyyy')||' по '||to_char(i.hol_end, 'dd.mm.yyyy');
        else
            v_message := v_message||', с '||to_char(i.hol_start, 'dd.mm.yyyy')||' по '||to_char(i.hol_end, 'dd.mm.yyyy');
        end if;
    end loop;
    return nvl(v_message, 'Кредитные каникулы не предоставлялись');
end;

end;
/
