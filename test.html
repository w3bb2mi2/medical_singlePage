CREATE OR REPLACE PACKAGE BODY REP_SBL_PKG_dev
is
--
-- Private procedure/functions
--
FUNCTION Get_Setting(p_param_code IN VARCHAR2)
         RETURN VARCHAR2
IS
  v_ret  BO_SETTINGS.PARAM_VALUE%TYPE;
BEGIN
  for r_s in (select c.Param_Value
              from BO_SETTINGS c
              where c.param_code = p_param_code
             )
  loop
    v_ret:=r_s.Param_Value;
  end loop;
  --
  return v_ret;
END;
--
FUNCTION Get_Request_ID
         RETURN NUMBER
IS
BEGIN
 return (TO_NUMBER(TO_CHAR(SYSTIMESTAMP, 'YYYYMMDDHH24MISSFF6')));
END;
--
  FUNCTION check_params2_SBL (pi_loan_account IN VARCHAR2,
                         pi_payment_plan_date IN DATE,
                         pi_ovd_close_date IN DATE) RETURN VARCHAR2
    IS
   lv_retval VARCHAR2(200);
   ld_today  DATE;
   ld_next_paym_day  DATE;
   ld_nextnext_paym_day  DATE;
   ln_cnt NUMBER;
   BEGIN
     lv_retval:='OK';
   SELECT count(*) into ln_cnt
   FROM CLTB_ACCOUNT_MASTER
   WHERE ACCOUNT_NUMBER = pi_loan_account;
   if ln_cnt=0
   then lv_retval:='Кредит не найден';
   else
       --get today
       SELECT today INTO ld_today FROM fcc.sttm_dates
       WHERE Branch_code = (SELECT Branch_code FROM CLTB_ACCOUNT_MASTER WHERE ACCOUNT_NUMBER = pi_loan_account);
       BEGIN
        SELECT MIN(to_date) INTO ld_next_paym_day FROM
               (SELECT a.SCHEDULE_ST_DATE from_date, a.SCHEDULE_DUE_DATE to_date, a.amount_due AM_DUE
                FROM fcc.CLTB_ACCOUNT_SCHEDULES  a
                 WHERE a.ACCOUNT_NUMBER = pi_loan_account
                 AND a.COMPONENT_NAME = 'MAIN_INT'
                 AND a.SCHEDULE_DUE_DATE >= ld_today)
         ;--WHERE AM_DUE <> 0;
       EXCEPTION WHEN NO_DATA_FOUND THEN
        ld_next_paym_day:=null;
       END;
       BEGIN
         SELECT MIN(to_date) INTO ld_nextnext_paym_day FROM
               (SELECT a.SCHEDULE_ST_DATE from_date, a.SCHEDULE_DUE_DATE to_date, a.amount_due AM_DUE
                FROM fcc.CLTB_ACCOUNT_SCHEDULES  a
                 WHERE a.ACCOUNT_NUMBER = pi_loan_account
                 AND a.COMPONENT_NAME = 'MAIN_INT'
                 AND a.SCHEDULE_DUE_DATE > ld_next_paym_day)
         ;--WHERE AM_DUE <> 0;
       EXCEPTION WHEN NO_DATA_FOUND THEN
        ld_nextnext_paym_day:=null;
       END;
       ld_nextnext_paym_day:=nvl(ld_nextnext_paym_day,ld_next_paym_day);
       --Установить ограничения (контроль при вводе дат пользователем):
       --   ?Планируемая дата платежа?  >= дате текущего дня и <= дате очередного погашения по графику
       --   ?Дата погашения просрочки?  >= дате текущего дня и  <= ?Планируемая дата платежа?
       if pi_payment_plan_date<ld_today then lv_retval:='Планируемая дата платежа должна быть больше или равна дате текущего операционного дня ('||to_char(ld_today,'DD.MM.RRRR')||')'; end if;
       if pi_payment_plan_date>ld_nextnext_paym_day then lv_retval:='Планируемая дата платежа должна быть меньше или равна дате платежа по графику, следующего за очередным погашением   ('||to_char(ld_nextnext_paym_day,'DD.MM.RRRR')||')'; end if;
       if pi_ovd_close_date<ld_today then lv_retval:='Дата погашения просрочки должна быть больше или равна дате текущего операционного дня ('||to_char(ld_today,'DD.MM.RRRR')||')'; end if;
       if pi_ovd_close_date>ld_next_paym_day then lv_retval:='Дата погашения просрочки должна быть меньше или равна дате очередного погашения по графику ('||to_char(ld_next_paym_day,'DD.MM.RRRR')||')'; end if;
       if pi_ovd_close_date>pi_payment_plan_date then lv_retval:='Дата погашения просрочки должна быть меньше или равна Планируемая дата платежа'; end if;
     end if;
   RETURN lv_retval;
   END check_params2_SBL;
  --
  function checking_amounts_fcc(in_account_number varchar2) return varchar2 is
           v_branch_code VARCHAR2(35);
           v_fact_amount number;
           v_calc_amount number;
  begin
           begin
             select branch_code
             into v_branch_code
             from fcc.cltb_account_master
             where account_number=in_account_number;
           exception when NO_DATA_FOUND then
             return null;
           end;

           select ROUND(sum(amount_due),1)
           into v_fact_amount
           from fcc.cltb_account_schedules
           where account_number=in_account_number
             and component_name='PRINCIPAL'
             and schedule_due_date>=(select today from fcc.sttm_dates where branch_code=v_branch_code);

           select ROUND(x.PRPL_EXPECTED,1)
           into v_calc_amount
           from table(REP_SBL_PKG.CASHFLOW_F(in_account_number)) x
           where (select today from fcc.sttm_dates where branch_code=v_branch_code) between from_date+1 and to_date;

           return case v_fact_amount-v_calc_amount when 0 then null else 'По кредиту '||in_account_number||' выявлены расхождения в графике платежей. Текущий основной долг: расчетный - '||v_calc_amount||', в FCC - '||v_fact_amount end;
  end checking_amounts_fcc;
  --
  -- расчет ПСК для ЧДП
  --
  function get_psk (in_account_number varchar2,
                    in_accuracy number,
                    in_date date default null) return number is
    Result number;
    v_dsbr_date DATE;
  begin
    -- Дата выдачи кредита с учетом миграции
    select A.value_date
      into v_dsbr_date
      from FCC.CLVW_EVENT_ENTRIES_ARCH A
     where A.account_number=in_account_number
       and A.component_name='PRINCIPAL'
       and A.event_code='DSBR';
    --
    select x into result
    from (select *
          from (-- выдача
                select from_date,
                       -1*nvl(prpl_EXPECTED,0) as emi_amount
                from table(CASHFLOW_F(in_account_number))where rownum=1
                -- Поток по выплате в день выдачи страховой премии
                union all
                select v_dsbr_date,
                       NVL(o1.INS_PREMIUM, 0)
                  from SIEBEL.SX_O@SBLREP.IMB.RU o, SIEBEL.SX_O1@SBLREP.IMB.RU o1
                 where o1.ID = o.ID
                   and o.CREDIT_NUM= in_account_number
                union all
                -- все потоки кроме выдачи
                select to_date,
                       nvl(prpl_due,0)+nvl(int_due,0)+nvl(prpl_prep,0)-nvl(prpl_incr,0)+nvl(prepaid_int,0)
                from table(CASHFLOW_F(in_account_number))
                where to_date<in_date or in_date is null
                union all
                -- поток после ЧДП
                select to_date,
                       case is_principal_pay when 'Y' then nvl(emi_amount,0)+nvl(adv_repayment,0)
                                             else nvl(adv_repayment,0) end
                from bodev.rep_int_due_calc3
                where to_date>=in_date and in_date is not null)
          model dimension by (row_number()over(order by from_date asc) as rn)
          measures(cast(0 as number) as fa,
                   cast(0 as number) as Tfa,
                   cast(0 as number) as fb,
                   cast(0 as number) as Tfb,
                   cast(0 as number) as a,
                   cast(0.1 as number) as b,
                   cast(0 as number) as x,
                   cast(0 as number) as tfx,
                   cast(0 as number) as fx,
                   from_date,
                   emi_amount,
                   from_date-first_value(from_date)over(order by from_date asc) diff)
          rules iterate(100) until(fx[1]<in_accuracy)(
                Tfa[any]=nvl(emi_amount[cv()],0)/power(1+a[1],diff[cv()]/365),
                fa[1]=sum(Tfa)[any],
                Tfb[any]=nvl(emi_amount[cv()],0)/power(1+b[1],diff[cv()]/365),
                fb[1]=sum(Tfb)[any],
                x[1]=a[1]-fa[1]*(b[1]-a[1])/(fb[1]-fa[1]),
                Tfx[any]=nvl(emi_amount[cv()],0)/power(1+x[1],diff[cv()]/365),
                fx[1]=sum(Tfx)[any],
                a[1]=case when fa[1]*fb[1]>0 then x[1] else a[1] end,
                b[1]=case when fa[1]*fb[1]>0 then b[1] else x[1] end)
    ) where rownum=1;
    return Result;
  exception when others then return 0;
  end get_psk;
  --
  -- Функция расчета начисленных процентов
  --
  function int_calc(in_amount number,
                    in_interest number,
                    start_date date,
                    end_date date) return number is
           V_ACCR_INT number:=0;
  begin
           if to_char(last_day(to_date('01.02.'||to_char(end_date,'yyyy'),'dd.mm.yyyy')),'dd')<>
               to_char(last_day(to_date('01.02.'||to_char(start_date,'yyyy'),'dd.mm.yyyy')),'dd') then
               -- Если дата или окончание периода попадают на разные года (т.е. один из них високосный)
               if to_char(last_day(to_date('01.02.'||to_char(end_date,'yyyy'),'dd.mm.yyyy')),'dd')='28' then
                  -- если период начинается в високосном, а заканчивается в не високосном
                  V_ACCR_INT:=in_amount*in_interest*(end_date-to_date('3112'||to_char(start_date,'yyyy'),'ddmmyyyy'))/36500;
                  V_ACCR_INT:=V_ACCR_INT+(in_amount*in_interest*(to_date('3112'||to_char(start_date,'yyyy'),'ddmmyyyy')-start_date)/36600);
               else
                  -- если период начинается в не високосном, а заканчивается в високосном
                  V_ACCR_INT:=in_amount*in_interest*(end_date-to_date('3112'||to_char(start_date,'yyyy'),'ddmmyyyy'))/36600;
                  V_ACCR_INT:=V_ACCR_INT+(in_amount*in_interest*(to_date('3112'||to_char(start_date,'yyyy'),'ddmmyyyy')-start_date)/36500);
               end if;
            else
               -- Если дата или окончание периода попадают на одинаковые года (т.е. либо оба високосные либо обя обычные)
               if to_char(last_day(to_date('01.02.'||to_char(end_date,'yyyy'),'dd.mm.yyyy')),'dd')='28' then
                  -- если год не високосный
                  V_ACCR_INT:=in_amount*in_interest*(end_date-start_date)/36500;
               else
                  -- если год високосный
                  V_ACCR_INT:=in_amount*in_interest*(end_date-start_date)/36600;
               end if;
            end if;
            return V_ACCR_INT;
  end;
  --
  PROCEDURE Get_count_days(p_date_from IN DATE,
                           p_date_to   IN DATE,
                           p_count_leap_days OUT NUMBER,
                           p_count_ordn_days OUT NUMBER)
  IS
  BEGIN
    if mod (extract (year from p_date_to), 4) = 0 and mod (extract (year from p_date_from), 4) != 0
    then
      p_count_leap_days := p_date_to - (trunc (p_date_to, 'rrrr')-1);
      p_count_ordn_days := (trunc (p_date_to, 'rrrr')-1) - p_date_from;
    elsif mod (extract (year from p_date_to), 4) != 0 and mod (extract (year from p_date_from), 4) = 0
     then
      p_count_leap_days := (trunc (p_date_to, 'rrrr')-1) - p_date_from;
      p_count_ordn_days := p_date_to - (trunc (p_date_to, 'rrrr')-1);
    elsif mod (extract (year from p_date_to), 4) = 0 and mod (extract (year from p_date_from), 4) = 0
     then
      p_count_leap_days := p_date_to - p_date_from;
      p_count_ordn_days := 0;
    else
      p_count_leap_days := 0;
      p_count_ordn_days := p_date_to - p_date_from;
    end if;
  END Get_count_days;
--
-- Public procedure/functions
--
  FUNCTION get_psk_rate (in_account_number varchar2,
                         in_accuracy number,
                         in_date date default null) return number is
    Result number;
    v_dsbr_date DATE;
  begin
    -- Дата выдачи кредита с учетом миграции
    select A.value_date
      into v_dsbr_date
      from FCC.CLVW_EVENT_ENTRIES_ARCH A
     where A.account_number=in_account_number
       and A.component_name='PRINCIPAL'
       and A.event_code='DSBR';
    --
    select x into result
    from (select *
          from (-- выдача
                select from_date,
                       -1*nvl(prpl_EXPECTED,0) as emi_amount
                from table(CASHFLOW_F(in_account_number))where rownum=1
                -- Поток по выплате в день выдачи страховой премии
                union all
                select v_dsbr_date,
                       NVL(o1.INS_PREMIUM, 0)
                  from SIEBEL.SX_O@SBLREP.IMB.RU o, SIEBEL.SX_O1@SBLREP.IMB.RU o1
                 where o1.ID = o.ID
                   and o.CREDIT_NUM= in_account_number
                union all
                -- все потоки кроме выдачи
                select to_date,
                       nvl(prpl_due,0)+nvl(int_due,0)+nvl(prpl_prep,0)-nvl(prpl_incr,0)+nvl(prepaid_int,0)
                from table(CASHFLOW_F(in_account_number))
                where to_date<in_date or in_date is null
                union all
                -- поток после ЧДП
                select to_date,
                       nvl(emi_amount,0) /*case is_principal_pay when 'Y' then nvl(emi_amount,0)+nvl(adv_repayment,0)
                                             else nvl(adv_repayment,0) end*/
                from bodev.rep_sbl_rate_sched
                where to_date>=in_date and in_date is not null)
          model dimension by (row_number()over(order by from_date asc) as rn)
          measures(cast(0 as number) as fa,
                   cast(0 as number) as Tfa,
                   cast(0 as number) as fb,
                   cast(0 as number) as Tfb,
                   cast(0 as number) as a,
                   cast(0.1 as number) as b,
                   cast(0 as number) as x,
                   cast(0 as number) as tfx,
                   cast(0 as number) as fx,
                   from_date,
                   emi_amount,
                   from_date-first_value(from_date)over(order by from_date asc) diff)
          rules iterate(100) until(fx[1]<in_accuracy)(
                Tfa[any]=nvl(emi_amount[cv()],0)/power(1+a[1],diff[cv()]/365),
                fa[1]=sum(Tfa)[any],
                Tfb[any]=nvl(emi_amount[cv()],0)/power(1+b[1],diff[cv()]/365),
                fb[1]=sum(Tfb)[any],
                x[1]=a[1]-fa[1]*(b[1]-a[1])/(fb[1]-fa[1]),
                Tfx[any]=nvl(emi_amount[cv()],0)/power(1+x[1],diff[cv()]/365),
                fx[1]=sum(Tfx)[any],
                a[1]=case when fa[1]*fb[1]>0 then x[1] else a[1] end,
                b[1]=case when fa[1]*fb[1]>0 then b[1] else x[1] end)
    ) where rownum=1;
    return Result;
  exception when others then return 0;
  end get_psk_rate;
  --
  FUNCTION calc_emi (pi_is_buy_back IN NUMBER, pi_PRPL_EXPECTED IN NUMBER, pi_RATE IN NUMBER, pi_last_paym_sum  IN NUMBER, pi_exp_pay_cnt IN NUMBER, pi_prev_adv_repay_sum IN NUMBER) RETURN NUMBER IS
    retval NUMBER;
    ln_ps NUMBER;
  BEGIN
    ln_ps:=pi_RATE/1200;
    --DBMS_OUTPUT.Put_Line('CALC EMI');
    --DBMS_OUTPUT.Put_Line('is_buy_back:='||to_char(pi_is_buy_back));
    --DBMS_OUTPUT.Put_Line('PRPL_EXPECTED:='||to_char(pi_PRPL_EXPECTED));
    --DBMS_OUTPUT.Put_Line('ln_ps:='||to_char(ln_ps,'0D99999999999'));
    --DBMS_OUTPUT.Put_Line('exp_pay_cnt:='||to_char(pi_exp_pay_cnt));
    --DBMS_OUTPUT.Put_Line('last_paym_sum:='||to_char(pi_last_paym_sum));
    --DBMS_OUTPUT.Put_Line('prev_adv_repay_sum:='||to_char(pi_prev_adv_repay_sum));
    if pi_is_buy_back=0 then
        retval:=pi_PRPL_EXPECTED*ln_ps/(1-power((1+ln_ps),-pi_exp_pay_cnt));
    else
        if pi_exp_pay_cnt=0 then retval:=pi_PRPL_EXPECTED;
        elsif pi_PRPL_EXPECTED<=(greatest(pi_last_paym_sum,pi_prev_adv_repay_sum)-pi_prev_adv_repay_sum) then
           retval:=pi_PRPL_EXPECTED*ln_ps;--pi_PRPL_EXPECTED*ln_ps;
        else
           --DBMS_OUTPUT.Put_Line('BIG FORMULA Buy Back');
           retval:=(pi_PRPL_EXPECTED-(greatest(pi_last_paym_sum,pi_prev_adv_repay_sum)-pi_prev_adv_repay_sum))*ln_ps/(1-power((1+ln_ps),-pi_exp_pay_cnt))+(greatest(pi_last_paym_sum,pi_prev_adv_repay_sum)-pi_prev_adv_repay_sum)*ln_ps;
        end if;
    end if;
    --DBMS_OUTPUT.Put_Line('EMI='||to_char(round(nvl(retval,0),2)));
    --return round(nvl(retval,0));
    --DBMS_OUTPUT.Put_Line('EMI='||to_char(ceil(nvl(retval,0))));
    return ceil(nvl(retval,0));
  END calc_emi;

  FUNCTION calc_emi2 (pi_is_buy_back IN NUMBER, pi_PRPL_EXPECTED IN NUMBER, pi_RATE IN NUMBER, pi_last_paym_sum  IN NUMBER, pi_exp_pay_cnt IN NUMBER, pi_prev_adv_repay_sum IN NUMBER, pi_adv_repay_sum IN NUMBER) RETURN NUMBER IS
    retval NUMBER;
    ln_ps NUMBER;
    ln_prev_adv_repay_sum NUMBER;
  BEGIN
    ln_ps:=pi_RATE/1200;
    --DBMS_OUTPUT.Put_Line('CALC EMI2');
    --DBMS_OUTPUT.Put_Line('is_buy_back:='||to_char(pi_is_buy_back));
    --DBMS_OUTPUT.Put_Line('PRPL_EXPECTED:='||to_char(pi_PRPL_EXPECTED));
    --DBMS_OUTPUT.Put_Line('ln_ps:='||to_char(ln_ps,'0D99999999999'));
    --DBMS_OUTPUT.Put_Line('exp_pay_cnt:='||to_char(pi_exp_pay_cnt));
    --DBMS_OUTPUT.Put_Line('last_paym_sum:='||to_char(pi_last_paym_sum));
    --DBMS_OUTPUT.Put_Line('prev_adv_repay_sum:='||to_char(pi_prev_adv_repay_sum));
    if pi_is_buy_back=0 then
        retval:=pi_PRPL_EXPECTED*ln_ps/(1-power((1+ln_ps),-pi_exp_pay_cnt));
    else
        if pi_exp_pay_cnt=0 then retval:=pi_PRPL_EXPECTED;
        elsif pi_PRPL_EXPECTED-pi_adv_repay_sum<=(greatest(pi_last_paym_sum-pi_adv_repay_sum,pi_prev_adv_repay_sum)-pi_prev_adv_repay_sum) then
           retval:=pi_PRPL_EXPECTED*ln_ps;--pi_PRPL_EXPECTED*ln_ps;
        else
           --DBMS_OUTPUT.Put_Line('BIG FORMULA Buy Back');
       --ln_prev_adv_repay_sum:=0;--nvl(pi_prev_adv_repay_sum,0);
       ln_prev_adv_repay_sum:=nvl(pi_prev_adv_repay_sum,0);
           retval:=((pi_PRPL_EXPECTED-pi_adv_repay_sum)-(greatest(pi_last_paym_sum-pi_adv_repay_sum,ln_prev_adv_repay_sum)-ln_prev_adv_repay_sum))*ln_ps/(1-power((1+ln_ps),-pi_exp_pay_cnt))+(greatest(pi_last_paym_sum-pi_adv_repay_sum,ln_prev_adv_repay_sum)-ln_prev_adv_repay_sum)*ln_ps;
        end if;
    end if;
    --DBMS_OUTPUT.Put_Line('EMI='||to_char(round(nvl(retval,0),2)));
    --return round(nvl(retval,0));
    --DBMS_OUTPUT.Put_Line('EMI='||to_char(ceil(nvl(retval,0))));
    return ceil(nvl(retval,0));
  END calc_emi2;-- Функция расчета потока
  --
  function CASHFLOW_F(in_account_number varchar2) return table_type pipelined is
           out_record row_type; -- объект результата
           v_max_date date;
           v_ACCR_INT number:=0;
           v_SUM_ACCR_INT number:=0; -- техническая непрофильная переменная
           v_POSTP_INT number:=0;
           v_PREPAID_INT number:=0;
           v_INT_DUE number:=0;
           v_EMI_AMOUNT number;
           v_PRPL_PREP number:=0;
           v_PRPL_DUE number:=0;
           v_PRPL_EXPECTED number:=0;
           v_PRPL_INCR number:=0;
           v_days_of_year integer:=null;
  begin
           -- Определение даты окончения договора
           select MATURITY_DATE
           into v_max_date
           from fcc.CLTB_ACCOUNT_APPS_MASTER
           where account_number=in_account_number;
           -- основная логика алгоритма
           for i in (select dates.account_number,
                            dates.from_date,
                            dates.to_date,
                            to_number(null) as accr_int,
                            to_number(null) as postp_int,
                            to_number(null) as int_due,
                            to_number(null) as prpl_due,
                            start_loan.prpl_expected,
                            lead(early_repayment.prpl_prep,1,null)over(order by from_date asc) prpl_prep,
                            lead(early_repayment.prepaid_int,1,null)over(order by from_date asc) prepaid_int,
                            ir.ude_value as int_rate,
                            payments.emi_amount,
                            row_number()over(order by from_date asc) as rn,
                            count(*)over() as cnt,
                            lead(add_transh.prpl_incr,1,null)over(order by dates.from_date asc) prpl_incr
                     from(select -- восстанавливаем периоды
                                 account_number,
                                 value_date as from_date,
                                 lead(value_date,1,max_date)over(order by value_date asc) as to_date,
                                 max_date
                          from (select distinct
                                       -- оставляем только уникальные периоды
                                       account_number,
                                       value_date,
                                       v_max_date as max_date
                                from (-- Информация о выдаче кредита
                                      select account_number,
                                             value_date
                                      from fcc.cltb_event_entries
                                      where account_number=in_account_number
                                        and component_name='PRINCIPAL'
                                        and event_code='DSBR'
                                      union all
                                      -- Информация платежей по графику
                                      select account_number,
                                             schedule_due_date
                                      from fcc.cltb_account_schedules
                                      where account_number=in_account_number
                                        and component_name='MAIN_INT'
                                      union all
                                      -- Информация о досрочных погашениях
                                      select x.account_number,
                                             x.paid_date
                                      from fcc.cltb_amount_paid x
                                      where x.account_number=in_account_number
                                        and ((x.component_name ='PRINCIPAL'
                                             and x.due_date>=x.paid_date)
                                                 or(x.component_name ='MAIN_INT'
                                                    and x.due_date>x.paid_date))
                                        and x.amount_paid>0
                                      union all
                                      -- Информация о дополнительных траншах кредита
                                      select account_number,
                                             value_date
                                      from fcc.cltb_event_entries
                                      where account_number=in_account_number
                                        and amount_tag='PRINCIPAL_INCR'
                                      group by account_number,
                                               value_date having sum(amount)>0
                                      union all
--                                      SELECT in_account_number,EFFECTIVE_DATE-1 FROM fcc.CLTB_ACCOUNT_UDE_VALUES
--                                      WHERE ACCOUNT_NUMBER = in_account_number
--                                      AND UDE_ID = 'INTEREST_RATE'
--                                      AND ude_value = 0
--                                     union all
                                      SELECT in_account_number,EFFECTIVE_DATE -1 as EFFECTIVE_DATE FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                      WHERE ACCOUNT_NUMBER = in_account_number
                                      AND UDE_ID = 'INTEREST_RATE'
                                      AND EFFECTIVE_DATE > (SELECT MIN(EFFECTIVE_DATE) FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                                             WHERE ACCOUNT_NUMBER = in_account_number
                                                               AND UDE_ID = 'INTEREST_RATE')
                                     )
                               )
                         ) dates
                     left outer join (select -- Информация о выдаче кредита с учетом миграции
                                         A.account_number,
                                         A.value_date,
                                         (CASE
                                            WHEN A.amount-nvl(B.field_number_2, 0)>0 THEN A.amount
                                            WHEN A.amount-nvl(B.field_number_2, 0)<0 THEN B.field_number_2
                                            ELSE A.amount
                                          END) as prpl_expected
                                        from FCC.CLVW_EVENT_ENTRIES_ARCH A,
                                        FCC.CLTB_ACCOUNT_APPS_MASTER B
                                        where A.account_number=in_account_number
                                            and B.ACCOUNT_NUMBER=A.account_number
                                            and A.component_name='PRINCIPAL'
                                            and A.event_code='DSBR'
                                        ) start_loan on dates.account_number=start_loan.account_number
                                                                         and start_loan.value_date = dates.from_date
                     left outer join (-- Информация о досрочных погашениях
                                      select x.account_number,
                                             x.paid_date,
                                             sum(decode(x.component_name,'PRINCIPAL',amount_paid,null)) as prpl_prep,
                                             sum(decode(x.component_name,'MAIN_INT',amount_paid,null)) as prepaid_int
                                      from fcc.cltb_amount_paid x
                                      where x.account_number=in_account_number
                                        and ((x.component_name ='PRINCIPAL'
                                             and x.due_date>=x.paid_date)
                                                 or(x.component_name ='MAIN_INT'
                                                    and x.due_date>x.paid_date))
                                        --and x.amount_paid>0
                                        --and y.account_number is null
                                      group by x.account_number,
                                               x.paid_date) early_repayment on early_repayment.account_number=dates.account_number
                                                                           and early_repayment.paid_date = dates.from_date
                     left outer join (-- Информация о дополнительных траншах кредита
                                      select account_number,
                                             value_date,
                                             sum(amount) as prpl_INCR
                                      from fcc.cltb_event_entries
                                      where account_number=in_account_number
                                        and amount_tag='PRINCIPAL_INCR'
                                      group by account_number,
                                               value_date having sum(amount)>0) add_transh on add_transh.account_number=dates.account_number
                                                                                          and add_transh.value_date=dates.from_date
                     left outer join (-- Информация платежей по графику
                                      select account_number,
                                             schedule_due_date,
                                             emi_amount
                                      from fcc.cltb_account_schedules
                                      WHERE account_number=in_account_number
                                        and component_name='MAIN_INT') payments on payments.account_number=dates.account_number
                                                                            and payments.schedule_due_date=dates.to_date
                                                                            and payments.schedule_due_date<dates.max_date
                     left outer join (-- добавление процентных ставок
                                      select account_number,
                                             effective_date as start_date,
                                             lead(effective_date-1,1,to_date('31129999','ddmmyyyy'))over(order by effective_date asc) as end_date,
                                             ude_value
                                        from fcc.cltb_account_ude_values
                                        where ude_id='INTEREST_RATE'
                                          and account_number=in_account_number) ir on dates.account_number=ir.account_number
                                                                                     and dates.from_date+1 between ir.start_date and ir.end_date
                     where not(dates.from_date=dates.to_date and dates.to_date=dates.max_date)) LOOP
      -- Расчет основного долга
      V_PRPL_EXPECTED := case i.rn when 1 then i.prpl_expected
                                   else round(V_PRPL_EXPECTED - nvl(v_prpl_prep,0) + nvl(v_PRPL_INCR,0)-nvl(v_prpl_due,0),2) end;
      --dbms_output.put_line(nvl(v_prpl_due,0));
      -- вычисление начисленных процентов
      V_ACCR_INT:=int_calc(V_PRPL_EXPECTED,i.int_rate,i.FROM_DATE,i.TO_DATE);

      if i.emi_amount is not null then
         -- если есть платеж
         if (nvl(v_postp_int,0)+v_accr_int+v_SUM_ACCR_INT)>nvl(i.emi_amount,0)-v_PREPAID_INT then
            -- если проценты больше платежа, то весь платеж уходит на плановые проценты
            v_int_due:=i.emi_amount-v_PREPAID_INT;
            -- вычисление отложенныч процентов
            v_postp_int:=round(V_ACCR_INT+V_SUM_ACCR_INT+nvl(v_postp_int,0)-(nvl(i.emi_amount,0)-v_PREPAID_INT),2);
         else
            -- если проценты меньше или равныв платежу, то платеж равен сумме процентов
            v_int_due:=round(v_accr_int+v_SUM_ACCR_INT+nvl(v_postp_int,0),2);
            -- обнуление отложенныч процентов
            v_postp_int:=0;
         end if;
         -- вычисление планового платежа по основному долгу
         v_prpl_due:=round(i.emi_amount-v_int_due,2)-v_PREPAID_INT;
         -- обнуление накопленныч процентов, которые возникли в периоды отсутствия платежей
         v_SUM_ACCR_INT:=0;
         -- Результат для отложенных процентов
         out_record.POSTP_INT:=round(v_postp_int,2);
      else
         -- если нет платежа
         v_SUM_ACCR_INT:=case when i.prepaid_int>0 then v_SUM_ACCR_INT else v_SUM_ACCR_INT+v_accr_int end;
         -- обнуляние плановых процентов
         v_int_due:=0;
         -- Результат для отложенных процентов
         out_record.POSTP_INT:=0;
         -- обнуление планового платежа по основному долгу
         v_prpl_due:=0;
      end if;

       -- вычисляем досрочное погашение основного долга
       v_PRPL_PREP:=case when case when i.prpl_prep is null
                         then nvl(i.prpl_prep,0)
                         else i.prpl_prep-v_prpl_due end<0 then 0 else case when i.prpl_prep is null
                         then nvl(i.prpl_prep,0)
                         else i.prpl_prep-v_prpl_due end end;

      -- Формирование результата
      out_record.rn:=i.rn;
      out_record.from_date:=i.from_date;
      out_record.to_date:=i.to_date;
      out_record.INT_RATE:=i.int_rate;
      out_record.ACCR_INT:=round(V_ACCR_INT,2);
      out_record.PREPAID_INT:=i.prepaid_int;
      out_record.INT_DUE:=case i.rn when i.cnt
                                    then round(v_ACCR_INT+v_POSTP_INT-v_PREPAID_INT,2)
                                    else round(v_int_due,2) end;
      out_record.EMI_AMOUNT:=case i.rn when i.cnt
                                       then round(v_ACCR_INT+v_POSTP_INT-v_PREPAID_INT+round(V_PRPL_EXPECTED,2),2)
                                       else i.emi_amount end;
      out_record.PRPL_PREP:=case v_PRPL_PREP when 0 then null else v_PRPL_PREP end;
      out_record.PRPL_DUE:=case i.rn when i.cnt
                                     then round(V_PRPL_EXPECTED,2)
                                     else round(v_prpl_due,2) end;
      out_record.PRPL_EXPECTED:=round(V_PRPL_EXPECTED,2);
      out_record.PRPL_INCR:=i.PRPL_INCR;

      v_PRPL_INCR:=i.PRPL_INCR;

      if i.emi_amount is null then
         v_PREPAID_INT:=v_PREPAID_INT+nvl(i.prepaid_int,0);
      else
         v_PREPAID_INT:=nvl(i.prepaid_int,0);
      end if;

      if i.prepaid_int>0 then
         -- обнуление отложенныч процентов если было ЧДП с гашением процентов
         v_postp_int:=0;
      end if;

      -- выброс результата
      pipe row(out_record);
    END LOOP;
  return;
  end CASHFLOW_F;
  --
  FUNCTION check_params3_SBL (pi_loan_account IN VARCHAR2,
                           pi_payment_plan_date OUT DATE,
                           --pi_ovd_close_date IN DATE,
                           pi_1paym_date IN DATE,
                           pi_1paym_sum  IN NUMBER,
                           pi_2paym_date IN DATE,
                           pi_2paym_sum  IN NUMBER,
                           pi_3paym_date IN DATE,
                           pi_3paym_sum  IN NUMBER,
                           pi_4paym_date IN DATE,
                           pi_4paym_sum  IN NUMBER,
                           pi_5paym_date IN DATE,
                           pi_5paym_sum  IN NUMBER,
                           pi_last_paym_sum  IN NUMBER,
                           po_is_buy_back OUT NUMBER) RETURN VARCHAR2
    IS
       lv_retval VARCHAR2(4000);
       ld_today  DATE;
     ln_cnt NUMBER;
       ld_next_paym_day  DATE;
       ld_nextnext_paym_day  DATE;
       lv_branch_code fcc.CLTB_ACCOUNT_MASTER.Branch_code%TYPE;
       lv_product_code fcc.CLTB_ACCOUNT_MASTER.Product_code%TYPE;
       ln_is_buy_back NUMBER;
       ln_cnt_dist_paym_date NUMBER;
       ln_cnt_paym_date NUMBER;
       ln_field_no FCC.CLTM_PRODUCT_UDF.field_no%TYPE;
       FUNCTION add_info_to_ret_val (pi_retval IN VARCHAR2, pi_add_info IN VARCHAR2) RETURN VARCHAR2 IS
       lv_funct_out VARCHAR2(4000);
       BEGIN
            IF pi_retval='OK' THEN lv_funct_out:=pi_add_info;
            ELSE lv_funct_out:=pi_retval||chr(13)||pi_add_info;
            END IF;
            RETURN lv_funct_out;
       END add_info_to_ret_val;
   BEGIN
     lv_retval:='OK';
     IF length(pi_loan_account)<>18 THEN
        lv_retval:=add_info_to_ret_val (lv_retval, 'Значение параметра "Номер кредита" должно содержать 18 символов, задано '||length(pi_loan_account));
   ELSE
     SELECT count(*) into ln_cnt
     FROM CLTB_ACCOUNT_MASTER
     WHERE ACCOUNT_NUMBER = pi_loan_account;
     if ln_cnt=0
     then lv_retval:='Кредит не найден';
     else
         --get credit params
         SELECT Branch_code, Product_code
         INTO lv_branch_code, lv_product_code
         FROM CLTB_ACCOUNT_MASTER
         WHERE ACCOUNT_NUMBER = pi_loan_account;
         --get today for branch
         SELECT today INTO ld_today FROM fcc.sttm_dates
         WHERE Branch_code = lv_branch_code;
         BEGIN
          SELECT MIN(to_date) INTO ld_next_paym_day FROM
                 (SELECT a.SCHEDULE_ST_DATE from_date, a.SCHEDULE_DUE_DATE to_date, a.amount_due AM_DUE
                  FROM fcc.CLTB_ACCOUNT_SCHEDULES  a
                   WHERE a.ACCOUNT_NUMBER = pi_loan_account
                   AND a.COMPONENT_NAME = 'MAIN_INT'
                   AND a.SCHEDULE_DUE_DATE >= ld_today);
         EXCEPTION WHEN NO_DATA_FOUND THEN
          ld_next_paym_day:=null;
         END;
         --get next payment for credit
         BEGIN
           SELECT MIN(to_date) INTO ld_nextnext_paym_day FROM
                 (SELECT a.SCHEDULE_ST_DATE from_date, a.SCHEDULE_DUE_DATE to_date, a.amount_due AM_DUE
                  FROM fcc.CLTB_ACCOUNT_SCHEDULES  a
                   WHERE a.ACCOUNT_NUMBER = pi_loan_account
                   AND a.COMPONENT_NAME = 'MAIN_INT'
                   AND a.SCHEDULE_DUE_DATE > ld_next_paym_day);
         EXCEPTION WHEN NO_DATA_FOUND THEN
          ld_nextnext_paym_day:=ld_next_paym_day;
         END;
         ld_nextnext_paym_day:=nvl(ld_nextnext_paym_day,ld_next_paym_day);
         --Проверям сумму для кредитов Buy Back
         ln_is_buy_back:=0;
         SELECT max(field_no)
         INTO ln_field_no FROM FCC.CLTM_PRODUCT_UDF
         WHERE field_name='BUY_BACK'
         AND product_code=lv_product_code;
         if ln_field_no is not null then
          execute immediate
          'SELECT count(*) FROM CLTB_ACCOUNT_APPS_MASTER
            WHERE account_number='''||pi_loan_account||'''
            AND field_char_'||to_char(ln_field_no)||' = ''YES''' into ln_is_buy_back;
          po_is_buy_back:=ln_is_buy_back;
         else
          po_is_buy_back:=ln_is_buy_back;
         end if;
         --IF ln_is_buy_back>0 and nvl(pi_last_paym_sum,0)=0 then  lv_retval:=add_info_to_ret_val (lv_retval, 'Для автокредитов "Buy Back" необходимо указать ненулевое значение параметра "Сумма последнего платежа по договору"'); end if;
         --IF ln_is_buy_back=0 and nvl(pi_last_paym_sum,0)>0 then  lv_retval:=add_info_to_ret_val (lv_retval, 'Кредит не является автокредитом "Buy Back" необходимо указать нулевое значение параметра "Сумма последнего платежа по договору"'); end if;
         --проверяем параметры для ЧДП
         for rec in (select pi_1paym_date paym_date, pi_1paym_sum paym_sum from dual
               union all
               select pi_2paym_date paym_date, pi_2paym_sum paym_sum from dual
               union all
               select pi_3paym_date paym_date, pi_3paym_sum paym_sum from dual
               union all
               select pi_4paym_date paym_date, pi_4paym_sum paym_sum from dual
               union all
               select pi_5paym_date paym_date, pi_5paym_sum paym_sum from dual
               order by paym_date asc nulls last) loop
           if rec.paym_date is not null and nvl(rec.paym_sum,0)=0 then  lv_retval:=add_info_to_ret_val (lv_retval, 'Для платежа от '||to_char(rec.paym_date,'DD.MM.RRRR')||' не указана сумма'); end if;
           if rec.paym_date is null and rec.paym_sum>0 then  lv_retval:=add_info_to_ret_val (lv_retval, 'Для платежа с суммой '||to_char(rec.paym_sum)||' не указана дата'); end if;
           if rec.paym_date is not null and rec.paym_date>ld_nextnext_paym_day then  lv_retval:=add_info_to_ret_val (lv_retval, 'Дата платежа от '||to_char(rec.paym_date,'DD.MM.RRRR')||' больше планируемой даты платежа, следующего за очередным погашением   ('||to_char(ld_nextnext_paym_day,'DD.MM.RRRR')||')'); end if;
           if rec.paym_date is not null and rec.paym_date>pi_payment_plan_date then  lv_retval:=add_info_to_ret_val (lv_retval, 'Дата платежа от '||to_char(rec.paym_date,'DD.MM.RRRR')||' больше планируемой даты платежа, следующего за очередным погашением   ('||to_char(pi_payment_plan_date,'DD.MM.RRRR')||')'); end if;
           --if rec.paym_date is not null and rec.paym_date<=ld_today then  lv_retval:=add_info_to_ret_val (lv_retval, 'Дата платежа от '||to_char(rec.paym_date,'DD.MM.RRRR')||' меньше или равна текущему операционному дню отделения кредита ('||to_char(ld_today,'DD.MM.RRRR')||')'); end if;
           if rec.paym_date is not null and rec.paym_date<ld_today then  lv_retval:=add_info_to_ret_val (lv_retval, 'Дата платежа от '||to_char(rec.paym_date,'DD.MM.RRRR')||' меньше текущего операционного дня отделения кредита ('||to_char(ld_today,'DD.MM.RRRR')||')'); end if;
         end loop;
         --проверяем есть ли 2 одинаковые даты в ЧДП и есть ли хоть одно ЧДП
         SELECT count(distinct paym_date), count(paym_date), max(paym_date)+1 --дата за последним ЧДП
          INTO ln_cnt_dist_paym_date, ln_cnt_paym_date, pi_payment_plan_date FROM
           (select pi_1paym_date paym_date, pi_1paym_sum paym_sum from dual
            union all
           select pi_2paym_date paym_date, pi_2paym_sum paym_sum from dual
            union all
           select pi_3paym_date paym_date, pi_3paym_sum paym_sum from dual
            union all
           select pi_4paym_date paym_date, pi_4paym_sum paym_sum from dual
            union all
           select pi_5paym_date paym_date, pi_5paym_sum paym_sum from dual) params
         WHERE params.paym_date is not null
         and nvl(params.paym_sum,0)>0
         and params.paym_date<=ld_nextnext_paym_day;
         --новое для Buy back считаем до конца кредита
         --if ln_is_buy_back>0 then
         --для всех теперь
          SELECT max(c.schedule_due_date) INTO pi_payment_plan_date
          FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
          WHERE c.ACCOUNT_NUMBER  = pi_loan_account
          AND C.COMPONENT_NAME = 'PRINCIPAL';
         --end if;
         if ln_cnt_dist_paym_date<>ln_cnt_paym_date then  lv_retval:=add_info_to_ret_val (lv_retval, 'Введены платежи с одинаковыми датами'); end if;
         if ln_cnt_paym_date=0 then  lv_retval:=add_info_to_ret_val (lv_retval, ' Необходимо ввести хотя бы один платеж частично-досрочного погашения'); end if;
      end if;
    END IF;
     RETURN lv_retval;
   END check_params3_SBL;

  procedure fill_report_by_date2_SBL (pi_loan_account in varchar2
                                    ,pi_payment_plan_date in date
                                    ,pi_ovd_close_date in date)
  is
    pragma autonomous_transaction;
    lv_current_step varchar2(100);
    lc_char1 char(1);
    ld_sch_start_date date;
    ld_min_from_date date;
    ld_max_from_date date;
    ld_first_from_date date;
    ld_year_last_day date;
    ld_branch_day    date;
    ld_branch_day2    date;
    ln_curr_year_days_cnt number;
    ln_next_year_days_cnt number;
    ln_prpl_expected_sum number;
    ln_prpl_expected_sum_last number;
    ln_divisor number;
    ln_int_expected number;
    ln_int_due     number;
    ln_principal_overdue number;
    ln_interest_overdue number;
    ln_int_on_ovd_p_accrued number;
    ln_penalty_p number;
    ln_penalty_i number;
    lv_check_message     varchar2(200);
    ld_today date;
    ln_int_ovd_rate number;
    ln_penalty_rate  number;
    --for ANNUAL | PER_DAY calculation basis difference
    lv_calc_basis varchar (255);
    leap_year_days number;
    ordn_year_days number;
  ln_row_cnt number;
  begin
    execute immediate 'truncate table rep_int_due_calc_totals';
    execute immediate 'truncate table rep_int_due_calc';
    --check params
    lv_check_message := check_params2_SBL (pi_loan_account
                                     ,pi_payment_plan_date
                                     ,pi_ovd_close_date);

    insert into rep_int_due_calc_totals (account_number
                                        ,check_message)
  values (pi_loan_account,lv_check_message);
  commit;
  UPDATE rep_int_due_calc_totals
  SET customer_name=(select name_rus3 || ' ' || name_rus1 || ' ' || name_rus2 as customer_name
                from fcc.sttm_cust_personal
               where customer_no = (select customer_id
                          from fcc.cltb_account_master
                           where account_number = pi_loan_account
                           and rownum = 1)
            );
  COMMIT;
    --get data for report
    if lv_check_message='OK' then
      lv_current_step:='Trunc result table';
      lv_current_step:='Init fill FROM_DATE';
      --new
      begin
      --get branch day
        select today
          into ld_branch_day2
          from fcc.sttm_dates
         where branch_code = (select branch_code
                                from fcc.cltb_account_master
                               where account_number = pi_loan_account);

        select max (to_date)
          into ld_sch_start_date
          from (select a.schedule_st_date from_date
                      ,a.schedule_due_date to_date
                      ,a.amount_due am_due
                  from fcc.cltb_account_schedules  a
                 where a.account_number = pi_loan_account
                   and a.component_name = 'PRINCIPAL'
                   and a.schedule_due_date < (select today
                                                from fcc.sttm_dates d
                                               where d.branch_code = a.branch_code))
         where am_due <> 0;
      exception
        when no_data_found then
          ld_sch_start_date:=null;
      end;
      --end new
      if ld_sch_start_date is null then
        select min(c.schedule_st_date) from_date
          into ld_first_from_date
          from fcc.cltb_account_schedules  c
         where c.account_number  = pi_loan_account
           and c.component_name = 'PRINCIPAL'
           and c.schedule_due_date <  pi_payment_plan_date;
        --new credit
        if ld_first_from_date is null then
          --set value date
          select max(value_date)
            into ld_first_from_date
            from fcc.cltb_account_master  c
           where c.account_number = pi_loan_account;
        end if;

        if ld_first_from_date is not null then
          insert into rep_int_due_calc (from_date)
          values (ld_first_from_date);
        end if;
      end if;

      insert into rep_int_due_calc (from_date)
      select distinct c.schedule_due_date from_date
        from fcc.cltb_account_schedules  c
       where c.account_number = pi_loan_account
         and c.component_name = 'PRINCIPAL'
         and (c.schedule_due_date >= ld_sch_start_date
           or ld_sch_start_date is null)
         and c.schedule_due_date /*<=*/< pi_payment_plan_date;

      commit;

      lv_current_step := 'Add fill FROM_DATE';
      select min (from_date)
        into ld_min_from_date
        from rep_int_due_calc;

      if ld_min_from_date is not null then
        insert into rep_int_due_calc (from_date)
        select distinct c.value_date from_date
          from fcc.cltb_liq a
              ,fcc.cltb_account_events_processed b
              ,fcc.cltb_event_entries c
         where a.account_number = b.account_number
           and a.account_number = c.account_number
           and a.event_seq_no = b.event_seq_no
           and a.event_seq_no = c.event_seq_no
           and a.account_number = pi_loan_account
           and a.installment_payment = 'N'
           and a.value_date > ld_min_from_date
           and b.component_name = 'PRINCIPAL'
           and b.execution_status = 'P'
           and a.payment_status = 'P'
           and b.event_code = 'MLIQ'
           and c.amount_tag = 'PRINCIPAL_DLIQ'
           and c.value_date not in (select from_date
                                      from rep_int_due_calc);
        COMMIT;
        -- PRB22238 add PrePay Date in current oper.date
        insert into rep_int_due_calc (from_date)
        select distinct c.value_date from_date
          from fcc.cltb_liq a
              ,fcc.cltb_account_events_diary b
              ,fcc.cltb_event_entries c
         where a.account_number = b.account_number
           and a.account_number = c.account_number
           and a.event_seq_no = b.event_seq_no
           and a.event_seq_no = c.event_seq_no
           and a.account_number = pi_loan_account
           and a.installment_payment = 'N'
           and a.value_date > ld_min_from_date
           and b.component_name = 'PRINCIPAL'
           and b.execution_status = 'P'
           and a.payment_status = 'P'
           and b.event_code = 'MLIQ'
           and c.amount_tag = 'PRINCIPAL_DLIQ'
           and c.value_date not in (select from_date
                                      from rep_int_due_calc);
      --
      COMMIT;
      --
      lv_current_step := 'Add last date of the year';
      for rec in (select from_date
                    from rep_int_due_calc
                   where from_date is not null)
      loop
        select add_months (trunc (rec.from_date, 'year'), 12) - trunc (rec.from_date, 'year')
          into ln_curr_year_days_cnt
          from dual;

        select add_months (trunc (add_months (rec.from_date,12), 'year'), 12) - trunc (add_months (rec.from_date, 12), 'year')
          into ln_next_year_days_cnt
          from dual;

        if ln_curr_year_days_cnt = 366 or ln_next_year_days_cnt = 366 then
          select max (from_date)
            into ld_max_from_date
            from rep_int_due_calc;

          ld_year_last_day := least (GREATEST(ld_max_from_date,pi_payment_plan_date), add_months (trunc (rec.from_date, 'year'), 12) - 1); -- Polischuk N.A. add end of year
          IF ld_year_last_day <> pi_payment_plan_date THEN
            begin
              select 'x'
                into lc_char1
                from rep_int_due_calc
               where from_date = ld_year_last_day;
            exception
              when no_data_found then
                insert into rep_int_due_calc (from_date)
                values (ld_year_last_day);
                commit;
            end;
          END IF;
        end if;
      end loop;

      lv_current_step := 'Add rate change dates';
      select min (from_date)
            ,max(from_date)
        into ld_min_from_date
            ,ld_max_from_date
        from rep_int_due_calc;

      insert into rep_int_due_calc (from_date)
      select distinct effective_date
        from fcc.cltb_account_ude_values
       where account_number = pi_loan_account
         and effective_date >= ld_min_from_date -- мин. дата from_date
         and effective_date <= ld_max_from_date -- макс. дата from_date
         and ude_id = 'INTEREST_RATE'
         and effective_date not in (select from_date
                                      from rep_int_due_calc);
      commit;

      lv_current_step := 'Fill TO_DATE';
      update rep_int_due_calc c2
         set c2.to_date = nvl ((select min(c1.from_date)
                                  from rep_int_due_calc c1
                                 where c1.from_date > c2.from_date), null);
      commit;

      update rep_int_due_calc c2
         set c2.to_date = pi_payment_plan_date
       where from_date = (select max(from_date)
                            from rep_int_due_calc);
      commit;

      lv_current_step := 'Fill EMI_AMOUNT';
      for rec in (select to_date
                    from rep_int_due_calc
                   where to_date is not null
                   order by to_date)
      loop
        for cur_var in (select a.schedule_due_date
                              ,a.emi_amount
                          from fcc.cltb_account_schedules a
                         where a.account_number = pi_loan_account
                           and a.schedule_due_date >= rec.to_date
                           and a.schedule_due_date <= pi_payment_plan_date
                           and a.component_name = 'MAIN_INT'
                        order by a.schedule_due_date)
        loop
          update rep_int_due_calc
             set emi_amount = cur_var.emi_amount
           where to_date = cur_var.schedule_due_date;
        end loop;
      end loop;
      commit;

      lv_current_step := 'Fill PRINCIPAL';
      for rec in (select a.to_date
                    from rep_int_due_calc a
                   where a.to_date is not null
                     and a.to_date <> (select max(b.to_date)
                                         from rep_int_due_calc b)
                  order by a.to_date)
      loop
        for cur_var in (select a.value_date value_date
                              ,sum(c.amount) principal
                          from fcc.cltb_liq a
                              ,fcc.cltb_account_events_processed b
                              ,fcc.cltb_event_entries c
                         where a.account_number = b.account_number
                           and a.account_number = c.account_number
                           and b.component_name = c.component_name
                           and a.event_seq_no = b.event_seq_no
                           and a.event_seq_no = c.event_seq_no
                           and a.account_number = pi_loan_account
                           and a. value_date >= rec.to_date
                           and b.component_name ='PRINCIPAL'
                           and b.execution_status = 'P'
                           and a.payment_status = 'P'
                           and c.amount_tag = 'PRINCIPAL_DLIQ'
                        group by a.value_date
                        order by value_date)
        loop
          update rep_int_due_calc
             set principal = cur_var.principal
           where to_date = cur_var.value_date;
        end loop;
        --
      end loop;
      commit;
      -- PRB22238 add PrePay in current oper.date
      update rep_int_due_calc
         set principal = nvl(principal,0) +
                         nvl((select sum(c.amount)
                                from fcc.cltb_liq a
                                    ,fcc.cltb_account_events_diary b
                                    ,fcc.cltb_event_entries c
                               where a.account_number = b.account_number
                                 and a.account_number = c.account_number
                                 and a.event_seq_no = b.event_seq_no
                                 and a.event_seq_no = c.event_seq_no
                                 and a.account_number = pi_loan_account
                                 and a.installment_payment = 'N'
                                 and a.value_date = ld_branch_day2
                                 and b.component_name = 'PRINCIPAL'
                                 and b.execution_status = 'P'
                                 and a.payment_status = 'P'
                                 and b.event_code = 'MLIQ'
                                 and c.amount_tag = 'PRINCIPAL_DLIQ'),0)
        where to_date = ld_branch_day2 and from_date <> to_date ;
      COMMIT;
      --
      lv_current_step:='Fill INT_PREPAID';
      for rec in (select to_date
                    from rep_int_due_calc
                   where to_date is not null
                  order by to_date)
      loop
        for cur_var in (select a.value_date value_date
                              ,sum(c.amount) int_prepaid
                          from fcc.cltb_liq a
                              ,fcc.cltb_account_events_processed b
                              ,fcc.cltb_event_entries c
                         where a.account_number = b.account_number
                           and a.account_number = c.account_number
                           and b.component_name = c.component_name
                           and a.event_seq_no = b.event_seq_no
                           and a.event_seq_no = c.event_seq_no
                           and a.account_number = pi_loan_account
                           and a.installment_payment = 'N'
                           and a.value_date >=rec.to_date
                           and b.component_name ='MAIN_INT'
                           and b.execution_status = 'P'
                           and a.payment_status = 'P'
                           and c.amount_tag = 'MAIN_INT_DLIQ'
                           and b.event_code = 'MLIQ'
                        group by a.VALUE_DATE
                        order by VALUE_DATE)
        loop
          update rep_int_due_calc
             set int_prepaid = cur_var.int_prepaid
           where to_date = cur_var.value_date;
        end loop;
      end loop;
      commit;

      lv_current_step:='Fill PRPL_EXPECTED';
      update rep_int_due_calc s
         set s.prpl_expected = (select nvl (sum (case
                                                   when (component_name = 'PRINCIPAL' and schedule_due_date >= pi_payment_plan_date) then amount_due - nvl (amount_settled, 0)
                                                   else 0
                                                 end)
                                           ,0) prpl_expected
                                  from fcc.cltb_account_schedules
                                 where account_number = pi_loan_account)
       where s.from_date = (select max (from_date)
                              from rep_int_due_calc);
      commit;

      lv_current_step := 'Fill last PRINCIPAL';
      update rep_int_due_calc s
         set s.principal = (select nvl (sum (case
                                               when (component_name = 'PRINCIPAL' and schedule_due_date >= pi_payment_plan_date) then amount_due - nvl (amount_settled, 0)
                                               else 0
                                             end)
                                       ,0) prpl_expected
                              from fcc.cltb_account_schedules
                             where account_number = pi_loan_account)
       where s.from_date = (select max (from_date)
                              from rep_int_due_calc);
      commit;

      lv_current_step:='Fill TRANCHE';
      for rec in (select to_date
                        ,from_date
                    from rep_int_due_calc
                   where to_date is not null
                  order by to_date)
      loop
        for cur_var in (select value_date value_date
                              ,sum(amount) tranche
                          from fcc.cltb_event_entries
                         where account_number = pi_loan_account
                           and event_code = 'VAMI'
                           and value_date between rec.from_date and rec.to_date
                        group by value_date)
        loop
          update rep_int_due_calc
             set tranche = cur_var.tranche
           where to_date = rec.to_date;
        end loop;
      end loop;
      commit;

      lv_current_step:='Fill other PRINCIPAL';
      ln_PRPL_EXPECTED_sum := 0;
      --new
      select sum (nvl (amount_due, 0))
        into ln_prpl_expected_sum_last
        from fcc.cltb_account_schedules
       where account_number = pi_loan_account
         and schedule_due_date >ld_branch_day2
         and schedule_due_date <pi_payment_plan_date
         and component_name = 'PRINCIPAL';

      ln_PRPL_EXPECTED_sum_last := nvl (ln_PRPL_EXPECTED_sum_last, 0);
      --end new
      for cur_var in (select nvl (principal, 0) principal
                            ,nvl (tranche, 0) tranche
                            ,to_date
                        from rep_int_due_calc
                      order by to_date desc)
      loop
        ln_prpl_expected_sum := ln_prpl_expected_sum + cur_var.principal - cur_var.tranche;
        update rep_int_due_calc
           set prpl_expected = ln_prpl_expected_sum
         where to_date = cur_var.to_date;

        ln_prpl_expected_sum := ln_prpl_expected_sum + ln_prpl_expected_sum_last;
        ln_prpl_expected_sum_last := 0;
      end loop;
      commit;

      lv_current_step:='Fill RATE';
      for rec in (select to_date
                    from rep_int_due_calc
                   where to_date is not null
                  order by to_date)
      loop
        for cur_var in (select effective_date
                              ,ude_value rate
                          from fcc.cltb_account_ude_values
                         where account_number = pi_loan_account
                           and effective_date<=rec.to_date
                           and ude_id = 'INTEREST_RATE'
                        order by effective_date)
        loop
          update rep_int_due_calc
             set int_rate = cur_var.rate
           where to_date = rec.to_date;
        end loop;
      end loop;
      commit;

      lv_current_step:='Fill ACCR_INT';
      for rec in (select from_date
                    from rep_int_due_calc)
      loop
        select add_months (trunc (rec.from_date + 1, 'year'), 12) - trunc (rec.from_date + 1, 'year')
          into ln_curr_year_days_cnt
          from dual;

        if ln_curr_year_days_cnt = 365 then
          ln_divisor := 36500;
                                       else
          ln_divisor := 36600;
        end if;

        update rep_int_due_calc
           --set accr_int = round (prpl_expected * int_rate * (to_date - from_date) / ln_divisor, 2) korn20180425
       set accr_int = prpl_expected * int_rate * (to_date - from_date) / ln_divisor
         where from_date = rec.from_date;
        end loop;
        commit;

        lv_current_step := 'Fill INT_EXPECTED';
        ln_INT_EXPECTED := 0;
        --new
        ln_INT_EXPECTED := nvl(ln_INT_EXPECTED,0);
        --end new
        for rec in (select from_date
                          ,accr_int
                          ,emi_amount
                      from rep_int_due_calc
                    order by from_date)
        loop
          --add task from golovan 20130403
          if ln_int_expected + nvl (rec.accr_int, 0) - nvl (rec.emi_amount, 0) > 0 then
            ln_int_due := ln_int_expected + nvl (rec.accr_int, 0) - (ln_int_expected + nvl (rec.accr_int, 0) - nvl(rec.emi_amount, 0));
                                                                                   else
            ln_int_due := ln_int_expected + nvl (rec.accr_int, 0);
          end if;

          ln_int_expected := ln_int_expected + nvl (rec.accr_int, 0) - nvl (rec.emi_amount, 0);
          update rep_int_due_calc
             set int_expected = ln_int_expected
           where from_date = rec.from_date;

          update rep_int_due_calc
             set int_due = ln_int_due
           where from_date=rec.from_date;
        end loop;
        commit;
        --additional req from Golovan 20130116
        insert into rep_int_due_calc (int_expected)
        select sum (nvl (int_expected, 0)) - sum (nvl (accr_int, 0))
          from rep_int_due_calc
         where from_date = ld_max_from_date;
        commit;
        --end additional req from Golovan 20130116

        lv_current_step:='Fill overdue info';
        --get branch day
        ld_branch_day := pi_ovd_close_date;
        ln_principal_overdue := 0;
        ln_interest_overdue := 0;
        ln_int_on_ovd_p_accrued := 0;
        ln_penalty_p := 0;
        ln_penalty_i := 0;
        if ld_branch_day is not null then
          select nvl (sum (case
                             when (component_name = 'PRINCIPAL' and schedule_due_date < ld_branch_day) THEN amount_due - NVL (amount_settled, 0)
                             else 0
                           end)
                     ,0) principal_overdue
            into ln_principal_overdue
            from fcc.cltb_account_schedules
           where account_number = pi_loan_account;
          ---------------------------------
          select nvl (sum (case
                             when (component_name = 'MAIN_INT' and schedule_due_date < ld_branch_day) then nvl (accrued_amount, 0) - nvl (amount_settled, 0)
                             else 0
                           end)
                     ,0) interest_overdue
            into ln_interest_overdue
            from fcc.cltb_account_schedules
           where account_number = pi_loan_account;
          ---------------------------------
          select nvl (sum (case
                             when (component_name = 'INT_ON_OVD_P' and schedule_due_date >= ld_branch_day2) then nvl (amount_due, 0) - nvl (amount_settled, 0)
                             else 0
                           end)
                     ,0) int_on_ovd_p_accrued
            into ln_int_on_ovd_p_accrued
            from fcc.cltb_account_schedules
           where account_number = pi_loan_account;
          ---------------------------------
          select nvl (sum (case
                             when (component_name = 'PENALTY_P' and schedule_due_date <= ld_branch_day) then nvl (amount_due, 0) - nvl (amount_settled, 0)
                             else 0
                           end)
                     ,0) penalty_p into ln_penalty_p
            from fcc.cltb_account_schedules
           where account_number = pi_loan_account;
          ---------------------------------
          select nvl (sum (case
                             when (component_name = 'PENALTY_I' and schedule_due_date <= ld_branch_day) then nvl (amount_due, 0) - nvl (amount_settled, 0)
                             else 0
                           end)
                     ,0) penalty_i into ln_penalty_i
            from fcc.cltb_account_schedules
           where account_number = pi_loan_account;
        end if;

        lv_current_step:='Fill report';
        --prepare
        --get today
        select today
          into ld_today
          from fcc.sttm_dates
         where branch_code = (select branch_code
                                from cltb_account_master
                               where account_number = pi_loan_account);
        --get rates
        begin
          select nvl (ude_value, 0) rate
            into ln_int_ovd_rate
            from fcc.cltb_account_ude_values
           where account_number = pi_loan_account
             and effective_date = (select max(effective_date)
                                     from fcc.cltb_account_ude_values
                                    where account_number = pi_loan_account
                                      and effective_date<=pi_ovd_close_date
                                      and ude_id = 'INT_OVD_RATE')
             and ude_id = 'INT_OVD_RATE';
        exception
          when no_data_found then
            ln_INT_OVD_RATE:=0;
        end;

        begin
          select nvl (ude_value, 0) rate
            into ln_penalty_rate
            from fcc.cltb_account_ude_values
           where account_number = pi_loan_account
             and effective_date = (select max (effective_date)
                                     from fcc.cltb_account_ude_values
                                    where account_number = pi_loan_account
                                      and effective_date<=pi_ovd_close_date
                                      and ude_id = 'PENALTY_RATE')
             and ude_id = 'PENALTY_RATE';
        exception
          when no_data_found then
            ln_PENALTY_RATE:=0;
        end;
        -- AD46331 Start

        select am.field_char_3
          into lv_calc_basis
          from fcc.cltb_account_master am
         where am.account_number = pi_loan_account;

        if lv_calc_basis = 'ANNUAL'
        then
          begin
            if mod (extract (year from pi_ovd_close_date), 4) = 0 and mod (extract (year from ld_today), 4) != 0
            then
              begin
                leap_year_days := pi_ovd_close_date - trunc (pi_ovd_close_date, 'rrrr');
                ordn_year_days := trunc (pi_ovd_close_date, 'rrrr') - ld_today;
              end;
            elsif mod (extract (year from pi_ovd_close_date), 4) != 0 and mod (extract (year from ld_today), 4) = 0
            then
              begin
                leap_year_days := trunc (pi_ovd_close_date, 'rrrr') - ld_today;
                ordn_year_days := pi_ovd_close_date - trunc (pi_ovd_close_date, 'rrrr');
              end;
            elsif mod (extract (year from pi_ovd_close_date), 4) = 0 and mod (extract (year from ld_today), 4) = 0
            then
              begin
                leap_year_days := pi_ovd_close_date - ld_today;
                ordn_year_days := 0;
              end;
            else
              begin
                leap_year_days := 0;
                ordn_year_days := pi_ovd_close_date - ld_today;
              end;
            end if;
          end;
        else
          begin
            leap_year_days := 0;
            ordn_year_days := pi_ovd_close_date - ld_today;
          end;
        end if;

        -- AD46331 Finish
        --fill report
        insert into rep_int_due_calc_totals
                   (account_number
                   ,prpl_expected
                   ,int_expected
                   ,principal_overdue
                   ,interest_overdue
                   ,int_on_ovd_p_accrued
                   ,penalty_p
                   ,penalty_i
                   ,exp_pay_cnt)
        values (pi_loan_account
               ,nvl ((select sum(nvl(prpl_expected,0))
                        from rep_int_due_calc
                       where from_date=ld_max_from_date)
                    ,0)
               /*,nvl ((select sum(nvl(accr_int,0))
                        from rep_int_due_calc
                       where from_date=ld_max_from_date)
                    ,0)
               +nvl ((select sum(int_expected)
                        from rep_int_due_calc
                       where from_date = (select max(from_date)
                                            from rep_int_due_calc
                                           where from_date < ld_max_from_date)
                         and int_expected > 0)
                    ,0)*/
        ,round(nvl ((select sum(nvl(accr_int,0))
                        from rep_int_due_calc
                       where from_date=ld_max_from_date)
                    ,0)
          +nvl ((select sum(int_expected)
              from rep_int_due_calc
               where from_date = (select max(from_date)
                        from rep_int_due_calc
                         where from_date < ld_max_from_date)
               and int_expected > 0)
            ,0),2) --korn20180425
               ,nvl (ln_principal_overdue,0)
               ,nvl (ln_interest_overdue,0)
               ,round (nvl (ln_int_on_ovd_p_accrued, 0) + nvl (ln_principal_overdue, 0) * (ln_int_ovd_rate / 100) * (leap_year_days / 366 + ordn_year_days / 365), 2) -- Changed to 366 Polishchuk NA INC000635178
               ,round (nvl (ln_penalty_p, 0) + nvl (ln_principal_overdue, 0) * (ln_penalty_rate / 100) * case lv_calc_basis when 'ANNUAL' then leap_year_days / 366 + ordn_year_days / 365 else ordn_year_days end, 2)
               ,round (nvl (ln_penalty_i, 0) + nvl (ln_interest_overdue, 0) * (ln_penalty_rate / 100) * case lv_calc_basis when 'ANNUAL' then leap_year_days / 366 + ordn_year_days / 365 else ordn_year_days end, 2)
               ,(select count(*)
                   from fcc.cltb_account_schedules  c
                  where c.account_number  = pi_loan_account
                    and c.component_name = 'MAIN_INT'
                    and c.schedule_due_date > pi_payment_plan_date));
        commit;

    --Leila K. Izmailova - 28.09.2017 13:56
      ----------------------
      SELECT  count(*) into ln_row_cnt FROM fcc.cltb_account_schedules
      WHERE   account_number = pi_loan_account
      AND component_name='PENALTY_P';
            if ln_row_cnt=0 then
        update rep_int_due_calc_totals
           set penalty_p = null;
        commit;
      end if;
      ----------------------
      SELECT  count(*) into ln_row_cnt FROM fcc.cltb_account_schedules
      WHERE   account_number = pi_loan_account
      AND component_name='PENALTY_I';
            if ln_row_cnt=0 then
        update rep_int_due_calc_totals
           set penalty_i = null;
        commit;
      end if;
      /*update rep_int_due_calc_totals
           set int_on_ovd_p_accrued = null;
      commit;*/
    --END Leila K. Izmailova - 28.09.2017 13:56
    UPDATE rep_int_due_calc --korn20180425
    SET ACCR_INT=round (ACCR_INT,2),
        INT_EXPECTED=round (INT_EXPECTED,2),
        INT_PREPAID=round (INT_PREPAID,2),
        INT_DUE=round (INT_DUE,2);
      COMMIT;
        update rep_int_due_calc_totals
           set total = nvl (round (prpl_expected, 2), 0)
                     + nvl (round (int_expected, 2), 0)
                     + nvl (round (principal_overdue, 2), 0)
                     + nvl (round (interest_overdue, 2), 0)
                     + nvl (round (int_on_ovd_p_accrued, 2), 0)
                     + nvl (round (penalty_p,2), 0)
                     + nvl (round (penalty_i, 2), 0);
        commit;
        --clear last sum
        update rep_int_due_calc s
           set s.principal = null
         where s.from_date = (select max (from_date)
                                from rep_int_due_calc);
        --new
        select sum (nvl (amount_due, 0))
          into ln_prpl_expected_sum_last
          from fcc.cltb_account_schedules
         where account_number = pi_loan_account
           and schedule_due_date >ld_branch_day2
           and schedule_due_date <pi_payment_plan_date
           and component_name = 'PRINCIPAL';

        ln_prpl_expected_sum_last := nvl(ln_prpl_expected_sum_last, 0);
        update rep_int_due_calc s
           set s.int_due = nvl (s.int_due, 0) + nvl (ln_prpl_expected_sum_last, 0)
         where s.from_date = (select max (from_date)
                                from rep_int_due_calc);
        --end new
        --add task from golovan 20130403
        --tune output
        update rep_int_due_calc s
           set s.principal = nvl (s.emi_amount, 0) - nvl (s.int_due, 0)
         where nvl (s.principal, 0) = 0
           and nvl (s.emi_amount, 0) <> 0;

        update rep_int_due_calc s
           set s.int_expected = null
         where s.int_expected < 0 or nvl (s.emi_amount, 0) = 0;

        update rep_int_due_calc s
           set s.int_due = null
         where nvl (s.emi_amount, 0) = 0;
      end if;
    end if;
    commit;
  end fill_report_by_date2_SBL;

  /*SELECT
    account_number
    ,prpl_expected
    ,int_expected
    ,principal_overdue
    ,interest_overdue
    ,int_on_ovd_p_accrued
    ,penalty_p
    ,penalty_i
    ,total
    ,exp_pay_cnt
    ,customer_name
    ,check_message
FROM TABLE (rep_sbl_pkg.SBL_PREPAY_PDP ('01582086RURRC10002'
                           ,date '2017-08-25'
                           ,date '2017-08-24'));*/
  /*SELECT    FROM_DATE,
        TO_DATE,
        INT_RATE,
        ACCR_INT,
        INT_EXPECTED,
        INT_PREPAID,
        INT_DUE,
        EMI_AMOUNT,
        PRINCIPAL,
        PRPL_EXPECTED,
        TRANCHE
  FROM BODEV.REP_INT_DUE_CALC
    ORDER BY FROM_DATE*/
  --copy from submit_by_date2
  function SBL_PREPAY_PDP (pi_loan_account in varchar2
                           ,pi_payment_plan_date in date
                           ,pi_ovd_close_date in date)
  return rep_sbl_pdp_dt_nt pipelined
  is
  lv_REPORT_WARN  varchar2(100);
  begin
    fill_report_by_date2_SBL (pi_loan_account,pi_payment_plan_date ,pi_ovd_close_date);
    lv_REPORT_WARN:=null;
--  Убрана проверка сторнирующих операций по согласованию с Завгородней Е. 06.05.20  PRB22107
--  begin
--    SELECT   CASE WHEN COUNT (*)>0 THEN 'Выполнялось сторнирование операций' ELSE null END
--      INTO lv_REPORT_WARN
--      FROM   fcc.cltb_account_events_processed
--     WHERE       account_number =pi_loan_account
--         AND event_date > (SELECT   MIN (from_date) FROM bodev.rep_int_due_calc)
--         AND (EVENT_CODE = 'REVV' OR EVENT_CODE = 'REVP');
--  exception when no_data_found then
--    lv_REPORT_WARN:=null;
--  end;
    for rec in (select max(decode(check_message,null,account_number,null)) account_number
                      ,max(decode(check_message,null,prpl_expected,null)) prpl_expected
                      ,max(decode(check_message,null,int_expected,null)) int_expected
                      ,max(decode(check_message,null,principal_overdue,null)) principal_overdue
                      ,max(decode(check_message,null,interest_overdue,null)) interest_overdue
                      ,max(decode(check_message,null,int_on_ovd_p_accrued,null)) int_on_ovd_p_accrued
                      ,max(decode(check_message,null,penalty_p,null)) penalty_p
                      ,max(decode(check_message,null,penalty_i,null)) penalty_i
                      ,max(decode(check_message,null,total,null)) total
                      ,max(decode(check_message,null,exp_pay_cnt,null)) exp_pay_cnt
                      ,max(decode(check_message,null,null,customer_name))  customer_name
                      ,max(decode(check_message,null,null,trim(nvl(check_message,'')||' '||nvl(lv_REPORT_WARN,'')))) check_message
                  from rep_int_due_calc_totals)
    loop
      pipe row (rep_sbl_pdp_dt_t (rec.account_number
                                       ,rec.prpl_expected
                                       ,rec.int_expected
                                       ,rec.principal_overdue
                                       ,rec.interest_overdue
                                       ,rec.int_on_ovd_p_accrued
                                       ,rec.penalty_p
                                       ,rec.penalty_i
                                       ,rec.total
                                       ,rec.exp_pay_cnt
                                       ,rec.customer_name
                                       ,rec.check_message));
    end loop;
    return;
  end SBL_PREPAY_PDP;

  PROCEDURE fill_report_by_date3_SBL(pi_loan_account IN VARCHAR2,
                                  --pi_payment_plan_date IN DATE,
                                  --pi_ovd_close_date IN DATE,
                                  pi_1paym_date IN DATE,
                                  pi_1paym_sum  IN NUMBER,
                                  pi_2paym_date IN DATE,
                                  pi_2paym_sum  IN NUMBER,
                                  pi_3paym_date IN DATE,
                                  pi_3paym_sum  IN NUMBER,
                                  pi_4paym_date IN DATE,
                                  pi_4paym_sum  IN NUMBER,
                                  pi_5paym_date IN DATE,
                                  pi_5paym_sum  IN NUMBER,
                                  pi_last_paym_sum  IN NUMBER,
                                  pi_principal_amt IN NUMBER
                                  )
   IS
   PRAGMA AUTONOMOUS_TRANSACTION;
   lv_current_step VARCHAR2(100);
   lc_char1 CHAR(1);
   ld_SCH_START_DATE DATE;
   ld_min_FROM_DATE DATE;
   ld_max_FROM_DATE DATE;
   ld_min_TO_DATE DATE;
   ld_max_TO_DATE DATE;
   ld_first_FROM_DATE DATE;
   ld_year_last_day DATE;
   ld_branch_day    DATE;
   ld_branch_day2    DATE;
   ln_curr_year_days_cnt NUMBER;
   ln_next_year_days_cnt NUMBER;
   ln_PRPL_EXPECTED_sum NUMBER;
   ln_PRPL_EXPECTED_sum_last NUMBER;
   ln_divisor NUMBER;
   ln_INT_EXPECTED NUMBER;
   ln_INT_DUE     NUMBER;
   ln_principal_overdue NUMBER;
   ln_interest_overdue NUMBER;
   ln_int_on_ovd_p_accrued NUMBER;
   ln_penalty_p NUMBER;
   ln_penalty_i NUMBER;
   lv_check_message     VARCHAR2(4000);
   --ld_today DATE;
   ln_INT_OVD_RATE NUMBER;
   ln_PENALTY_RATE  NUMBER;
   ln_row_cnt NUMBER;
   ---
   gv_branch_code fcc.CLTB_ACCOUNT_MASTER.Branch_code%TYPE;
   gv_customer_no fcc.CLTB_ACCOUNT_MASTER.customer_id%TYPE;
   gv_branch_day fcc.sttm_dates.today%TYPE;
   gd_max_val_date fcc.CLTB_ACCOUNT_MASTER.value_date%TYPE;
   gd_min_adv_rep_to_date DATE;
   gd_max_adv_rep_to_date DATE;
   gn_MIDDLE_PAYMENT NUMBER;
   gn_is_buy_back NUMBER;
   go_PRINCIPAL_OVERDUE NUMBER;
   go_INTEREST_OVERDUE NUMBER;
   go_INT_ON_OVD_P_ACCRUED NUMBER;
   go_PENALTY_P NUMBER;
   go_PENALTY_I NUMBER;
   go_PRPL_EXPECTED NUMBER;
   ln_prev_INT_EXPECTED NUMBER;
   ln_curr_INT_EXPECTED NUMBER;
   ln_curr_EMI_AMOUNT NUMBER;
   ln_curr_ACCR_INT NUMBER;
   pi_payment_plan_date DATE;
   pi_ovd_close_date DATE;
   ln_sum_ADV_REPAYMENT NUMBER;
   ln_sum_hist_ADV_REPAYMENT NUMBER;
   ln_minus_paym NUMBER;
   ln_due_dates_on NUMBER;
   ln_due_dates_on_rep NUMBER;
   ln_orig_st_date NUMBER;
   ld_maturity_date DATE;
   ln_last2_pay_month NUMBER;
   ln_near28_maturity_date NUMBER;
   ln_debug NUMBER;
   ln_prpl_expected_on_first_adv NUMBER;
   ln_all_adv_repay_sum NUMBER;
   ln_CALC_last_paym_sum NUMBER;
   min_pmnt_date_after_CHDP DATE; -- add Polischuk N. PRB21747
   BEGIN
      lv_current_step:='Trunc result table';
      execute immediate 'TRUNCATE TABLE REP_INT_DUE_CALC_TOTALS3';
      execute immediate 'TRUNCATE TABLE REP_INT_DUE_CALC3';
      execute immediate 'alter session set global_names=false';
      --проверяем параметры
      lv_check_message:=check_params3_SBL (pi_loan_account,
                                           pi_payment_plan_date,
                                           pi_1paym_date,
                                           pi_1paym_sum,
                                           pi_2paym_date,
                                           pi_2paym_sum,
                                           pi_3paym_date,
                                           pi_3paym_sum,
                                       pi_4paym_date,
                                       pi_4paym_sum,
                                       pi_5paym_date,
                                       pi_5paym_sum,
                                       pi_last_paym_sum,
                                       gn_is_buy_back);
      if lv_check_message='OK' then
          --получаем часто используемые значения
          --код отделения, кл. номер, максимальную дату валютирования
          SELECT max(Branch_code), max(customer_id), max(value_date) INTO gv_branch_code, gv_customer_no, gd_max_val_date FROM fcc.CLTB_ACCOUNT_MASTER
          WHERE ACCOUNT_NUMBER = pi_loan_account;
          --опер день отделения
          select today INTO gv_branch_day from fcc.sttm_dates where Branch_code = gv_branch_code;
          pi_ovd_close_date:=gv_branch_day;
          --записываем ФИО клиента
          insert into rep_int_due_calc_totals3(customer_name, check_message)
          select NAME_RUS3||' '||NAME_RUS1||' '||NAME_RUS2 as customer_name, lv_check_message as check_message
          from fcc.STTM_CUST_PERSONAL
          where customer_no=gv_customer_no;
          --если параметры нормальны, то формируем данные отчета
          lv_current_step:='Init fill FROM_DATE';
          BEGIN
          --определяем дату начала расписания для детального рассчета
          --SELECT MAX(to_date) INTO ld_SCH_START_DATE FROM
          SELECT MAX(from_date) INTO ld_SCH_START_DATE FROM
             (SELECT a.SCHEDULE_ST_DATE from_date, a.SCHEDULE_DUE_DATE to_date, a.amount_due AM_DUE
                FROM fcc.CLTB_ACCOUNT_SCHEDULES  a
               WHERE a.ACCOUNT_NUMBER = pi_loan_account
                 AND a.COMPONENT_NAME = 'PRINCIPAL'
                 AND a.SCHEDULE_DUE_DATE < gv_branch_day)
                 WHERE AM_DUE <> 0;
          EXCEPTION WHEN NO_DATA_FOUND THEN
            ld_SCH_START_DATE:=null;
          END;
          --end new
          IF ld_SCH_START_DATE is null THEN
            SELECT min(c.SCHEDULE_ST_DATE) FROM_DATE INTO ld_first_FROM_DATE
            FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
            WHERE c.ACCOUNT_NUMBER  = pi_loan_account
            AND C.COMPONENT_NAME = 'PRINCIPAL'
            AND c.SCHEDULE_DUE_DATE < pi_payment_plan_date;
            --new credit
            --если по кредиту не было погашний ОД, то ставим дату валютирования кредита
            IF ld_first_FROM_DATE IS NULL THEN
                --set value date
                ld_first_FROM_DATE:=gd_max_val_date;
            END IF;
            IF ld_first_FROM_DATE IS NOT NULL THEN
                INSERT INTO REP_INT_DUE_CALC3 (FROM_DATE) VALUES (ld_first_FROM_DATE);
            END IF;
          END IF;
          INSERT INTO REP_INT_DUE_CALC3 (FROM_DATE)
            SELECT distinct c.SCHEDULE_DUE_DATE FROM_DATE
            FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
            WHERE c.ACCOUNT_NUMBER  = pi_loan_account
            AND C.COMPONENT_NAME = 'PRINCIPAL'
            AND (c.SCHEDULE_DUE_DATE >= ld_SCH_START_DATE OR ld_SCH_START_DATE is null)
            AND c.SCHEDULE_DUE_DATE <  pi_payment_plan_date;
            COMMIT;
           --формируем полность расписание для детального расчета
           lv_current_step:='Add fill FROM_DATE';
           --добавляем периоды платежей
           SELECT min (FROM_DATE) into ld_min_FROM_DATE FROM REP_INT_DUE_CALC3;
           IF ld_min_FROM_DATE is not null then
                INSERT INTO REP_INT_DUE_CALC3 (FROM_DATE)
                    SELECT distinct c.VALUE_DATE  FROM_DATE
                    FROM fcc.CLTB_LIQ a, fcc.CLTB_ACCOUNT_EVENTS_PROCESSED b, fcc.cltb_event_entries c
                    WHERE a.ACCOUNT_NUMBER = b.ACCOUNT_NUMBER
                    AND a.ACCOUNT_NUMBER = c.ACCOUNT_NUMBER
                    AND a.EVENT_SEQ_NO = b.EVENT_SEQ_NO
                    AND a.EVENT_SEQ_NO = c.EVENT_SEQ_NO
                    AND a.ACCOUNT_NUMBER = pi_loan_account
                    AND a.INSTALLMENT_PAYMENT = 'N'
                    AND a.VALUE_DATE > ld_min_FROM_DATE
                    AND b.COMPONENT_NAME = 'PRINCIPAL'
                    AND b.EXECUTION_STATUS = 'P'
                    AND a.PAYMENT_STATUS = 'P'  --new
                    AND b.EVENT_CODE = 'MLIQ'
                    AND c.AMOUNT_TAG = 'PRINCIPAL_DLIQ'
                    AND c.VALUE_DATE not in (SELECT FROM_DATE FROM REP_INT_DUE_CALC3);
            lv_current_step:='Add fill FROM_DATE last date of the year';
            --добавляем переход через год
            FOR rec in (SELECT FROM_DATE FROM REP_INT_DUE_CALC3 WHERE FROM_DATE IS NOT NULL) LOOP
                select add_months(trunc(rec.FROM_DATE, 'YEAR'), 12) - trunc(rec.FROM_DATE, 'YEAR') INTO ln_curr_year_days_cnt from dual;
                select add_months(trunc(add_months(rec.FROM_DATE,12), 'YEAR'), 12) - trunc(add_months(rec.FROM_DATE,12), 'YEAR') INTO ln_next_year_days_cnt from dual;
                IF ln_curr_year_days_cnt=366 or ln_next_year_days_cnt=366 THEN
                    SELECT max(FROM_DATE) into ld_max_FROM_DATE FROM REP_INT_DUE_CALC3;
                    ld_year_last_day:=least(ld_max_from_date, add_months(trunc(rec.FROM_DATE, 'YEAR'), 12)-1);
                    BEGIN
                        SELECT 'x' into lc_char1 FROM REP_INT_DUE_CALC3
                        WHERE FROM_DATE=ld_year_last_day;
                    EXCEPTION WHEN NO_DATA_FOUND THEN
                        INSERT INTO REP_INT_DUE_CALC3 (FROM_DATE, YEAR_DIV) VALUES (ld_year_last_day,'E');
                        COMMIT;
                    END;
                END IF;
            END LOOP;
            --промежуточные максимальная и минимальные границы расписания определены, сохраняем их в переменные
            SELECT min (FROM_DATE), max(FROM_DATE) into ld_min_FROM_DATE, ld_max_FROM_DATE FROM REP_INT_DUE_CALC3;
            --добавляем периоды измененения процентной ставки
            lv_current_step:='Add fill FROM_DATE rate change dates';
            INSERT INTO REP_INT_DUE_CALC3 (FROM_DATE/*, YEAR_DIV*/)
            SELECT distinct EFFECTIVE_DATE /*, 'R'*/ FROM fcc.CLTB_ACCOUNT_UDE_VALUES
            WHERE ACCOUNT_NUMBER = pi_loan_account
            AND EFFECTIVE_DATE >= ld_min_FROM_DATE -- мин. дата FROM_DATE
            AND EFFECTIVE_DATE <= ld_max_FROM_DATE -- макс. дата FROM_DATE
            AND UDE_ID = 'INTEREST_RATE'
            AND EFFECTIVE_DATE not in (SELECT FROM_DATE FROM REP_INT_DUE_CALC3);  --korn 20130322
            COMMIT;
            --добавляем даты планиреумых ЧДП, если они не совпадают с существующими
            lv_current_step:='Add fill FROM_DATE adv repay params';
            INSERT INTO REP_INT_DUE_CALC3 (FROM_DATE)
                 SELECT distinct params.paym_date FROM
                     (select pi_1paym_date paym_date, pi_1paym_sum paym_sum from dual
                        union all
                     select pi_2paym_date paym_date, pi_2paym_sum paym_sum from dual
                        union all
                     select pi_3paym_date paym_date, pi_3paym_sum paym_sum from dual
                        union all
                     select pi_4paym_date paym_date, pi_4paym_sum paym_sum from dual
                        union all
                     select pi_5paym_date paym_date, pi_5paym_sum paym_sum from dual) params
                     WHERE params.paym_date is not null
                     and nvl(params.paym_sum,0)>0
                     and params.paym_date<pi_payment_plan_date
                     and params.paym_date>=gv_branch_day
                     AND params.paym_date not in (SELECT FROM_DATE FROM REP_INT_DUE_CALC3);
      --добавляем дату транша
            INSERT INTO REP_INT_DUE_CALC3 (FROM_DATE)
                 select distinct VALUE_DATE VALUE_DATE from fcc.cltb_event_entries
                                WHERE ACCOUNT_NUMBER = pi_loan_account
                                AND EVENT_CODE = 'VAMI'
                                AND VALUE_DATE >(SELECT min(FROM_DATE) FROM REP_INT_DUE_CALC3)
                AND VALUE_DATE not in (SELECT FROM_DATE FROM REP_INT_DUE_CALC3);
            COMMIT;
            --пока не точно, но нужно скорее всего добавить дату текущего опердня в TO_DATE, ставим во FROM_DATE опердень+1
            --INSERT INTO REP_INT_DUE_CALC3 (FROM_DATE)
            --SELECT gv_branch_day+1 FROM DUAL
            --WHERE gv_branch_day+1 not in (SELECT FROM_DATE FROM REP_INT_DUE_CALC3);
            --COMMIT;
            --заполняем границы периодов
            lv_current_step:='Fill TO_DATE';
            update REP_INT_DUE_CALC3 c2
            set c2.to_date = nvl((select min(c1.from_date) from REP_INT_DUE_CALC3 c1 where c1.from_date > c2.from_date), null);
            COMMIT;
            update REP_INT_DUE_CALC3 c2
            set c2.to_date = pi_payment_plan_date
            where from_date = (select max(from_date) from REP_INT_DUE_CALC3);
            COMMIT;
      update REP_INT_DUE_CALC3
            set YEAR_DIV='B'
            where to_date in (select from_date from REP_INT_DUE_CALC3 where YEAR_DIV='E');
      COMMIT;
      /*update REP_INT_DUE_CALC3
            set YEAR_DIV='V'
            where from_date in (select to_date from REP_INT_DUE_CALC3 where YEAR_DIV='R');
      COMMIT;*/
            --заполняем суммы ЧДП
            lv_current_step:='Fill sum adv repay params';
            UPDATE REP_INT_DUE_CALC3 c2
            SET c2.adv_repayment = (SELECT max(params.paym_sum) FROM
                                             (select pi_1paym_date paym_date, pi_1paym_sum paym_sum from dual
                                                union all
                                             select pi_2paym_date paym_date, pi_2paym_sum paym_sum from dual
                                                union all
                                             select pi_3paym_date paym_date, pi_3paym_sum paym_sum from dual
                                                union all
                                             select pi_4paym_date paym_date, pi_4paym_sum paym_sum from dual
                                                union all
                                             select pi_5paym_date paym_date, pi_5paym_sum paym_sum from dual) params
                                             WHERE params.paym_date = c2.to_date);
            --окончательные максимальная и минимальные границы расписания определены, пересохраняем их в переменные
            SELECT min (FROM_DATE), max(FROM_DATE) into ld_min_FROM_DATE, ld_max_FROM_DATE FROM REP_INT_DUE_CALC3;
            --для начала проставим признак того, что в to_date должен быть платеж ОД
            update REP_INT_DUE_CALC3 c set
                    c.IS_PRINCIPAL_PAY = 'Y'
            WHERE EXISTS (
                SELECT 'X'
                 FROM fcc.cltb_account_schedules
                WHERE account_number = pi_loan_account
                AND component_name = 'PRINCIPAL'
                AND schedule_due_date=c.TO_DATE);
            COMMIT;
            --добавляем досрочно погашенные проценты
            lv_current_step:='Fill INT_PREPAID';
            FOR rec in (SELECT TO_DATE FROM REP_INT_DUE_CALC3 WHERE TO_DATE IS NOT NULL ORDER BY TO_DATE) LOOP
                for cur_var in (SELECT a.VALUE_DATE VALUE_DATE, sum(c.AMOUNT) INT_PREPAID
                                 FROM fcc.CLTB_LIQ a, fcc.CLTB_ACCOUNT_EVENTS_PROCESSED b, fcc.cltb_event_entries c
                                 WHERE a.ACCOUNT_NUMBER = b.ACCOUNT_NUMBER
                                 AND a.ACCOUNT_NUMBER = c.ACCOUNT_NUMBER
                                 AND b.COMPONENT_NAME = c.COMPONENT_NAME
                                 AND a.EVENT_SEQ_NO = b.EVENT_SEQ_NO
                                 AND a.EVENT_SEQ_NO = c.EVENT_SEQ_NO
                                 AND a.ACCOUNT_NUMBER = pi_loan_account
                                 AND a.INSTALLMENT_PAYMENT = 'N'
                                 AND a.VALUE_DATE >=rec.TO_DATE
                                 --досрочка только между платежами
                                 AND a.VALUE_DATE not in (select TO_DATE from REP_INT_DUE_CALC3 where IS_PRINCIPAL_PAY = 'Y')
                                 AND b.COMPONENT_NAME ='MAIN_INT'
                                 AND b.EXECUTION_STATUS = 'P'
                                 AND a.PAYMENT_STATUS = 'P'  --new
                                 AND c.AMOUNT_TAG = 'MAIN_INT_DLIQ'
                                 AND b.EVENT_CODE = 'MLIQ'
                                 group by a.VALUE_DATE
                                order by VALUE_DATE) loop
                    update REP_INT_DUE_CALC3 set INT_PREPAID = cur_var.INT_PREPAID where TO_DATE = cur_var.VALUE_DATE;
                end loop;
            END LOOP;
            COMMIT;
            --если кредит выдавался несколькими траншами, то заполняем их значения
            lv_current_step:='Fill TRANCHE';
            FOR rec in (SELECT TO_DATE, FROM_DATE FROM REP_INT_DUE_CALC3 WHERE FROM_DATE IS NOT NULL ORDER BY FROM_DATE) LOOP
                for cur_var in (select VALUE_DATE VALUE_DATE, sum(AMOUNT) TRANCHE from fcc.cltb_event_entries
                                WHERE ACCOUNT_NUMBER = pi_loan_account
                                AND EVENT_CODE = 'VAMI'
                                AND VALUE_DATE = rec.FROM_DATE --between rec.FROM_DATE and rec.TO_DATE
                                group by VALUE_DATE) loop
                    --update REP_INT_DUE_CALC3 set TRANCHE = cur_var.TRANCHE where FROM_DATE = rec.FROM_DATE; --korn20180522
          update REP_INT_DUE_CALC3 set TRANCHE = cur_var.TRANCHE where TO_DATE = rec.FROM_DATE;
                end loop;
            END LOOP;
            COMMIT;
            --debug
            --немного траншей для теста
            --UPDATE REP_INT_DUE_CALC3 s
            --SET s.tranche=100000
            --WHERE s.from_date=to_date('05.03.2014','DD.MM.RRRR');
            --commit;
            --end debug
            --заполняем периоды процентными ставками
            lv_current_step:='Fill RATE';
            FOR rec in (SELECT TO_DATE FROM REP_INT_DUE_CALC3 WHERE TO_DATE IS NOT NULL ORDER BY TO_DATE) LOOP
                for cur_var in (SELECT EFFECTIVE_DATE, UDE_VALUE RATE FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                WHERE ACCOUNT_NUMBER = pi_loan_account
                                --AND EFFECTIVE_DATE<=rec.TO_DATE
                AND EFFECTIVE_DATE<rec.TO_DATE --korn20180416
                                AND UDE_ID = 'INTEREST_RATE'
                                order by EFFECTIVE_DATE) loop
                    update REP_INT_DUE_CALC3 set INT_RATE = cur_var.RATE where TO_DATE = rec.TO_DATE;
                end loop;
            END LOOP;
            COMMIT;
            --заполняем количество оставшихся платежей для всех периодов, пригодится для аннуитета
            update REP_INT_DUE_CALC3 с1
            set с1.EXP_PAY_CNT= (SELECT count(*)
                                FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
                                WHERE c.ACCOUNT_NUMBER  = pi_loan_account
                                AND c.COMPONENT_NAME = 'MAIN_INT'
                                AND c.schedule_due_date > с1.TO_DATE);
            --20140411 новая доработка для вычитания последнего платежа
            --получаем DUE_DATES_ON
            BEGIN
                select due_dates_on into ln_due_dates_on from CLTB_ACCOUNT_COMP_SCH s
                 where ACCOUNT_NUMBER = pi_loan_account
                 and component_name = 'MAIN_INT'
                 and sch_end_date in (select to_date from REP_INT_DUE_CALC3
                                    where EXP_PAY_CNT=1); --предпоследний платеж
            EXCEPTION when no_data_found THEN
                ln_due_dates_on:=null;
            END;
            SELECT  nvl(ln_due_dates_on, extract(DAY from value_date)),
                    extract(DAY from ORIGINAL_ST_DATE),
                    maturity_date
            INTO ln_due_dates_on, ln_orig_st_date, ld_maturity_date
            FROM CLTB_ACCOUNT_MASTER
            WHERE ACCOUNT_NUMBER = pi_loan_account;
--            SELECT count(*) INTO ln_near28_maturity_date
--                                FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
--                                WHERE c.ACCOUNT_NUMBER  = pi_loan_account
--                                AND c.COMPONENT_NAME = 'MAIN_INT'
--                                AND c.schedule_due_date >=ld_maturity_date-28
--                                AND c.schedule_due_date < ld_maturity_date;
            SELECT COUNT(DISTINCT pay_month) INTO ln_last2_pay_month
                FROM
                (SELECT trunc(max(c.schedule_due_date),'month') pay_month
                                    FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
                                    WHERE c.ACCOUNT_NUMBER  = pi_loan_account
                                    AND c.COMPONENT_NAME = 'MAIN_INT'
                                    AND c.schedule_due_date < ld_maturity_date
                UNION ALL
                SELECT trunc(ld_maturity_date, 'month') pay_month FROM dual);
            -- PRB22107 06.05.20 Вычитание последнего платежа только для случая, когда 2 последних платежа попадают на один месяц
            if ln_last2_pay_month=1 then ln_minus_paym:=1;
            else ln_minus_paym:=0;
            end if;
            --Если  DD в поле Original St. Date <= значения Due Dates On (по каким дням платить), и 2 последних платежа попадают на 1 месяц, то не учитываем последний платеж, если 2 последних платежа не попадают в 1 месяц, то платеж Maturity Date, учитывается при подсчете числа предстоящих платежей
            --Если  DD в поле Original St. Date > значения Due Dates On (по каким дням платить) и 2 последних платежа попадают на 1 месяц, то не учитываем последний платеж, если 2 последних платежа не попадают в 1 месяц, то:
                         --Если в течении 28 дней до даты Maturity Date, есть платеж, то платеж Maturity Date не учитывается при подсчете числа предстоящих платежей
                         --Если в течении 28 дней до даты Maturity Date, нет платежей, то платеж Maturity Date учитывается при подсчете числа предстоящих платежей
--            if ln_orig_st_date<=ln_due_dates_on then
--                if ln_last2_pay_month=1 then ln_minus_paym:=1;
--                else ln_minus_paym:=0;
--                end if;
--            elsif ln_orig_st_date>ln_due_dates_on then
--                if ln_last2_pay_month=1 then ln_minus_paym:=1;
--                else
--                    if ln_near28_maturity_date>0 then  ln_minus_paym:=1;
--                    else ln_minus_paym:=0;
--                    end if;
--                end if;
--            else  ln_minus_paym:=0;
--            end if;
      BEGIN
        select due_dates_on into ln_due_dates_on_rep from
        (select due_dates_on from CLTB_ACCOUNT_COMP_SCH s
                 where ACCOUNT_NUMBER = pi_loan_account
                 and component_name = 'MAIN_INT'
         and due_dates_on is not null
         order by sch_end_date desc)
        WHERE rownum=1;
            EXCEPTION when no_data_found THEN
                ln_due_dates_on_rep:=ln_due_dates_on;
            END;
      --ln_minus_paym:=0; --korn20171030
            --end 20140411
            --немного прервемся на расчет просроченной задолженности
            lv_current_step:='Fill overdue info';
            ln_principal_overdue:=0;
            ln_interest_overdue:=0;
            ln_int_on_ovd_p_accrued:=0;
            ln_penalty_p:=0;
            ln_penalty_i:=0;
            IF pi_ovd_close_date IS NOT NULL THEN
                SELECT   NVL (
                             SUM(CASE
                                     WHEN (component_name = 'PRINCIPAL'
                                           AND schedule_due_date < pi_ovd_close_date) --до даты планового погашения просрочки
                                     THEN
                                         amount_due - NVL (amount_settled, 0)
                                     ELSE
                                         0
                                 END),
                             0)
                             principal_overdue INTO ln_principal_overdue
                  FROM   fcc.cltb_account_schedules
                 WHERE   account_number = pi_loan_account;
                 ---------------------------------
                SELECT   NVL (
                             SUM(CASE
                                     WHEN (component_name = 'MAIN_INT'
                                           AND schedule_due_date < pi_ovd_close_date) --до даты планового погашения просрочки
                                     THEN
                                         NVL (accrued_amount, 0) - NVL (amount_settled, 0)
                                     ELSE
                                         0
                                 END),
                             0)
                             interest_overdue  INTO ln_interest_overdue
                  FROM   fcc.cltb_account_schedules
                 WHERE   account_number = pi_loan_account;
                  ---------------------------------
                SELECT   NVL (
                             SUM(CASE
                                     WHEN (component_name = 'INT_ON_OVD_P'
                                           AND schedule_due_date >= gv_branch_day) --после текущего опер дня
                                     THEN
                                         NVL (amount_due, 0) - NVL (amount_settled, 0)
                                     ELSE
                                         0
                                 END),
                             0)
                             int_on_ovd_p_accrued INTO ln_int_on_ovd_p_accrued
                  FROM   fcc.cltb_account_schedules
                 WHERE   account_number = pi_loan_account;
                  ---------------------------------
                SELECT   NVL (
                             SUM(CASE
                                     WHEN (component_name = 'PENALTY_P'
                                           AND schedule_due_date <= pi_ovd_close_date) --до даты планового погашения просрочки
                                     THEN
                                         NVL (amount_due, 0) - NVL (amount_settled, 0)
                                     ELSE
                                         0
                                 END),
                             0)
                             penalty_p INTO ln_penalty_p
                  FROM   fcc.cltb_account_schedules
                 WHERE   account_number = pi_loan_account;
                  ---------------------------------
                SELECT   NVL (
                             SUM(CASE
                                     WHEN (component_name = 'PENALTY_I'
                                           AND schedule_due_date <= pi_ovd_close_date)
                                     THEN
                                         NVL (amount_due, 0) - NVL (amount_settled, 0)
                                     ELSE
                                         0
                                 END),
                             0)
                             penalty_i INTO ln_penalty_i
                  FROM   fcc.cltb_account_schedules
                 WHERE   account_number = pi_loan_account;
                END IF;
            --Получаем ставки по кторым считаются штрафы
            BEGIN
                SELECT nvl(UDE_VALUE,0) RATE INTO ln_INT_OVD_RATE FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                         WHERE ACCOUNT_NUMBER = pi_loan_account
                                          AND EFFECTIVE_DATE=(SELECT max(EFFECTIVE_DATE) FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                                               WHERE ACCOUNT_NUMBER = pi_loan_account
                                                               AND EFFECTIVE_DATE<=pi_ovd_close_date
                                                               AND UDE_ID = 'INT_OVD_RATE')
                                         AND UDE_ID = 'INT_OVD_RATE';
            EXCEPTION WHEN NO_DATA_FOUND THEN
                ln_INT_OVD_RATE:=0;
            END;
            BEGIN
                SELECT nvl(UDE_VALUE,0) RATE INTO ln_PENALTY_RATE FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                         WHERE ACCOUNT_NUMBER = pi_loan_account
                                          AND EFFECTIVE_DATE=(SELECT max(EFFECTIVE_DATE) FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                                               WHERE ACCOUNT_NUMBER = pi_loan_account
                                                               AND EFFECTIVE_DATE<=pi_ovd_close_date
                                                               AND UDE_ID = 'PENALTY_RATE')
                                         AND UDE_ID = 'PENALTY_RATE';
            EXCEPTION WHEN NO_DATA_FOUND THEN
                ln_PENALTY_RATE:=0;
            END;
            --посчитали просрочку для вывода в отчет
            go_PRINCIPAL_OVERDUE:=nvl(ln_principal_overdue,0);
            go_INTEREST_OVERDUE:=nvl(ln_interest_overdue,0);
      --Leila K. Izmailova - 28.09.2017 13:56
      SELECT  count(*) into ln_row_cnt FROM fcc.cltb_account_schedules
      WHERE   account_number = pi_loan_account
      AND component_name='INT_ON_OVD_P';
      if ln_row_cnt=0 then
        go_INT_ON_OVD_P_ACCRUED:=null;
      else
        go_INT_ON_OVD_P_ACCRUED:=round(nvl(ln_int_on_ovd_p_accrued,0)+nvl(ln_principal_overdue,0)*(ln_INT_OVD_RATE/(100*366))*(pi_ovd_close_date-gv_branch_day),2); -- Changed to 366 Polishchuk NA INC000635178
      end if;
      ----------------------
      SELECT  count(*) into ln_row_cnt FROM fcc.cltb_account_schedules
      WHERE   account_number = pi_loan_account
      AND component_name='PENALTY_P';
            if ln_row_cnt=0 then
        go_PENALTY_P:=null;
      else
        go_PENALTY_P:=round(nvl(ln_penalty_p,0)+nvl(ln_principal_overdue,0)*(ln_PENALTY_RATE/100)*(pi_ovd_close_date-gv_branch_day),2);
      end if;
      ----------------------
      SELECT  count(*) into ln_row_cnt FROM fcc.cltb_account_schedules
      WHERE   account_number = pi_loan_account
      AND component_name='PENALTY_I';
            if ln_row_cnt=0 then
        go_PENALTY_I:=null;
      else
        go_PENALTY_I:=round(nvl(ln_penalty_i,0)+nvl(ln_interest_overdue,0)*(ln_PENALTY_RATE/100)*(pi_ovd_close_date-gv_branch_day),2);
      end if;
      --END Leila K. Izmailova - 28.09.2017 13:56

            --и забыли о ней до вывода)
            --самое сложное)
            --вычисляем минимальную дату ЧДП
            lv_current_step:='Fill PRINCIPAL before AVD_REP';
            select min(TO_DATE), max(TO_DATE) into gd_min_adv_rep_to_date, gd_max_adv_rep_to_date from REP_INT_DUE_CALC3
            where ADV_REPAYMENT>0;
            --Для начала считаем платежи ОД для всех дат до первого ЧДП
            lv_current_step:='Fill PRINCIPAL';
            FOR rec in (SELECT a.TO_DATE FROM REP_INT_DUE_CALC3 a
                        WHERE a.TO_DATE IS NOT NULL
                        AND a.TO_DATE<=gd_min_adv_rep_to_date--gv_branch_day
                        ORDER BY a.TO_DATE) LOOP
                    --досрочка
                    for cur_var in (SELECT a.VALUE_DATE VALUE_DATE, sum(c.AMOUNT) PRINCIPAL
                                    FROM fcc.CLTB_LIQ a, fcc.CLTB_ACCOUNT_EVENTS_PROCESSED b, fcc.cltb_event_entries c
                                    WHERE a.ACCOUNT_NUMBER = b.ACCOUNT_NUMBER
                                    AND a.ACCOUNT_NUMBER = c.ACCOUNT_NUMBER
                                    AND b.COMPONENT_NAME = c.COMPONENT_NAME
                                    AND a.EVENT_SEQ_NO = b.EVENT_SEQ_NO
                                    AND a.EVENT_SEQ_NO = c.EVENT_SEQ_NO
                                    AND a.ACCOUNT_NUMBER = pi_loan_account
                                    --AND a. INSTALLMENT_PAYMENT = 'N'
                                    AND a. VALUE_DATE >= rec.TO_DATE
                                    AND b.COMPONENT_NAME ='PRINCIPAL'
                                    AND b.EXECUTION_STATUS = 'P'
                                    AND a.PAYMENT_STATUS = 'P'  --new
                                    AND c.AMOUNT_TAG = 'PRINCIPAL_DLIQ'
                                    --AND b.EVENT_CODE = 'MLIQ'
                                    group by a.VALUE_DATE --korn20130606
                                    order by VALUE_DATE) loop
                            update REP_INT_DUE_CALC3 set PRINCIPAL = cur_var.PRINCIPAL where TO_DATE = cur_var.VALUE_DATE; --korn20180522
              --update REP_INT_DUE_CALC3 set PRINCIPAL = cur_var.PRINCIPAL where FROM_DATE = cur_var.VALUE_DATE;
                    end loop;
            END LOOP;
            COMMIT;
            commit;
            --считаем аннуитет пока не начались ЧДП
            lv_current_step:='Fill EMI_AMOUNT before AVD_REP';
            FOR rec in (SELECT TO_DATE FROM REP_INT_DUE_CALC3
                        WHERE TO_DATE<=gd_min_adv_rep_to_date --потом руками считаем
                        ORDER BY TO_DATE) LOOP
                    for cur_var in (SELECT a.SCHEDULE_DUE_DATE, a.EMI_AMOUNT
                                        FROM fcc.CLTB_ACCOUNT_SCHEDULES a
                                        WHERE a.ACCOUNT_NUMBER  = pi_loan_account
                                        AND a.SCHEDULE_DUE_DATE >= rec.TO_DATE
                                        AND a.SCHEDULE_DUE_DATE <= pi_payment_plan_date
                                        AND a.COMPONENT_NAME = 'MAIN_INT'
                                    order by a.SCHEDULE_DUE_DATE) loop
                        update REP_INT_DUE_CALC3 set EMI_AMOUNT = cur_var.EMI_AMOUNT
                        where TO_DATE = cur_var.SCHEDULE_DUE_DATE;
                    end loop;
            END LOOP;
            COMMIT;
            --посчитаем минимальную TO_DATE
            SELECT min (TO_DATE), max(TO_DATE) into ld_min_TO_DATE, ld_max_TO_DATE FROM REP_INT_DUE_CALC3;
            --потом считаем сумму ОД на дату первого ЧДП
            lv_current_step:='Fill first PRPL_EXPECTED';
            UPDATE REP_INT_DUE_CALC3 s
            SET s.prpl_expected =
              (SELECT NVL
                         (SUM
                             (CASE
                                 WHEN (    component_name = 'PRINCIPAL'
                                       AND schedule_due_date >=gd_min_adv_rep_to_date
                                      )
                                    THEN amount_due - NVL (amount_settled, 0)
                                 ELSE 0
                              END
                             ),
                          0
                         ) prpl_expected
                 FROM fcc.cltb_account_schedules
                WHERE account_number = pi_loan_account)
            WHERE s.to_date= gd_min_adv_rep_to_date;
            COMMIT;
            --предупреждение о сумме ЧДП
            --сумма всех ЧДП
            SELECT sum(params.paym_sum) INTO ln_all_adv_repay_sum FROM
               (select pi_1paym_date paym_date, pi_1paym_sum paym_sum from dual
                union all
                select pi_2paym_date paym_date, pi_2paym_sum paym_sum from dual
                union all
                select pi_3paym_date paym_date, pi_3paym_sum paym_sum from dual
                union all
                select pi_4paym_date paym_date, pi_4paym_sum paym_sum from dual
                union all
                select pi_5paym_date paym_date, pi_5paym_sum paym_sum from dual) params;
            --ОД на дату первого ЧДП
            SELECT NVL
                         (SUM
                             (CASE
                                 WHEN (    component_name = 'PRINCIPAL'
                                       AND schedule_due_date >=gd_min_adv_rep_to_date
                                      )
                                    THEN amount_due - NVL (amount_settled, 0)
                                 ELSE 0
                              END
                             ),
                          0
                         ) prpl_expected INTO ln_prpl_expected_on_first_adv
                 FROM fcc.cltb_account_schedules
                WHERE account_number = pi_loan_account;
            IF nvl(ln_all_adv_repay_sum,0)>nvl(ln_prpl_expected_on_first_adv,0) THEN
               UPDATE rep_int_due_calc_totals3
               SET check_message='Суммы ЧДП ('||to_char(ln_all_adv_repay_sum)||') превышают остаток основной задолженности ('||ln_prpl_expected_on_first_adv||'). Повторите расчет с другими параметрами'
               WHERE check_message is not null;
               COMMIT;
            END IF;
            --для начала проставим признак того, что в to_date должен быть платеж ОД
            /*
            --перенес повыше
            update REP_INT_DUE_CALC3 c set
                    c.IS_PRINCIPAL_PAY = 'Y'
            WHERE EXISTS (
                SELECT 'X'
                 FROM fcc.cltb_account_schedules
                WHERE account_number = pi_loan_account
                AND component_name = 'PRINCIPAL'
                AND schedule_due_date=c.TO_DATE);
            COMMIT;*/
            --ВВЕРХ
            --от первого ЧДП двигаемся вверх
            FOR rec in (SELECT a.FROM_DATE, a.TO_DATE, a.PRINCIPAL,  a.INT_RATE, a.PRPL_EXPECTED, a.EXP_PAY_CNT, a.ADV_REPAYMENT  FROM REP_INT_DUE_CALC3 a
                        WHERE a.TO_DATE<=gd_min_adv_rep_to_date
                        ORDER BY a.TO_DATE desc) LOOP
                        --ставим проценты, которые должны быть в платеже, чтобы потом узнать ОД
                        update REP_INT_DUE_CALC3 set
                        INT_DUE = nvl((SELECT sum(nvl(amount_due,0))
                                        FROM fcc.CLTB_ACCOUNT_SCHEDULES a
                                        WHERE a.ACCOUNT_NUMBER  = pi_loan_account
                                        AND a.SCHEDULE_DUE_DATE = rec.TO_DATE
                                        AND a.COMPONENT_NAME = 'MAIN_INT'),0)
                        where TO_DATE = rec.TO_DATE
                        AND IS_PRINCIPAL_PAY='Y';
                        commit;
                        --ставим платеж ОД
                        update REP_INT_DUE_CALC3 set
                        PRINCIPAL = /*nvl(PRINCIPAL,0)+*/nvl(EMI_AMOUNT,0)-nvl(INT_DUE,0)
                        where TO_DATE = rec.TO_DATE
                        AND IS_PRINCIPAL_PAY='Y'
                        AND PRINCIPAL is null;
                        commit;
            END LOOP;
            --еще разок вверх для расчета ОД
            FOR rec in (SELECT a.FROM_DATE, a.TO_DATE, a.PRINCIPAL,  a.INT_RATE, a.PRPL_EXPECTED, a.EXP_PAY_CNT, a.ADV_REPAYMENT, a.TRANCHE  FROM REP_INT_DUE_CALC3 a
                        WHERE a.TO_DATE<=gd_min_adv_rep_to_date
                        ORDER BY a.TO_DATE desc) LOOP
                        --ставим расчетное значение ОД
                        update REP_INT_DUE_CALC3 set
                        PRPL_EXPECTED = nvl((SELECT c.PRPL_EXPECTED FROM REP_INT_DUE_CALC3 c
                                                WHERE FROM_DATE <> rec.TO_DATE
                                                AND TO_DATE = rec.TO_DATE),0)
                                        +nvl(PRINCIPAL,0) -nvl(TRANCHE,0)
                        where TO_DATE = rec.FROM_DATE;
                        commit;
                    --считаем  начисленные проценты
                        select add_months(trunc(rec.FROM_DATE+1, 'YEAR'), 12) - trunc(rec.FROM_DATE+1, 'YEAR') INTO ln_curr_year_days_cnt from dual;
                        IF ln_curr_year_days_cnt=365 THEN ln_divisor:=36500;
                        ELSE  ln_divisor:=36600;
                        END IF;
                        --update REP_INT_DUE_CALC3 set ACCR_INT = ROUND(PRPL_EXPECTED*INT_RATE*(TO_DATE-FROM_DATE)/ln_divisor,2) where FROM_DATE = rec.FROM_DATE;
            --korn20180215
            update REP_INT_DUE_CALC3 set ACCR_INT = PRPL_EXPECTED*INT_RATE*(TO_DATE-FROM_DATE)/ln_divisor where FROM_DATE = rec.FROM_DATE;
                        COMMIT;
            END LOOP;
            --ВНИЗ
            ln_prev_INT_EXPECTED:=0;
            ln_curr_INT_EXPECTED:=0;
            --до первого ЧДП считаем отложенные проценты
            FOR rec in (SELECT a.FROM_DATE,
                               a.TO_DATE,
                               a.PRINCIPAL,
                               a.INT_RATE,
                               a.PRPL_EXPECTED,
                               a.EXP_PAY_CNT,
                               a.ADV_REPAYMENT,
                               a.EMI_AMOUNT,
                               a.ACCR_INT,
                               a.INT_PREPAID  FROM REP_INT_DUE_CALC3 a
                        WHERE a.TO_DATE<=gd_min_adv_rep_to_date
                        ORDER BY a.TO_DATE) LOOP
                    --считаем отложенные проценты
                        --текущее значение=предыдущее значение+начиленные за период-аннуитет
                        ln_curr_INT_EXPECTED:=round(ln_prev_INT_EXPECTED+nvl(rec.ACCR_INT,0)-nvl(rec.EMI_AMOUNT,0)-nvl(rec.INT_PREPAID,0),2);
                        --если начислено больше чем аннуитет
                        IF ln_curr_INT_EXPECTED>0 THEN
                        --проценты равны аннуитету
                            ln_INT_DUE:=rec.EMI_AMOUNT;
                        ELSE
                        --проценты равны отложенным+начисленным-досрочно погашенным
                            ln_INT_DUE:=ln_prev_INT_EXPECTED+nvl(rec.ACCR_INT,0)-nvl(rec.INT_PREPAID,0);
                        END IF;
                        update REP_INT_DUE_CALC3 set INT_EXPECTED=case when ln_curr_INT_EXPECTED<0 then 0 else ln_curr_INT_EXPECTED end
                        WHERE FROM_DATE=rec.FROM_DATE;
            --TESTKOP2
                        update REP_INT_DUE_CALC3 set INT_DUE=round(ln_INT_DUE,2) --korn20180215 round
            --update REP_INT_DUE_CALC3 set INT_DUE=ln_INT_DUE
                        WHERE FROM_DATE=rec.FROM_DATE;
                        --если отложенные проценты больше нуля, запоминаем их для следущего шага
                        IF ln_curr_INT_EXPECTED>0 THEN
                            ln_prev_INT_EXPECTED:=ln_curr_INT_EXPECTED;
                        ELSE
                            ln_prev_INT_EXPECTED:=0;
                        END IF;
            END LOOP;
            COMMIT;
            --считаем ЧДП, которые клиент уже сделал
            --ЧДП сделанные "задним числом"
            SELECT
                nvl((SELECT SUM(nvl(AMOUNT_PAID,0))
                  FROM fcc.CLTB_AMOUNT_PAID A
                 WHERE branch_code = gv_branch_code
                   AND ACCOUNT_NUMBER = pi_loan_account
                   AND COMPONENT_NAME = 'PRINCIPAL' AND PAID_STATUS = 'P'
                   AND paid_date <=gd_min_adv_rep_to_date
                   AND EXISTS
                 (SELECT 1
                          FROM fcc.cltb_liq B
                         WHERE branch_code = A.BRANCH_CODE
                           AND account_number = A.ACCOUNT_NUMBER
                           AND EVENT_SEQ_NO = A.EVENT_SEQ_NO
                           AND execution_date = gv_branch_day
                           AND payment_status = 'P'
                           AND auth_stat = 'A')),0)
            --ЧДП сделанные обычным способом до опердня
                 +nvl((select sum(nvl(chpd.chdp_amount,0)-nvl(princ.princ_amount,0)) chdp_amount_cleared
            from
               (SELECT a.VALUE_DATE, sum(nvl(c.AMOUNT,0)) chdp_amount
              FROM fcc.CLTB_LIQ a, fcc.CLTB_ACCOUNT_EVENTS_PROCESSED b, fcc.cltb_event_entries c
              WHERE a.ACCOUNT_NUMBER = b.ACCOUNT_NUMBER
              AND a.ACCOUNT_NUMBER = c.ACCOUNT_NUMBER
              AND a.EVENT_SEQ_NO = b.EVENT_SEQ_NO
              AND a.EVENT_SEQ_NO = c.EVENT_SEQ_NO
              AND a.ACCOUNT_NUMBER = pi_loan_account
              AND a.INSTALLMENT_PAYMENT = 'N'
              AND b.COMPONENT_NAME = 'PRINCIPAL'
              AND b.EXECUTION_STATUS = 'P'
              AND a.PAYMENT_STATUS = 'P'
              AND b.EVENT_CODE = 'MLIQ'
              AND c.AMOUNT_TAG = 'PRINCIPAL_DLIQ'
              AND a.VALUE_DATE <gv_branch_day
              GROUP BY a.VALUE_DATE) chpd
            left join
              (SELECT schedule_due_date VALUE_DATE, sum(nvl(amount_settled,0)) princ_amount
                FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
              WHERE c.ACCOUNT_NUMBER  = pi_loan_account
              AND c.COMPONENT_NAME = 'PRINCIPAL'
              group by schedule_due_date) princ
            on chpd.VALUE_DATE=princ.VALUE_DATE)
        ,0)
            INTO ln_sum_hist_ADV_REPAYMENT
            FROM DUAL;
            --двигаемся вниз по расписанию и формируем
            --ln_prev_INT_EXPECTED:=0; --korn20140313
            BEGIN
                SELECT INT_EXPECTED INTO ln_prev_INT_EXPECTED
                FROM
                (SELECT a.INT_EXPECTED  FROM REP_INT_DUE_CALC3 a
                            WHERE a.TO_DATE<gd_min_adv_rep_to_date
                            ORDER BY a.TO_DATE desc) b
                WHERE ROWNUM=1;
            EXCEPTION WHEN NO_DATA_FOUND THEN
                ln_prev_INT_EXPECTED:=0;
            END;
            ln_curr_INT_EXPECTED:=0;
      ---korn20171215
      if gn_is_buy_back>0 then
          begin
            select SUM_LAST_PAY into ln_CALC_last_paym_sum from SIEBEL.SX_O@SBLREP.IMB.RU
             where CREDIT_NUM= pi_loan_account;
          exception when no_data_found then
            select amount_due into ln_CALC_last_paym_sum from
            (SELECT amount_due
            FROM fcc.cltb_account_schedules
            WHERE account_number = pi_loan_account
            and component_name = 'PRINCIPAL'
            order by schedule_st_date desc)
          where rownum=1;
        end;
      end if;
      --end korn20171215
            FOR rec in (SELECT a.FROM_DATE,
                               a.TO_DATE,
                               a.PRINCIPAL,
                               a.INT_RATE,
                               a.PRPL_EXPECTED,
                               a.EXP_PAY_CNT,
                               a.ADV_REPAYMENT,
                               a.IS_PRINCIPAL_PAY,
                               a.INT_EXPECTED  FROM REP_INT_DUE_CALC3 a
                        WHERE a.TO_DATE>=gd_min_adv_rep_to_date
                        ORDER BY a.TO_DATE) LOOP
            --считаем остаток ОД
            --считаем  начисленные проценты
                        select add_months(trunc(rec.FROM_DATE+1, 'YEAR'), 12) - trunc(rec.FROM_DATE+1, 'YEAR') INTO ln_curr_year_days_cnt from dual;
                        IF ln_curr_year_days_cnt=365 THEN ln_divisor:=36500;
                        ELSE  ln_divisor:=36600;
                        END IF;
                        --update REP_INT_DUE_CALC3 set ACCR_INT = ROUND(PRPL_EXPECTED*INT_RATE*(TO_DATE-FROM_DATE)/ln_divisor,2)
            --korn20180215
            update REP_INT_DUE_CALC3 set ACCR_INT = PRPL_EXPECTED*INT_RATE*(TO_DATE-FROM_DATE)/ln_divisor
                        where FROM_DATE = rec.FROM_DATE;
                        COMMIT;
           --считаем аннуитет
                    --DBMS_OUTPUT.Put_Line(to_char(rec.ADV_REPAYMENT));
               /*     if rec.ADV_REPAYMENT>0 then
                      update REP_INT_DUE_CALC3 set EMI_AMOUNT = (SELECT calc_emi (gn_is_buy_back,
                                                                                  c.PRPL_EXPECTED-rec.ADV_REPAYMENT-nvl(rec.PRINCIPAL,0), --korn20140313
                                                                                  c.INT_RATE,
                                                                                  pi_last_paym_sum,
                                                                                  c.EXP_PAY_CNT,
                                                                                  nvl((SELECT SUM(nvl(ADV_REPAYMENT,0)) FROM REP_INT_DUE_CALC3
                                                                                  WHERE TO_DATE <= rec.TO_DATE),0)
                                                                                )
                                                                  FROM REP_INT_DUE_CALC3 c
                                                                  WHERE FROM_DATE <> rec.TO_DATE
                                                                  AND TO_DATE = rec.TO_DATE)

                      where FROM_DATE = rec.TO_DATE;
                      commit;
                    end if;*/
           --считаем проценты, которые нужно погасить к платежу
                    update REP_INT_DUE_CALC3 set
                    INT_DUE = --если не было ЧДП
          case when TO_DATE<gd_min_adv_rep_to_date or is_principal_pay='Y' then EMI_AMOUNT-PRINCIPAL--+nvl(ADV_REPAYMENT,0) --korn20180511
                    --case when TO_DATE<gd_min_adv_rep_to_date then EMI_AMOUNT-PRINCIPAL
                    --если были, то сумма начисленных процентов с предыдущего платежа
          --TESTKOP
                    /*else (SELECT round(sum(ACCR_INT),2) FROM REP_INT_DUE_CALC3 c1 --korn20180215 round
                          WHERE c1.TO_DATE<=rec.TO_DATE
                          AND c1.TO_DATE>(SELECT max(c2.TO_DATE) FROM REP_INT_DUE_CALC3 c2
                                         WHERE PRINCIPAL>0
                                         AND c2.TO_DATE<rec.TO_DATE))*/
            else (SELECT round(sum(ACCR_INT),2) FROM REP_INT_DUE_CALC3 c1 --korn20180215 round
                          WHERE c1.TO_DATE<=rec.TO_DATE
                          AND c1.TO_DATE>=(SELECT min(c2.TO_DATE) FROM REP_INT_DUE_CALC3 c2
                                         WHERE IS_PRINCIPAL_PAY is null
                                         AND c2.TO_DATE<rec.TO_DATE))
                    end
                    where TO_DATE = rec.TO_DATE
                    AND PRINCIPAL>0
          --TESTKOP
                    --AND INT_DUE is null
          ;
                    commit;
             --считаем отложенные проценты
                    --текущее значение=предыдущее значение+начиленные за период-аннуитет+отложенная часть посчитанная до этого
                    SELECT ln_prev_INT_EXPECTED
                           /*+case when c1.TO_DATE=gd_min_adv_rep_to_date then 0 else nvl(ACCR_INT,0) end --для даты первого ЧДП проценты уже учтены в отложенных
                           -case when c1.TO_DATE=gd_min_adv_rep_to_date then 0 else decode(is_principal_pay,'Y',nvl(EMI_AMOUNT,0),0) end --для даты первого ЧДП аннуитет уже учтен в отложенных
                           */ --korn20140313
                           +nvl(ACCR_INT,0)-decode(is_principal_pay,'Y',nvl(EMI_AMOUNT,0),0) --отличаем реальные платежи от перерасчета аннуитета
                           --+nvl(INT_EXPECTED,0)--korn20140313
                           ,
                           decode(is_principal_pay,'Y',nvl(EMI_AMOUNT,0),0),
                           nvl(ACCR_INT,0)
                    INTO ln_curr_INT_EXPECTED,
                         ln_curr_EMI_AMOUNT,
                         ln_curr_ACCR_INT
                    FROM REP_INT_DUE_CALC3 c1
                    WHERE c1.TO_DATE=rec.TO_DATE;
                    --DBMS_OUTPUT.Put_Line('rec.TO_DATE='||to_char(rec.TO_DATE));
                    --DBMS_OUTPUT.Put_Line('ln_curr_INT_EXPECTED='||to_char(ln_curr_INT_EXPECTED));
                    --DBMS_OUTPUT.Put_Line('ln_curr_EMI_AMOUNT='||to_char(ln_curr_EMI_AMOUNT));
                    --DBMS_OUTPUT.Put_Line('ln_curr_ACCR_INT='||to_char(ln_curr_ACCR_INT));
                    --если начислено больше чем аннуитет
                    IF ln_curr_INT_EXPECTED>0 THEN
                       --проценты равны аннуитету
                            ln_INT_DUE:=ln_curr_EMI_AMOUNT;
                    ELSE
                        --проценты равны отложенным+начисленным
                            ln_INT_DUE:=ln_prev_INT_EXPECTED+ln_curr_ACCR_INT;
                    END IF;
                    update REP_INT_DUE_CALC3 set INT_EXPECTED=round(case when ln_curr_INT_EXPECTED<0 then 0 else ln_curr_INT_EXPECTED end,2)
                    WHERE FROM_DATE=rec.FROM_DATE;
          --TESTKOP
                    update REP_INT_DUE_CALC3 set INT_DUE=round(ln_INT_DUE,2)
          WHERE FROM_DATE=rec.FROM_DATE
          AND TO_DATE>gd_min_adv_rep_to_date; --korn20180215 round
                    --если отложенные проценты больше нуля, запоминаем их для следущего шага
                    IF ln_curr_INT_EXPECTED>0 THEN
                        ln_prev_INT_EXPECTED:=ln_curr_INT_EXPECTED;
                    ELSE
                        ln_prev_INT_EXPECTED:=0;
                    END IF;
            --ставим расчетное значение платежа ОД
                    update REP_INT_DUE_CALC3 set
                    PRINCIPAL = nvl(EMI_AMOUNT,0)-nvl(INT_DUE,0)--,
                    --PRPL_EXPECTED = PRPL_EXPECTED-PRINCIPAL+nvl(EMI_AMOUNT,0)-nvl(INT_DUE,0)
                    where TO_DATE = rec.TO_DATE
                    and nvl(INT_DUE,0)>0;
                    commit;
             --следущий ОД=предыдущий ОД-предыдущий платеж ОД+транш
                    update REP_INT_DUE_CALC3 set PRPL_EXPECTED = nvl((SELECT SUM (PRPL_EXPECTED)-SUM(nvl(PRINCIPAL,0))-SUM(nvl(ADV_REPAYMENT,0)) FROM REP_INT_DUE_CALC3 WHERE FROM_DATE <> rec.TO_DATE AND TO_DATE = rec.TO_DATE),0)
                                                                  +nvl(TRANCHE,0)
                    where FROM_DATE = rec.TO_DATE;
                    COMMIT;
             --еще раз пересчитываем следущий аннуитет
             --korn20130318
          -- 2 платежа в последний месяц должны объединяться не зависимо от вида кредита СЗ № 201/227 REQ000367527
          --if gn_is_buy_back>0 then ln_minus_paym:=0; end if;
          if rec.ADV_REPAYMENT>0 or rec.IS_PRINCIPAL_PAY='Y' then
          --считаем только до даты последнего ЧДП включительно
            if rec.TO_DATE<=gd_max_adv_rep_to_date then
              --DBMS_OUTPUT.Put_Line('ln_minus_paym='||to_char(ln_minus_paym));
              update REP_INT_DUE_CALC3 c1 set EMI_AMOUNT = (SELECT calc_emi2 (gn_is_buy_back,
                                                          --case when gn_is_buy_back>0 and rec.IS_PRINCIPAL_PAY='Y' then c1.PRPL_EXPECTED+nvl(rec.ADV_REPAYMENT,0) else c1.PRPL_EXPECTED end,---rec.ADV_REPAYMENT-nvl(c.PRINCIPAL,0), --korn20140313
                                                                             case when nvl(pi_principal_amt,0)-nvl(pi_1paym_sum,0)>0 then
                                                                                case when gn_is_buy_back>0
                                                                                then nvl(pi_principal_amt,0)
                                                                                else nvl(pi_principal_amt,0)-nvl(pi_1paym_sum,0)
                                                                                end
                                                                             else
                                                                               case when gn_is_buy_back>0
                                                                               then c1.PRPL_EXPECTED+nvl(rec.ADV_REPAYMENT,0)
                                                                               else c1.PRPL_EXPECTED end
                                                                             end, --korn20180813 -- PRPL_EXPECTED
                                                                             c.INT_RATE,
                                                                             ln_CALC_last_paym_sum, --pi_last_paym_sum,
                                                                             --c1.EXP_PAY_CNT, --korn20140325
                                                                             case when nvl((SELECT SUM(nvl(EXP_PAY_CNT,0)) FROM REP_INT_DUE_CALC3 WHERE TO_DATE = c1.FROM_DATE),0)-ln_minus_paym>0
                                                                             then
                                                                                nvl((SELECT SUM(nvl(EXP_PAY_CNT,0)) FROM REP_INT_DUE_CALC3 WHERE TO_DATE = c1.FROM_DATE),0)-ln_minus_paym
                                                                             else
                                                                                nvl((SELECT SUM(nvl(EXP_PAY_CNT,0)) FROM REP_INT_DUE_CALC3 WHERE TO_DATE = c1.FROM_DATE),0)
                                                                             end, --korn20140411 --EXP_PAY_CNT
                                                                             --ЧДП указанные в отчете
                                                                             nvl((SELECT SUM(nvl(ADV_REPAYMENT,0)) FROM REP_INT_DUE_CALC3
                                                                                   WHERE TO_DATE < rec.TO_DATE),0)+nvl(ln_sum_hist_ADV_REPAYMENT,0), --WHERE TO_DATE <= rec.TO_DATE),0),
                                                                             pi_1paym_sum
                                                                             --ЧДП до опердня
                                                                             --+nvl(ln_sum_hist_ADV_REPAYMENT,0)
                                                                          )
                                                                      FROM REP_INT_DUE_CALC3 c
                                                                      WHERE FROM_DATE <> rec.TO_DATE
                                                                      AND TO_DATE = rec.TO_DATE)

                   where FROM_DATE = rec.TO_DATE;
                   commit;
            end if;
          end if;
          --потом просто копируем из предыдущего
          IF rec.TO_DATE>gd_max_adv_rep_to_date then
            update REP_INT_DUE_CALC3 c1 set EMI_AMOUNT = (SELECT c.EMI_AMOUNT
                                                            FROM REP_INT_DUE_CALC3 c
                                                           WHERE c.TO_DATE = rec.TO_DATE)

            where FROM_DATE = rec.TO_DATE;
            commit;
          end if;
        END LOOP;
           ---новая проверка
               --korn20140425
               /*UPDATE rep_int_due_calc_totals3
               SET check_message='Суммы ЧДП превышают остаток основной задолженности. Повторите расчет с другими параметрами'
               WHERE check_message is not null
               AND EXISTS (SELECT 'x' FROM REP_INT_DUE_CALC3 WHERE PRPL_EXPECTED<0);*/
               DELETE FROM REP_INT_DUE_CALC3
               WHERE PRPL_EXPECTED<0;
               COMMIT;
         --korn20180215 TESTKOP
         update REP_INT_DUE_CALC3 set ACCR_INT = round(ACCR_INT,2);
               COMMIT;
           -- add Polischuk N. PRB21747
           BEGIN
             select min(to_date) INTO min_pmnt_date_after_CHDP
               from REP_INT_DUE_CALC3
              where is_principal_pay='Y'
                and to_date>pi_1paym_date;
           EXCEPTION WHEN NO_DATA_FOUND THEN
              min_pmnt_date_after_CHDP:=gd_max_adv_rep_to_date;
           END;

           --
           --формируем итоги
           INSERT INTO rep_int_due_calc_totals3
           (account_number,
             prpl_expected,
             int_expected,
             principal_overdue,
             interest_overdue,
             int_on_ovd_p_accrued,
             penalty_p,
             penalty_i,
             exp_pay_cnt,
             due_date_on,
             new_emi,
             last_paym_contr,
             last_paym_calc)
         VALUES
             (pi_loan_account, --account_number
             /*nvl((SELECT sum(nvl(PRPL_EXPECTED,0))
                FROM REP_INT_DUE_CALC3
                WHERE from_date=gd_max_adv_rep_to_date),0),*/ --prpl_expected
              nvl((SELECT sum(nvl(PRPL_EXPECTED,0))
                FROM REP_INT_DUE_CALC3
                WHERE to_date=pi_1paym_date),0),
             /*nvl((SELECT sum(nvl(ACCR_INT,0))
                FROM REP_INT_DUE_CALC3
                WHERE to_date=pi_1paym_date),0),*/
      --korn20180215
              nvl((select sum(nvl(INT_DUE,0)) from REP_INT_DUE_CALC3
                    where to_date=(select min(to_date) from REP_INT_DUE_CALC3
                  where is_principal_pay='Y'
                  and to_date>=pi_1paym_date)
                   ),
              nvl((SELECT sum(nvl(ACCR_INT,0))
                     FROM REP_INT_DUE_CALC3
                    WHERE to_date=pi_1paym_date),0)),
             --вместо процентов будем выподить последнюю процентную ставку
             --nvl((SELECT max(nvl(INT_RATE,0))
             --   FROM REP_INT_DUE_CALC3
             --   WHERE from_date=gd_max_adv_rep_to_date/*(SELECT max(from_date) FROM REP_INT_DUE_CALC3)*/),0), --inr_rate
             /*nvl((SELECT sum(nvl(INT_EXPECTED,0))
                FROM REP_INT_DUE_CALC3
                WHERE from_date=ld_max_FROM_DATE),0), --int_expected*/
             go_PRINCIPAL_OVERDUE, --principal_overdue
             go_INTEREST_OVERDUE, --interest_overdue
             go_INT_ON_OVD_P_ACCRUED, --int_on_ovd_p_accrued
             go_PENALTY_P, --penalty_p
             go_PENALTY_I, --penalty_i
             /*(SELECT count(*)
                FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
                WHERE c.ACCOUNT_NUMBER  = pi_loan_account
                AND c.COMPONENT_NAME = 'MAIN_INT'
                AND c.schedule_due_date >= gd_max_adv_rep_to_date--pi_payment_plan_date
                ),*/ --exp_pay_cnt
             nvl((select exp_pay_cnt from REP_INT_DUE_CALC3
                    where to_date=gd_max_adv_rep_to_date),0),  --exp_pay_cnt
             ln_due_dates_on_rep,
             nvl((SELECT sum(nvl(PRINCIPAL,0)+nvl(INT_DUE,0)) --sum(nvl(EMI_AMOUNT,0))
                FROM REP_INT_DUE_CALC3
                 --WHERE from_date=gd_max_adv_rep_to_date/*(SELECT max(from_date) FROM REP_INT_DUE_CALC3 WHERE nvl(EMI_AMOUNT,0)>0)*/),0), --new_emi
                WHERE to_date = min_pmnt_date_after_CHDP),0), --new_emi -- add Polischuk N. PRB21747
             ln_CALC_last_paym_sum, --pi_last_paym_sum, --last_paym_contr
             null --last_paym_calc
             );
         COMMIT;
         UPDATE rep_int_due_calc_totals3
            SET TOTAL= nvl(round(PRPL_EXPECTED,2),0)+
                        nvl(round(INT_EXPECTED,2),0)+
                        nvl(round(PRINCIPAL_OVERDUE,2),0)+
                        nvl(round(INTEREST_OVERDUE,2),0)+
                        nvl(round(INT_ON_OVD_P_ACCRUED,2),0)+
                        nvl(round(PENALTY_P,2),0)+
                        nvl(round(PENALTY_I,2),0)
         WHERE PRPL_EXPECTED is not null;
         COMMIT;
         --DBMS_OUTPUT.Put_Line('gn_is_buy_back='||to_char(gn_is_buy_back));
         /*IF gn_is_buy_back>0 THEN
            SELECT SUM(nvl(ADV_REPAYMENT,0)) INTO ln_sum_ADV_REPAYMENT
             FROM REP_INT_DUE_CALC3;
             UPDATE rep_int_due_calc_totals3
                SET LAST_PAYM_CALC= case when
                nvl(round(PRPL_EXPECTED,2),0)>=nvl(round(LAST_PAYM_CONTR,2),0)-nvl(ln_sum_ADV_REPAYMENT,0)
                then greatest(nvl(round(LAST_PAYM_CONTR,2),0),nvl(ln_sum_ADV_REPAYMENT,0))-nvl(ln_sum_ADV_REPAYMENT,0) --чтобы не было отрицательных значений
                else nvl(round(PRPL_EXPECTED,2),0)
                end
             WHERE PRPL_EXPECTED is not null;
             COMMIT;
         ELSE
            UPDATE rep_int_due_calc_totals3
                SET LAST_PAYM_CONTR=NULL;
             COMMIT;
         END IF;*/

         --для вывода сложим суммы
         UPDATE REP_INT_DUE_CALC3
         SET PRINCIPAL=nvl(PRINCIPAL,0)+nvl(ADV_REPAYMENT,0),
             INT_DUE=case when IS_PRINCIPAL_PAY='Y' then nvl(INT_DUE,EMI_AMOUNT)  else null end
         WHERE nvl(ADV_REPAYMENT,0)>0;
         COMMIT;
         --для вывода удалим отложенные проценты за даты где не было платежа
         UPDATE REP_INT_DUE_CALC3
         SET INT_EXPECTED=null
         WHERE nvl(IS_PRINCIPAL_PAY,0)<>'Y';
         COMMIT;
         UPDATE rep_int_due_calc_totals3
                SET customer_name=to_char(gd_max_adv_rep_to_date+1,'DD.MM.RRRR')
         WHERE PRPL_EXPECTED is not null;
         COMMIT;
         --последний платеж в расписании
         UPDATE REP_INT_DUE_CALC3
         SET int_expected=case when nvl(int_expected,0)=0 then 0 else nvl(int_expected,0)+nvl(EMI_AMOUNT,0) end  --отложенные % в последнем платеже не гасятся аннуитетом
         WHERE exp_pay_cnt=0;
         UPDATE REP_INT_DUE_CALC3
         SET PRINCIPAL=nvl(prpl_expected,0),
             EMI_AMOUNT=nvl(prpl_expected,0)+case when nvl(int_expected,0)>0 then nvl(int_expected,0) else nvl(accr_int,0) end
     WHERE EXP_PAY_CNT=(SELECT min(EXP_PAY_CNT) FROM REP_INT_DUE_CALC3);
     --korn20180524
         --WHERE exp_pay_cnt=0;
         COMMIT;
         UPDATE rep_int_due_calc_totals3
                SET LAST_PAYM_CALC=(--select nvl(prpl_expected,0)+case when nvl(int_expected,0)>0 then nvl(int_expected,0) else nvl(accr_int,0) end
                  select nvl(prpl_expected,0)+case when nvl(int_expected,0)>0 then nvl(int_expected,0) else nvl(int_due,0) end
                                        from REP_INT_DUE_CALC3
                                        where to_date=(select max(to_date) from REP_INT_DUE_CALC3))
         WHERE PRPL_EXPECTED is not null;
         COMMIT;
         END IF;
     ELSE
         insert into rep_int_due_calc_totals3(account_number,check_message)
         values(pi_loan_account, lv_check_message);
         COMMIT;
     end if;

   COMMIT;
   END fill_report_by_date3_SBL;

  FUNCTION SBL_PREPAY_CHDP(pi_loan_account IN VARCHAR2,
                           pi_1paym_date IN DATE,
                           pi_1paym_sum  IN NUMBER,
                           pi_last_paym_sum  IN NUMBER,
               pi_principal_amt IN NUMBER) return rep_sbl_chdp_dt_nt PIPELINED IS
    lv_REPORT_WARN  varchar2(500);
    --lv_REPORT_WARN2  varchar2(4000);
    ln_PSK  number;
   BEGIN
      rep_sbl_pkg.fill_report_by_date3_SBL(pi_loan_account,
                            pi_1paym_date,
                            pi_1paym_sum,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            pi_last_paym_sum,
                            pi_principal_amt);
    lv_REPORT_WARN:=null;
--  Убрана проверка сторнирующих операций по согласованию с Завгородней Е. 06.05.20  PRB22107
--      begin
--      SELECT   CASE WHEN COUNT (*)>0 THEN 'Выполнялось сторнирование операций' ELSE null END
--        INTO lv_REPORT_WARN
--        FROM   fcc.cltb_account_events_processed
--       WHERE       account_number =pi_loan_account
--           AND event_date > (SELECT   MIN (from_date) FROM bodev.REP_INT_DUE_CALC3)
--           AND (EVENT_CODE = 'REVV' OR EVENT_CODE = 'REVP');
--      exception when no_data_found then
--      lv_REPORT_WARN:=null;
--      end;
      ln_PSK:=get_psk(pi_loan_account,0.0001,pi_1paym_date)*100;
      --  Убрана проверка контроля сумм остатка задолженности в FCC и расчитанной по заявке от Завгородней Е. INC000776962
      /*begin
      lv_REPORT_WARN2:=substr(checking_amounts_fcc(pi_loan_account),1,4000);
      exception when others then lv_REPORT_WARN2:=null;
      end;
      if lv_REPORT_WARN2 is not null then
        lv_REPORT_WARN2:='По указанному кредиту на текущую дату уже есть заявка на ЧДП';
        lv_REPORT_WARN:=substr(trim(nvl(lv_REPORT_WARN,'')||' '||nvl(lv_REPORT_WARN2,'')),1,500);
      end if;*/
      for rec in (SELECT   max(decode(check_message,null,account_number,null)) account_number,
               max(decode(check_message,null,prpl_expected,null)) prpl_expected,
               max(decode(check_message,null,int_expected,null)) int_expected,
                           max(decode(check_message,null,principal_overdue,null)) principal_overdue,
               max(decode(check_message,null,interest_overdue,null)) interest_overdue,
               max(decode(check_message,null,int_on_ovd_p_accrued,null)) int_on_ovd_p_accrued,
                           max(decode(check_message,null,penalty_p,null)) penalty_p,
               max(decode(check_message,null,penalty_i,null)) penalty_i,
               max(decode(check_message,null,exp_pay_cnt,null)) exp_pay_cnt,
               max(decode(check_message,null,due_date_on,null)) due_date_on,
               max(decode(check_message,null,new_emi,null)) new_emi,
                           max(decode(check_message,null,last_paym_contr,null)) last_paym_contr,
               max(decode(check_message,null,last_paym_calc,null)) last_paym_calc,
               max(decode(check_message,null,total,null)) total,
               max(decode(check_message,null,null,customer_name)) customer_name,
                           max(decode(check_message,null,null,trim(check_message))) check_message
                          FROM rep_int_due_calc_totals3) loop
         if rec.check_message is not null and lv_REPORT_WARN is null then
          lv_REPORT_WARN:=rec.check_message;
         elsif rec.check_message='OK' and lv_REPORT_WARN is not null then
          lv_REPORT_WARN:=trim(lv_REPORT_WARN);
         elsif rec.check_message<>'OK' and lv_REPORT_WARN is not null then
          lv_REPORT_WARN:=trim(nvl(rec.check_message,'')||' '||nvl(lv_REPORT_WARN,''));
         end if;
               pipe row(rep_sbl_chdp_dt_t(rec.account_number,
                                               rec.prpl_expected,
                                               rec.int_expected,
                                               rec.principal_overdue,
                                               rec.interest_overdue,
                                               rec.int_on_ovd_p_accrued,
                                               rec.penalty_p,
                                               rec.penalty_i,
                                               rec.exp_pay_cnt,
                         rec.due_date_on,
                                               rec.new_emi,
                         round(ln_PSK,5),
                                               rec.last_paym_contr,
                                               rec.last_paym_calc,
                                               rec.total,
                                               rec.customer_name,
                                               lv_REPORT_WARN
                         ));
      end loop;
      RETURN;
   END SBL_PREPAY_CHDP;

function SBL_PREPAY_CHDP_SCHED(p_date_chdp IN DATE) return rep_sbl_chdp_sched_nt pipelined is
begin
    for rec in (SELECT FROM_DATE,
      TO_DATE,
      INT_RATE,
      ACCR_INT,
      INT_EXPECTED,
      INT_PREPAID,
      decode(ADV_REPAYMENT,0,null,ADV_REPAYMENT) ADV_REPAYMENT,
      INT_DUE,
      EMI_AMOUNT,
      IS_PRINCIPAL_PAY,
      PRINCIPAL,
      nvl(PRPL_EXPECTED,0)-nvl(PRINCIPAL,0) PRPL_EXPECTED, --Denis A. Vishnikin 27.09.2017 17:19
      TRANCHE,
      EXP_PAY_CNT
    FROM (SELECT      clc.FROM_DATE,
                nvl(clc2.TO_DATE,clc.TO_DATE) TO_DATE,
                clc.INT_RATE,
                nvl(clc.ACCR_INT,0)+nvl(clc2.ACCR_INT,0) ACCR_INT,
                nvl(clc.INT_EXPECTED,0)+nvl(clc2.INT_EXPECTED,0) INT_EXPECTED,
                nvl(clc.INT_PREPAID,0)+nvl(clc2.INT_PREPAID,0) INT_PREPAID,
                nvl(clc.ADV_REPAYMENT,0)+nvl(clc2.ADV_REPAYMENT,0) ADV_REPAYMENT,
                nvl(clc2.INT_DUE,clc.INT_DUE) INT_DUE,
                nvl(clc2.EMI_AMOUNT,clc.EMI_AMOUNT) EMI_AMOUNT,
                nvl(clc2.IS_PRINCIPAL_PAY,clc.IS_PRINCIPAL_PAY) IS_PRINCIPAL_PAY,
                nvl(clc2.PRINCIPAL,clc.PRINCIPAL) PRINCIPAL,
                nvl(clc2.PRPL_EXPECTED,clc.PRPL_EXPECTED) PRPL_EXPECTED,
                nvl(clc.TRANCHE,0)+nvl(clc2.TRANCHE,0) TRANCHE,
                nvl(clc2.EXP_PAY_CNT,clc.EXP_PAY_CNT) EXP_PAY_CNT
              /*clc.YEAR_DIV,
              clc2.FROM_DATE,
                clc2.TO_DATE,
                clc2.INT_RATE,
                clc2.ACCR_INT,
                clc2.INT_EXPECTED,
                clc2.INT_PREPAID,
                clc2.ADV_REPAYMENT,
                clc2.INT_DUE,
                clc2.EMI_AMOUNT,
                clc2.IS_PRINCIPAL_PAY,
                clc2.PRINCIPAL,
                clc2.PRPL_EXPECTED,
                clc2.TRANCHE,
                clc2.EXP_PAY_CNT,
              clc2.YEAR_DIV*/
              FROM BODEV.REP_INT_DUE_CALC3 clc
            LEFT JOIN BODEV.REP_INT_DUE_CALC3 clc2
            ON clc.TO_DATE=clc2.FROM_DATE
            AND clc.YEAR_DIV='B' AND clc2.YEAR_DIV='E'
            WHERE nvl(clc.YEAR_DIV,'Z')<>'E')
    WHERE TO_DATE  >=  p_date_chdp
    ORDER BY FROM_DATE)
    loop
      pipe row (rep_sbl_chdp_sched_t (rec.FROM_DATE,
                    rec.TO_DATE,
                      rec.INT_RATE,
                      rec.ACCR_INT,
                      rec.INT_EXPECTED,
                      rec.INT_PREPAID,
                      rec.ADV_REPAYMENT,
                      rec.INT_DUE,
                      rec.EMI_AMOUNT,
                      rec.IS_PRINCIPAL_PAY,
                      rec.PRINCIPAL,
                      rec.PRPL_EXPECTED,
                      rec.TRANCHE,
                      rec.EXP_PAY_CNT));
    end loop;
    return;
end SBL_PREPAY_CHDP_SCHED;

PROCEDURE sbl_prepay_pdp_wrap(p_loan_id IN VARCHAR2,
                              p_date_pdp IN DATE,
                              p_date_ovr IN DATE,
                              p_cursor OUT SYS_REFCURSOR
                             )
IS
  v_account_number       VARCHAR2(20);
  v_prpl_expected        NUMBER;
  v_int_expected         NUMBER;
  v_principal_overdue    NUMBER;
  v_interest_overdue     NUMBER;
  v_int_on_ovd_p_accrued NUMBER;
  v_penalty_p            NUMBER;
  v_penalty_i            NUMBER;
  v_total                NUMBER;
  v_exp_pay_cnt          NUMBER;
  v_customer_name        VARCHAR2(500);
  v_check_message        VARCHAR2(200);
  v_insert_time          TIMESTAMP(6);
  v_process_time         TIMESTAMP(6);
  v_is_log               BO_SETTINGS.PARAM_VALUE%TYPE;
  v_row                  REP_SBL_PKG_LOG%ROWTYPE;
  v_request_id           NUMBER;
BEGIN
 v_is_log:=Get_Setting('REP_SBL_PKG.SBL_PREPAY_PDP_WRAP');

 if (v_is_log = 'Y')
 then
   -- Logging
   v_insert_time:=SYSTIMESTAMP;
   v_request_id:=Get_Request_ID;
   v_row.insert_time:=v_insert_time;
   v_row.request_id:=v_request_id;
   v_row.proc_name:='REP_SBL_PKG.SBL_PREPAY_PDP_WRAP';
   v_row.param_type:='IN';

   -- IN parameters
   v_row.loan_id:=p_loan_id;
   v_row.date_pdp:=p_date_pdp;
   v_row.date_ovr:=p_date_ovr;

   insert into REP_SBL_PKG_LOG
   values v_row;

   v_row:=NULL;

   -- OUT parameters
   v_row.proc_name:='REP_SBL_PKG.SBL_PREPAY_PDP_WRAP';
   v_row.param_type:='OUT';

   insert into REP_SBL_PKG_LOG
    (proc_name
    ,param_type
    ,insert_time
	,request_id
    ,account_number
    ,prpl_expected
    ,int_expected
    ,principal_overdue
    ,interest_overdue
    ,int_on_ovd_p_accrued
    ,penalty_p
    ,penalty_i
    ,total
    ,exp_pay_cnt
    ,customer_name
    ,check_message
    )
   select v_row.proc_name
         ,v_row.param_type
         ,v_insert_time
		 ,v_request_id
         ,account_number
         ,prpl_expected
         ,int_expected
         ,principal_overdue
         ,interest_overdue
         ,int_on_ovd_p_accrued
         ,penalty_p
         ,penalty_i
         ,total
         ,exp_pay_cnt
         ,customer_name
         ,check_message
    from table (rep_sbl_pkg.SBL_PREPAY_PDP(p_loan_id
                                       ,p_date_pdp
                                       ,p_date_ovr));
 end if;

 open p_cursor for
 select account_number
       ,prpl_expected
       ,int_expected
       ,principal_overdue
       ,interest_overdue
       ,int_on_ovd_p_accrued
       ,penalty_p
       ,penalty_i
       ,total
       ,exp_pay_cnt
       ,customer_name
       ,check_message
 from table (rep_sbl_pkg.SBL_PREPAY_PDP(p_loan_id
                                       ,p_date_pdp
                                       ,p_date_ovr));

 if (v_is_log = 'Y')
 then
   v_process_time:=SYSTIMESTAMP;

   update REP_SBL_PKG_LOG
   set process_time = v_process_time
   where request_id = v_request_id;
   commit;
 end if;

END sbl_prepay_pdp_wrap;
--
PROCEDURE sbl_prepay_chdp_wrap (
    p_loan_id IN VARCHAR2,
    p_date_chdp IN DATE,
    p_sum_chdp IN NUMBER,
    p_sum_last_pay IN NUMBER,
    p_cursor OUT SYS_REFCURSOR,
    p_schedule OUT SYS_REFCURSOR) IS
BEGIN
  OPEN p_cursor FOR
    SELECT account_number
      ,prpl_expected
      ,int_expected
      ,principal_overdue
      ,interest_overdue
      ,int_on_ovd_p_accrued
      ,penalty_p
      ,penalty_i
      ,exp_pay_cnt
      ,due_date_on
      ,new_emi
      ,trunc(new_psk,3) new_psk
      ,last_paym_contr
      ,last_paym_calc
      ,total
      ,customer_name
      ,check_message
    FROM TABLE (rep_sbl_pkg.SBL_PREPAY_CHDP (p_loan_id
                 ,p_date_chdp
                 ,p_sum_chdp
                 ,p_sum_last_pay
                 ,null));
  OPEN p_schedule FOR
  SELECT FROM_DATE,
      TO_DATE,
      INT_RATE,
      ACCR_INT,
      INT_EXPECTED,
      INT_PREPAID,
      ADV_REPAYMENT,
      INT_DUE,
      EMI_AMOUNT,
      IS_PRINCIPAL_PAY,
      PRINCIPAL,
      PRPL_EXPECTED,
      TRANCHE,
      EXP_PAY_CNT
    FROM TABLE (rep_sbl_pkg.SBL_PREPAY_CHDP_SCHED(p_date_chdp));
END sbl_prepay_chdp_wrap;
--
PROCEDURE sbl_prepay_chdp_ext_wrap(
    p_loan_id IN VARCHAR2,
    p_date_chdp IN DATE,
    p_sum_chdp IN NUMBER,
    p_fccComp_DUE_FCY_ADCH_CHG IN NUMBER,
    p_fccComp_DUE_FCY_ARRFEE IN NUMBER,
    p_fccComp_DUE_FCY_ARRFEE_F IN NUMBER,
    p_fccComp_DUE_FCY_COST_CHG IN NUMBER,
    p_fccComp_DUE_MAIN_INT IN NUMBER, --
    p_fccComp_DUE_ARR_FEE IN NUMBER,
    p_fccComp_DUE_COST_CHRG IN NUMBER,
    p_fccComp_DUE_PENALTY_I IN NUMBER, --
    p_fccComp_DUE_ARR_FEE_FULL IN NUMBER,
    p_fccComp_DUE_PRINCIPAL IN NUMBER, --
    p_fccComp_DUE_ADH_PENALTY IN NUMBER,
    p_fccComp_DUE_INT_ON_OVD_P IN NUMBER,
    p_fccComp_DUE_ADHOC_CHRG IN NUMBER,
    p_fccComp_DUE_PENALTY_P IN NUMBER, --
    p_fccComp_OVDUE_FCY_ADCH_CHG IN NUMBER,
    p_fccComp_OVDUE_FCY_ARRFEE IN NUMBER,
    p_fccComp_OVDUE_FCY_ARRFEE_F IN NUMBER,
    p_fccComp_OVDUE_FCY_COST_CHG IN NUMBER,
    p_fccComp_OVDUE_MAIN_INT IN NUMBER, --
    p_fccComp_OVDUE_ARR_FEE IN NUMBER,
    p_fccComp_OVDUE_COST_CHRG IN NUMBER,
    p_fccComp_OVDUE_PENALTY_I IN NUMBER, --
    p_fccComp_OVDUE_ARR_FEE_FULL IN NUMBER,
    p_fccComp_OVDUE_PRINCIPAL IN NUMBER, --
    p_fccComp_OVDUE_ADH_PENALTY IN NUMBER,
    p_fccComp_OVDUE_INT_ON_OVD_P IN NUMBER,
    p_fccComp_OVDUE_ADHOC_CHRG IN NUMBER,
    p_fccComp_OVDUE_PENALTY_P IN NUMBER, --
    p_fccComp_NOTDUE_FCY_ADCH_CHG IN NUMBER,
    p_fccComp_NOTDUE_FCY_ARRFEE IN NUMBER,
    p_fccComp_NOTDUE_FCY_ARRFEE_F IN NUMBER,
    p_fccComp_NOTDUE_FCY_COST_CHG IN NUMBER,
    p_fccComp_NOTDUE_MAIN_INT IN NUMBER, --
    p_fccComp_NOTDUE_ARR_FEE IN NUMBER,
    p_fccComp_NOTDUE_COST_CHRG IN NUMBER,
    p_fccComp_NOTDUE_PENALTY_I IN NUMBER, --
    p_fccComp_NOTDUE_ARR_FEE_FULL IN NUMBER,
    p_fccComp_NOTDUE_PRINCIPAL IN NUMBER, --
    p_fccComp_NOTDUE_ADH_PENALTY IN NUMBER,
    p_fccComp_NOTDUE_INT_ON_OVD_P IN NUMBER, --
    p_fccComp_NOTDUE_ADHOC_CHRG IN NUMBER,
    p_fccComp_NOTDUE_PENALTY_P IN NUMBER, --
    p_cursor OUT SYS_REFCURSOR,
    p_schedule OUT SYS_REFCURSOR)
IS
 p_sum_last_pay NUMBER;
 ld_today DATE;
 ln_sum_MAIN_INT NUMBER;
 ln_sum_PRINCIPAL NUMBER;
 ld_date_MAIN_INT DATE;
 ld_date_PRINCIPAL DATE;
 ln_INT_OVD_RATE  NUMBER;
 ln_PENALTY_RATE NUMBER;
 ln_row_cnt_INT_ON_OVD_P NUMBER;
 ln_row_cnt_PENALTY_P NUMBER;
 ln_row_cnt_PENALTY_I NUMBER;
 lv_field_no VARCHAR2(10);
 lv_penalty_rate_type VARCHAR2(50);
 ln_penalty_rate_div NUMBER;
 go_INT_ON_OVD_P_ACCRUED NUMBER;
 go_PENALTY_P NUMBER;
 go_PENALTY_I NUMBER;
 v_count_ordn_days NUMBER;
 v_count_leap_days NUMBER;
 v_cust_name       VARCHAR2(500);
 v_loan_branch     VARCHAR2(10);
 v_insert_time     TIMESTAMP(6);
 v_process_time    TIMESTAMP(6);
 v_is_log          BO_SETTINGS.PARAM_VALUE%TYPE;
 v_row             REP_SBL_PKG_LOG%ROWTYPE;
 v_request_id      NUMBER;
BEGIN
  v_is_log:=Get_Setting('REP_SBL_PKG.SBL_PREPAY_CHDP_EXT_WRAP');

  if (v_is_log = 'Y')
  then
   -- Logging
   v_insert_time:=SYSTIMESTAMP;
   v_request_id:=Get_Request_ID;
   v_row.insert_time:=v_insert_time;
   v_row.request_id:=v_request_id;
   v_row.proc_name:='REP_SBL_PKG.SBL_PREPAY_CHDP_EXT_WRAP';
   v_row.param_type:='IN';

   -- IN parameters
   v_row.loan_id:=p_loan_id;
   v_row.date_chdp:=p_date_chdp;
   v_row.sum_chdp:=p_sum_chdp;
   v_row.fcccomp_due_fcy_adch_chg:=p_fcccomp_due_fcy_adch_chg;
   v_row.fcccomp_due_fcy_arrfee:=p_fcccomp_due_fcy_arrfee;
   v_row.fcccomp_due_fcy_arrfee_f:=p_fcccomp_due_fcy_arrfee_f;
   v_row.fcccomp_due_fcy_cost_chg:=p_fcccomp_due_fcy_cost_chg;
   v_row.fcccomp_due_main_int:=p_fcccomp_due_main_int;
   v_row.fcccomp_due_arr_fee:=p_fcccomp_due_arr_fee;
   v_row.fcccomp_due_cost_chrg:=p_fcccomp_due_cost_chrg;
   v_row.fcccomp_due_penalty_i:=p_fcccomp_due_penalty_i;
   v_row.fcccomp_due_arr_fee_full:=p_fcccomp_due_arr_fee_full;
   v_row.fcccomp_due_principal:=p_fcccomp_due_principal;
   v_row.fcccomp_due_adh_penalty:=p_fcccomp_due_adh_penalty;
   v_row.fcccomp_due_int_on_ovd_p:=p_fcccomp_due_int_on_ovd_p;
   v_row.fcccomp_due_adhoc_chrg:=p_fcccomp_due_adhoc_chrg;
   v_row.fcccomp_due_penalty_p:=p_fcccomp_due_penalty_p;
   v_row.fcccomp_ovdue_fcy_adch_chg:=p_fcccomp_ovdue_fcy_adch_chg;
   v_row.fcccomp_ovdue_fcy_arrfee:=p_fcccomp_ovdue_fcy_arrfee;
   v_row.fcccomp_ovdue_fcy_arrfee_f:=p_fcccomp_ovdue_fcy_arrfee_f;
   v_row.fcccomp_ovdue_fcy_cost_chg:=p_fcccomp_ovdue_fcy_cost_chg;
   v_row.fcccomp_ovdue_main_int:=p_fcccomp_ovdue_main_int;
   v_row.fcccomp_ovdue_arr_fee:=p_fcccomp_ovdue_arr_fee;
   v_row.fcccomp_ovdue_cost_chrg:=p_fcccomp_ovdue_cost_chrg;
   v_row.fcccomp_ovdue_penalty_i:=p_fcccomp_ovdue_penalty_i;
   v_row.fcccomp_ovdue_arr_fee_full:=p_fcccomp_ovdue_arr_fee_full;
   v_row.fcccomp_ovdue_principal:=p_fcccomp_ovdue_principal;
   v_row.fcccomp_ovdue_adh_penalty:=p_fcccomp_ovdue_adh_penalty;
   v_row.fcccomp_ovdue_int_on_ovd_p:=p_fcccomp_ovdue_int_on_ovd_p;
   v_row.fcccomp_ovdue_adhoc_chrg:=p_fcccomp_ovdue_adhoc_chrg;
   v_row.fcccomp_ovdue_penalty_p:=p_fcccomp_ovdue_penalty_p;
   v_row.fcccomp_notdue_fcy_adch_chg:=p_fcccomp_notdue_fcy_adch_chg;
   v_row.fcccomp_notdue_fcy_arrfee:=p_fcccomp_notdue_fcy_arrfee;
   v_row.fcccomp_notdue_fcy_arrfee_f:=p_fcccomp_notdue_fcy_arrfee_f;
   v_row.fcccomp_notdue_fcy_cost_chg:=p_fcccomp_notdue_fcy_cost_chg;
   v_row.fcccomp_notdue_main_int:=p_fcccomp_notdue_main_int;
   v_row.fcccomp_notdue_arr_fee:=p_fcccomp_notdue_arr_fee;
   v_row.fcccomp_notdue_cost_chrg:=p_fcccomp_notdue_cost_chrg;
   v_row.fcccomp_notdue_penalty_i:=p_fcccomp_notdue_penalty_i;
   v_row.fcccomp_notdue_arr_fee_full:=p_fcccomp_notdue_arr_fee_full;
   v_row.fcccomp_notdue_principal:=p_fcccomp_notdue_principal;
   v_row.fcccomp_notdue_adh_penalty:=p_fcccomp_notdue_adh_penalty;
   v_row.fcccomp_notdue_int_on_ovd_p:=p_fcccomp_notdue_int_on_ovd_p;
   v_row.fcccomp_notdue_adhoc_chrg:=p_fcccomp_notdue_adhoc_chrg;
   v_row.fcccomp_notdue_penalty_p:=p_fcccomp_notdue_penalty_p;

   insert into REP_SBL_PKG_LOG
   values v_row;
  end if;

  v_row:=NULL;

  p_sum_last_pay:=null;
  SELECT today, Branch_code INTO ld_today, v_loan_branch FROM fcc.sttm_dates
  WHERE Branch_code = (SELECT Branch_code FROM CLTB_ACCOUNT_MASTER WHERE ACCOUNT_NUMBER = p_loan_id);
  --
  if FCCADPRO.FLEXADP_ESBADP.Is_Loan_Holiday(p_loan_id, v_loan_branch) = 'Y' then -- Mortgage and Covid19 loan holidays
    select NAME_RUS3||' '||NAME_RUS1||' '||NAME_RUS2 INTO v_cust_name
      from fcc.STTM_CUST_PERSONAL
      where customer_no=(SELECT max(customer_id) FROM fcc.CLTB_ACCOUNT_MASTER WHERE ACCOUNT_NUMBER = p_loan_id);

   if (v_is_log = 'Y')
   then

    -- Logging (OUT parameters)
    v_row.param_type:='OUT';
    v_row.proc_name:='REP_SBL_PKG.SBL_PREPAY_CHDP_EXT_WRAP';

    insert into REP_SBL_PKG_LOG
    (proc_name
    ,param_type
    ,insert_time
	,request_id
    ,account_number
    ,prpl_expected
    ,int_expected
    ,principal_overdue
    ,interest_overdue
    ,int_on_ovd_p_accrued
    ,penalty_p
    ,penalty_i
    ,exp_pay_cnt
    ,due_date_on
    ,new_emi
    ,new_psk
    ,last_paym_contr
    ,last_paym_calc
    ,total
    ,customer_name
    ,check_message
    )
    SELECT v_row.proc_name
          ,v_row.param_type
          ,v_insert_time
		  ,v_request_id
          ,p_loan_id as account_number
          ,1 as prpl_expected
          ,1 as int_expected
          ,0 as principal_overdue
          ,0 as interest_overdue
          ,0 as int_on_ovd_p_accrued
          ,1 as penalty_p
          ,1 as penalty_i
          ,1 as exp_pay_cnt
          ,1 as due_date_on
          ,1 as new_emi
          ,1 as new_psk
          ,1 as last_paym_contr
          ,1 as last_paym_calc
          ,1 as total
          ,v_cust_name as customer_name
          ,'OK' as check_message
    FROM DUAL;
   end if;

    OPEN p_cursor FOR
     SELECT p_loan_id as account_number
      ,1 as prpl_expected
      ,1 as int_expected
      ,0 as principal_overdue
      ,0 as interest_overdue
      ,0 as int_on_ovd_p_accrued
      ,1 as penalty_p
      ,1 as penalty_i
      ,1 as exp_pay_cnt
      ,1 as due_date_on
      ,1 as new_emi
      ,1 as new_psk
      ,1 as last_paym_contr
      ,1 as last_paym_calc
      ,1 as total
      ,v_cust_name as customer_name
      ,'OK' as check_message
    FROM DUAL;
    --
    OPEN p_schedule FOR
      SELECT ld_today as FROM_DATE,
             ld_today as TO_DATE,
             1 as INT_RATE,
             1 as ACCR_INT,
             1 as INT_EXPECTED,
             1 as INT_PREPAID,
             1 as ADV_REPAYMENT,
             1 as INT_DUE,
             1 as EMI_AMOUNT,
            'Y' as IS_PRINCIPAL_PAY,
             1 AS PRINCIPAL,
             1 AS PRPL_EXPECTED,
             1 AS TRANCHE,
             1 AS EXP_PAY_CNT
        FROM DUAL;
  ELSE
    SELECT sum(nvl(a.amount_due,0)), max(SCHEDULE_DUE_DATE) INTO ln_sum_MAIN_INT, ld_date_MAIN_INT
      FROM fcc.CLTB_ACCOUNT_SCHEDULES  a
     WHERE a.ACCOUNT_NUMBER = p_loan_id
       AND a.COMPONENT_NAME = 'MAIN_INT'
       AND a.SCHEDULE_DUE_DATE >= ld_today
       AND a.SCHEDULE_DUE_DATE < p_date_chdp;
    SELECT sum(nvl(a.amount_due,0)), max(SCHEDULE_DUE_DATE) INTO ln_sum_PRINCIPAL, ld_date_PRINCIPAL
    FROM fcc.CLTB_ACCOUNT_SCHEDULES  a
    WHERE a.ACCOUNT_NUMBER = p_loan_id
    AND a.COMPONENT_NAME = 'PRINCIPAL'
    AND a.SCHEDULE_DUE_DATE >= ld_today
        AND a.SCHEDULE_DUE_DATE < p_date_chdp;
  --penalty
  SELECT  count(*) into ln_row_cnt_INT_ON_OVD_P FROM fcc.cltb_account_schedules
      WHERE   account_number = p_loan_id
      AND component_name='INT_ON_OVD_P';
  SELECT  count(*) into ln_row_cnt_PENALTY_P FROM fcc.cltb_account_schedules
      WHERE   account_number = p_loan_id
      AND component_name='PENALTY_P';
  SELECT  count(*) into ln_row_cnt_PENALTY_I FROM fcc.cltb_account_schedules
      WHERE   account_number = p_loan_id
      AND component_name='PENALTY_I';
  IF (ln_sum_MAIN_INT>0 or ln_sum_PRINCIPAL>0)
  THEN
      --ставки
          BEGIN
                SELECT nvl(UDE_VALUE,0) RATE INTO ln_INT_OVD_RATE FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                         WHERE ACCOUNT_NUMBER = p_loan_id
                                          AND EFFECTIVE_DATE=(SELECT max(EFFECTIVE_DATE) FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                                               WHERE ACCOUNT_NUMBER = p_loan_id
                                                               AND EFFECTIVE_DATE<=p_date_chdp
                                                               AND UDE_ID = 'INT_OVD_RATE')
                                         AND UDE_ID = 'INT_OVD_RATE';
            EXCEPTION WHEN NO_DATA_FOUND THEN
                ln_INT_OVD_RATE:=0;
            END;
            BEGIN
                SELECT nvl(UDE_VALUE,0) RATE INTO ln_PENALTY_RATE FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                         WHERE ACCOUNT_NUMBER = p_loan_id
                                          AND EFFECTIVE_DATE=(SELECT max(EFFECTIVE_DATE) FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                                               WHERE ACCOUNT_NUMBER = p_loan_id
                                                               AND EFFECTIVE_DATE<=p_date_chdp
                                                               AND UDE_ID = 'PENALTY_RATE')
                                         AND UDE_ID = 'PENALTY_RATE';
            EXCEPTION WHEN NO_DATA_FOUND THEN
                ln_PENALTY_RATE:=0;
            END;
      --периодичность ставки по Penalty
      if (ln_row_cnt_PENALTY_P>0 or ln_row_cnt_PENALTY_I>0) then
        SELECT field_no into lv_field_no FROM FCC.CLTM_PRODUCT_UDF
          WHERE field_name ='PENAL_RATE_BASIS'
          AND product_code=(SELECT Product_code
                   FROM CLTB_ACCOUNT_MASTER
                   WHERE ACCOUNT_NUMBER = p_loan_id);
          if lv_field_no is not null then
            execute immediate
            'SELECT field_char_'||to_char(lv_field_no)||' FROM CLTB_ACCOUNT_APPS_MASTER
              WHERE account_number='''||p_loan_id||'''' into lv_penalty_rate_type;
            if lv_penalty_rate_type='ANNUAL'
            then ln_penalty_rate_div:=366; -- Changed to 366 Polishchuk NA INC000635178
            else ln_penalty_rate_div:=1;
            end if;
          else
            ln_penalty_rate_div:=1;
          end if;
      end if;
      -- Calculate the number of days in a leap and non-leap year within ld_date_PRINCIPAL AND p_date_chdp Polishchuk NA 201210
      GET_count_days(ld_date_PRINCIPAL,p_date_chdp, v_count_leap_days, v_count_ordn_days);
      if ln_row_cnt_INT_ON_OVD_P>0 then
        go_INT_ON_OVD_P_ACCRUED:=round(nvl(ln_sum_PRINCIPAL,0)*(ln_INT_OVD_RATE/100)*( v_count_leap_days / 366 + v_count_ordn_days / 365 ),2); -- Changed to 366 Polishchuk NA INC000635178
      end if;
      ----------------------
      if ln_row_cnt_PENALTY_P>0 then
        IF ln_penalty_rate_div = 1 THEN
          go_PENALTY_P:=round(nvl(ln_sum_PRINCIPAL,0)*(ln_PENALTY_RATE/100)*(p_date_chdp-ld_date_PRINCIPAL),2);
        ELSE
          go_PENALTY_P:=round(nvl(ln_sum_PRINCIPAL,0)*(ln_PENALTY_RATE/100)*( v_count_leap_days / 366 + v_count_ordn_days / 365 ),2);
        end if;
      END IF;
      -- Calculate the number of days in a leap and non-leap year within ld_date_PRINCIPAL AND p_date_chdp Polishchuk NA 201210
      GET_count_days(ld_date_MAIN_INT,p_date_chdp, v_count_leap_days, v_count_ordn_days);
      ----------------------
      if ln_row_cnt_PENALTY_I>0 then
        IF ln_penalty_rate_div = 1 THEN
          go_PENALTY_P:=round(nvl(ln_sum_MAIN_INT,0)*(ln_PENALTY_RATE/100)*(p_date_chdp-ld_date_PRINCIPAL),2);
        ELSE
          go_PENALTY_P:=round(nvl(ln_sum_MAIN_INT,0)*(ln_PENALTY_RATE/100)*( v_count_leap_days / 366 + v_count_ordn_days / 365 ),2);
        end if;
      end if;
  END IF;
  --

  v_row:=NULL;

  if (v_is_log = 'Y')
  then
    -- Logging (OUT parameters)
    v_row.param_type:='OUT';
    v_row.proc_name:='REP_SBL_PKG.SBL_PREPAY_CHDP_EXT_WRAP';

    insert into REP_SBL_PKG_LOG
    (proc_name
    ,param_type
    ,insert_time
	,request_id
    ,account_number
    ,prpl_expected
    ,int_expected
    ,principal_overdue
    ,interest_overdue
    ,int_on_ovd_p_accrued
    ,penalty_p
    ,penalty_i
    ,exp_pay_cnt
    ,due_date_on
    ,new_emi
    ,new_psk
    ,last_paym_contr
    ,last_paym_calc
    ,total
    ,customer_name
    ,check_message
    )
    SELECT v_row.proc_name
    ,v_row.param_type
    ,v_insert_time
	,v_request_id
    ,account_number
    ,nvl(p_fccComp_DUE_PRINCIPAL,0)+nvl(p_fccComp_NOTDUE_PRINCIPAL,0) prpl_expected
    ,nvl(p_fccComp_DUE_MAIN_INT,0) int_expected
    ,case when nvl(p_fccComp_OVDUE_PRINCIPAL,0)>=nvl(ln_sum_PRINCIPAL,0) then nvl(p_fccComp_OVDUE_PRINCIPAL,0)-nvl(ln_sum_PRINCIPAL,0) else nvl(p_fccComp_OVDUE_PRINCIPAL,0) end principal_overdue
    ,case when nvl(p_fccComp_OVDUE_MAIN_INT,0)>=nvl(ln_sum_MAIN_INT,0) then nvl(p_fccComp_OVDUE_MAIN_INT,0)-nvl(ln_sum_MAIN_INT,0) else nvl(p_fccComp_OVDUE_MAIN_INT,0) end interest_overdue
    ,case when ln_row_cnt_INT_ON_OVD_P=0 then null
      else case
          when (nvl(p_fccComp_OVDUE_INT_ON_OVD_P,0)+nvl(p_fccComp_DUE_INT_ON_OVD_P,0))-nvl(go_INT_ON_OVD_P_ACCRUED,0)>=0 then
              (nvl(p_fccComp_OVDUE_INT_ON_OVD_P,0)+nvl(p_fccComp_DUE_INT_ON_OVD_P,0))-nvl(go_INT_ON_OVD_P_ACCRUED,0)
          else (nvl(p_fccComp_OVDUE_INT_ON_OVD_P,0)+nvl(p_fccComp_DUE_INT_ON_OVD_P,0))
          end
      end int_on_ovd_p_accrued
    ,case when ln_row_cnt_PENALTY_P=0 then
      null
      else case
          when (nvl(p_fccComp_OVDUE_PENALTY_P,0)+nvl(p_fccComp_DUE_PENALTY_P,0))-nvl(go_PENALTY_P,0)>=0 then
              (nvl(p_fccComp_OVDUE_PENALTY_P,0)+nvl(p_fccComp_DUE_PENALTY_P,0))-nvl(go_PENALTY_P,0)
          else (nvl(p_fccComp_OVDUE_PENALTY_P,0)+nvl(p_fccComp_DUE_PENALTY_P,0))
          end
      end penalty_p
    ,case when ln_row_cnt_PENALTY_I=0 then
      null
      else case
          when (nvl(p_fccComp_OVDUE_PENALTY_I,0)+nvl(p_fccComp_DUE_PENALTY_I,0))-nvl(go_PENALTY_I,0)>=0 then
            (nvl(p_fccComp_OVDUE_PENALTY_I,0)+nvl(p_fccComp_DUE_PENALTY_I,0))-nvl(go_PENALTY_I,0)
          else (nvl(p_fccComp_OVDUE_PENALTY_I,0)+nvl(p_fccComp_DUE_PENALTY_I,0))
          end
      end penalty_i
    ,exp_pay_cnt
    ,due_date_on
    ,new_emi
    ,trunc(new_psk,3) new_psk
    ,last_paym_contr
    ,last_paym_calc
    ,total
    ,customer_name
    ,check_message
    FROM TABLE (rep_sbl_pkg.SBL_PREPAY_CHDP(p_loan_id
                 ,p_date_chdp
                 ,p_sum_chdp
                 ,p_sum_last_pay
                 ,p_fccComp_NOTDUE_PRINCIPAL));
  end if;

  OPEN p_cursor FOR
  SELECT account_number
      ,nvl(p_fccComp_DUE_PRINCIPAL,0)+nvl(p_fccComp_NOTDUE_PRINCIPAL,0) prpl_expected
      ,nvl(p_fccComp_DUE_MAIN_INT,0) int_expected
      ,case when nvl(p_fccComp_OVDUE_PRINCIPAL,0)>=nvl(ln_sum_PRINCIPAL,0) then nvl(p_fccComp_OVDUE_PRINCIPAL,0)-nvl(ln_sum_PRINCIPAL,0) else nvl(p_fccComp_OVDUE_PRINCIPAL,0) end principal_overdue
      ,case when nvl(p_fccComp_OVDUE_MAIN_INT,0)>=nvl(ln_sum_MAIN_INT,0) then nvl(p_fccComp_OVDUE_MAIN_INT,0)-nvl(ln_sum_MAIN_INT,0) else nvl(p_fccComp_OVDUE_MAIN_INT,0) end interest_overdue
      ,case when ln_row_cnt_INT_ON_OVD_P=0 then null
        else case
            when (nvl(p_fccComp_OVDUE_INT_ON_OVD_P,0)+nvl(p_fccComp_DUE_INT_ON_OVD_P,0))-nvl(go_INT_ON_OVD_P_ACCRUED,0)>=0 then
                (nvl(p_fccComp_OVDUE_INT_ON_OVD_P,0)+nvl(p_fccComp_DUE_INT_ON_OVD_P,0))-nvl(go_INT_ON_OVD_P_ACCRUED,0)
            else (nvl(p_fccComp_OVDUE_INT_ON_OVD_P,0)+nvl(p_fccComp_DUE_INT_ON_OVD_P,0))
            end
        end int_on_ovd_p_accrued
      ,case when ln_row_cnt_PENALTY_P=0 then
        null
        else case
            when (nvl(p_fccComp_OVDUE_PENALTY_P,0)+nvl(p_fccComp_DUE_PENALTY_P,0))-nvl(go_PENALTY_P,0)>=0 then
                (nvl(p_fccComp_OVDUE_PENALTY_P,0)+nvl(p_fccComp_DUE_PENALTY_P,0))-nvl(go_PENALTY_P,0)
            else (nvl(p_fccComp_OVDUE_PENALTY_P,0)+nvl(p_fccComp_DUE_PENALTY_P,0))
            end
        end penalty_p
      ,case when ln_row_cnt_PENALTY_I=0 then
        null
        else case
            when (nvl(p_fccComp_OVDUE_PENALTY_I,0)+nvl(p_fccComp_DUE_PENALTY_I,0))-nvl(go_PENALTY_I,0)>=0 then
              (nvl(p_fccComp_OVDUE_PENALTY_I,0)+nvl(p_fccComp_DUE_PENALTY_I,0))-nvl(go_PENALTY_I,0)
            else (nvl(p_fccComp_OVDUE_PENALTY_I,0)+nvl(p_fccComp_DUE_PENALTY_I,0))
            end
        end penalty_i
      /*case when p_fccComp_OVDUE_PENALTY_P is null and p_fccComp_DUE_PENALTY_P is null then
        null
        else nvl(p_fccComp_OVDUE_PENALTY_P,0)+nvl(p_fccComp_DUE_PENALTY_P,0)
        end penalty_p
      ,case when p_fccComp_OVDUE_PENALTY_I is null and p_fccComp_DUE_PENALTY_I is null then
        null
        else nvl(p_fccComp_OVDUE_PENALTY_I,0)+nvl(p_fccComp_DUE_PENALTY_I,0)
        end penalty_i*/
      ,exp_pay_cnt
      ,due_date_on
      ,new_emi
      ,trunc(new_psk,3) new_psk
      ,last_paym_contr
      ,last_paym_calc
      ,total
      ,customer_name
      ,check_message
    FROM TABLE (rep_sbl_pkg.SBL_PREPAY_CHDP(p_loan_id
                 ,p_date_chdp
                 ,p_sum_chdp
                 ,p_sum_last_pay
                 ,p_fccComp_NOTDUE_PRINCIPAL));
    /*SELECT account_number
      ,nvl(p_fccComp_OVDUE_PRINCIPAL,0)+nvl(p_fccComp_NOTDUE_PRINCIPAL,0) prpl_expected
      ,nvl(p_fccComp_NOTDUE_MAIN_INT,0) int_expected
      ,nvl(p_fccComp_OVDUE_PRINCIPAL,0) principal_overdue
      ,nvl(p_fccComp_OVDUE_MAIN_INT,0) interest_overdue
      ,nvl(p_fccComp_OVDUE_INT_ON_OVD_P,0)+nvl(p_fccComp_NOTDUE_INT_ON_OVD_P,0) int_on_ovd_p_accrued
      ,nvl(p_fccComp_OVDUE_PENALTY_P,0)+nvl(p_fccComp_NOTDUE_PENALTY_P,0) penalty_p
      ,nvl(p_fccComp_OVDUE_PENALTY_I,0)+nvl(p_fccComp_NOTDUE_PENALTY_I,0) penalty_i
      ,exp_pay_cnt
      ,due_date_on
      ,new_emi
      ,trunc(new_psk,3) new_psk
      ,last_paym_contr
      ,last_paym_calc
      ,total
      ,customer_name
      ,check_message
    FROM TABLE (rep_sbl_pkg.SBL_PREPAY_CHDP (p_loan_id
                 ,p_date_chdp
                 ,p_sum_chdp
                 ,p_sum_last_pay
                 ,p_fccComp_NOTDUE_PRINCIPAL));*/
  OPEN p_schedule FOR
  SELECT FROM_DATE,
      TO_DATE,
      INT_RATE,
      ACCR_INT,
      INT_EXPECTED,
      INT_PREPAID,
      ADV_REPAYMENT,
      INT_DUE,
      EMI_AMOUNT,
      IS_PRINCIPAL_PAY,
      PRINCIPAL,
      PRPL_EXPECTED,
      TRANCHE,
      EXP_PAY_CNT
    FROM TABLE (rep_sbl_pkg.SBL_PREPAY_CHDP_SCHED(p_date_chdp));
 END IF;

 if (v_is_log = 'Y')
 then
   v_process_time:=SYSTIMESTAMP;

   update REP_SBL_PKG_LOG
   set process_time = v_process_time
   where request_id = v_request_id;
   commit;
 end if;

END sbl_prepay_chdp_ext_wrap;
--
FUNCTION check_percent_rate_SBL (pi_loan_account IN VARCHAR2,
                           pi_payment_plan_date OUT DATE,
                           pi_new_int_rate_date IN DATE,
                           pi_new_int_rate  IN NUMBER,
                           pi_last_paym_sum  IN NUMBER,
                           po_is_buy_back OUT NUMBER) RETURN VARCHAR2
    IS
       lv_retval VARCHAR2(4000);
       ld_today  DATE;
     ld_prev_paym_day DATE;
     ld_val_date DATE;
       lv_branch_code fcc.CLTB_ACCOUNT_MASTER.Branch_code%TYPE;
       lv_product_code fcc.CLTB_ACCOUNT_MASTER.Product_code%TYPE;
       ln_is_buy_back NUMBER;
       ln_cnt NUMBER;
     ln_old_rate NUMBER;
       ln_field_no FCC.CLTM_PRODUCT_UDF.field_no%TYPE;
       FUNCTION add_info_to_ret_val (pi_retval IN VARCHAR2, pi_add_info IN VARCHAR2) RETURN VARCHAR2 IS
       lv_funct_out VARCHAR2(4000);
       BEGIN
            --do not work
            --RETURN nvl2(pi_retval,pi_retval||chr(13)||pi_add_info,pi_add_info);
            --the same
            IF pi_retval='OK' THEN lv_funct_out:=pi_add_info;
            ELSE lv_funct_out:=pi_retval||chr(13)||pi_add_info;
            END IF;
            RETURN lv_funct_out;
       END add_info_to_ret_val;
   BEGIN
     lv_retval:='OK';
     IF length(pi_loan_account)<>18 THEN
        lv_retval:=add_info_to_ret_val (lv_retval, 'Значение параметра "Номер кредита" должно содержать 18 символов, задано '||length(pi_loan_account));
     ELSE
     SELECT count(*) into ln_cnt
     FROM CLTB_ACCOUNT_MASTER
     WHERE ACCOUNT_NUMBER = pi_loan_account;
     if ln_cnt=0
     then lv_retval:='Кредит не найден';
     else
         --get credit params
         SELECT Branch_code, Product_code, value_date
         INTO lv_branch_code, lv_product_code, ld_val_date
         FROM CLTB_ACCOUNT_MASTER
         WHERE ACCOUNT_NUMBER = pi_loan_account;
         --get today for branch
         SELECT today INTO ld_today FROM fcc.sttm_dates
         WHERE Branch_code = lv_branch_code;

         ln_is_buy_back:=0;
         SELECT max(field_no)
         INTO ln_field_no FROM FCC.CLTM_PRODUCT_UDF
         WHERE field_name='BUY_BACK'
         AND product_code=lv_product_code;
         if ln_field_no is not null then
          execute immediate
          'SELECT count(*) FROM CLTB_ACCOUNT_APPS_MASTER
            WHERE account_number='''||pi_loan_account||'''
            AND field_char_'||to_char(ln_field_no)||' = ''YES''' into ln_is_buy_back;
          po_is_buy_back:=ln_is_buy_back;
         else
          po_is_buy_back:=ln_is_buy_back;
         end if;
         IF ln_is_buy_back>0 and nvl(pi_last_paym_sum,0)=0 then  lv_retval:=add_info_to_ret_val (lv_retval, 'Для автокредитов "Buy Back" необходимо указать ненулевое значение параметра "Сумма последнего платежа по договору"'); end if;
         IF ln_is_buy_back=0 and nvl(pi_last_paym_sum,0)>0 then  lv_retval:=add_info_to_ret_val (lv_retval, 'Кредит не является автокредитом "Buy Back" необходимо указать нулевое значение параметра "Сумма последнего платежа по договору"'); end if;
         SELECT max(c.schedule_due_date) INTO pi_payment_plan_date
          FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
          WHERE c.ACCOUNT_NUMBER  = pi_loan_account
          AND C.COMPONENT_NAME = 'PRINCIPAL';
          SELECT MAX(to_date) INTO ld_prev_paym_day FROM
                 (SELECT a.SCHEDULE_ST_DATE from_date, a.SCHEDULE_DUE_DATE to_date, a.amount_due AM_DUE
                  FROM fcc.CLTB_ACCOUNT_SCHEDULES  a
                   WHERE a.ACCOUNT_NUMBER = pi_loan_account
                   AND a.COMPONENT_NAME = 'MAIN_INT'
                   AND a.SCHEDULE_DUE_DATE <= ld_today);
         begin
         SELECT UDE_VALUE into ln_old_rate FROM fcc.CLTB_ACCOUNT_UDE_VALUES
          WHERE ACCOUNT_NUMBER = pi_loan_account
          AND EFFECTIVE_DATE = pi_new_int_rate_date
          AND UDE_ID = 'INTEREST_RATE';
         exception when no_data_found then
          ln_old_rate:=pi_new_int_rate;
         end;
         --проверяем параметры для Ставки
         if pi_new_int_rate_date is null then  lv_retval:=add_info_to_ret_val (lv_retval, 'Должна быть указана дата изменения процентной ставки'); end if;
         if pi_new_int_rate is null then  lv_retval:=add_info_to_ret_val (lv_retval, 'Должно быть указано новое значение процентной ставки'); end if;
         if nvl(ld_prev_paym_day,ld_val_date)>pi_new_int_rate_date then  lv_retval:=add_info_to_ret_val (lv_retval, 'Дата изменения процентной ставки должна быть больше или равна дате последнего платежа по основному долгу ('||nvl(to_char(nvl(ld_prev_paym_day,ld_val_date),'DD.MM.RRRR'),'')||')'); end if;
         if pi_payment_plan_date<=pi_new_int_rate_date then  lv_retval:=add_info_to_ret_val (lv_retval, 'Дата изменения процентной ставки должна быть меньше даты последнего платежа по договору'); end if;
         if ln_old_rate<>pi_new_int_rate then  lv_retval:=add_info_to_ret_val (lv_retval, 'Дата изменения процентной ставки сопадает с уже введенным в FCC значением '||nvl(ln_old_rate,'')); end if;
      end if;
     END IF;
     RETURN lv_retval;
   END check_percent_rate_SBL;

   PROCEDURE fill_percent_rate_SBL(pi_loan_account IN VARCHAR2,
                                  pi_new_int_rate_date IN DATE,
                                  pi_new_int_rate  IN NUMBER,
                                  pi_last_paym_sum  IN NUMBER
                                  )
    IS
   PRAGMA AUTONOMOUS_TRANSACTION;
   lv_current_step VARCHAR2(100);
   lc_char1 CHAR(1);
   ld_SCH_START_DATE DATE;
   ld_min_FROM_DATE DATE;
   ld_max_FROM_DATE DATE;
   ld_min_TO_DATE DATE;
   ld_max_TO_DATE DATE;
   ld_first_FROM_DATE DATE;
   ld_year_last_day DATE;
   ld_branch_day    DATE;
   ld_branch_day2    DATE;
   ln_curr_year_days_cnt NUMBER;
   ln_next_year_days_cnt NUMBER;
   ln_PRPL_EXPECTED_sum NUMBER;
   ln_PRPL_EXPECTED_sum_last NUMBER;
   ln_divisor NUMBER;
   ln_INT_EXPECTED NUMBER;
   ln_INT_DUE     NUMBER;
   ln_principal_overdue NUMBER;
   ln_interest_overdue NUMBER;
   ln_int_on_ovd_p_accrued NUMBER;
   ln_penalty_p NUMBER;
   ln_penalty_i NUMBER;
   lv_check_message     VARCHAR2(4000);
   --ld_today DATE;
   ln_INT_OVD_RATE NUMBER;
   ln_PENALTY_RATE  NUMBER;
   ln_row_cnt NUMBER;
   ---
   gv_branch_code fcc.CLTB_ACCOUNT_MASTER.Branch_code%TYPE;
   gv_customer_no fcc.CLTB_ACCOUNT_MASTER.customer_id%TYPE;
   gv_branch_day fcc.sttm_dates.today%TYPE;
   gd_max_val_date fcc.CLTB_ACCOUNT_MASTER.value_date%TYPE;
   gd_min_adv_rep_to_date DATE;
   gd_max_adv_rep_to_date DATE;
   gn_MIDDLE_PAYMENT NUMBER;
   gn_is_buy_back NUMBER;
   go_PRINCIPAL_OVERDUE NUMBER;
   go_INTEREST_OVERDUE NUMBER;
   go_INT_ON_OVD_P_ACCRUED NUMBER;
   go_PENALTY_P NUMBER;
   go_PENALTY_I NUMBER;
   go_PRPL_EXPECTED NUMBER;
   ln_prev_INT_EXPECTED NUMBER;
   ln_curr_INT_EXPECTED NUMBER;
   ln_curr_EMI_AMOUNT NUMBER;
   ln_curr_ACCR_INT NUMBER;
   ln_prev_ACCR_INT NUMBER;
   pi_payment_plan_date DATE;
   pi_ovd_close_date DATE;
   ln_sum_ADV_REPAYMENT NUMBER;
   ln_sum_hist_ADV_REPAYMENT NUMBER;
   ln_minus_paym NUMBER;
   ln_due_dates_on NUMBER;
   ln_due_dates_on_rep NUMBER;
   ln_orig_st_date NUMBER;
   ld_maturity_date DATE;
   ln_last2_pay_month NUMBER;
   ln_near28_maturity_date NUMBER;
   ln_debug NUMBER;
   ln_prpl_expected_on_first_adv NUMBER;
   ln_all_adv_repay_sum NUMBER;
   ln_current_rate NUMBER;
   ln_new_EMI NUMBER;
   ln_prev_INT_PREPAID NUMBER;
   ln_curr_INT_PREPAID NUMBER;
   ln_curr_INT_DUE NUMBER;
   ln_CALC_last_paym_sum NUMBER;
   BEGIN
      lv_current_step:='Trunc result table';
      execute immediate 'TRUNCATE TABLE rep_sbl_rate';
      execute immediate 'TRUNCATE TABLE rep_sbl_rate_sched';
      --проверяем параметры
      lv_check_message:=check_percent_rate_SBL (pi_loan_account,
                                       pi_payment_plan_date,
                                       pi_new_int_rate_date,
                     pi_new_int_rate,
                     pi_last_paym_sum,
                                       gn_is_buy_back);
      if lv_check_message='OK' then
          --получаем часто используемые значения
          --код отделения, кл. номер, максимальную дату валютирования
          SELECT max(Branch_code), max(customer_id), max(value_date) INTO gv_branch_code, gv_customer_no, gd_max_val_date FROM fcc.CLTB_ACCOUNT_MASTER
          WHERE ACCOUNT_NUMBER = pi_loan_account;
          --опер день отделения
          select today INTO gv_branch_day from fcc.sttm_dates where Branch_code = gv_branch_code;
          pi_ovd_close_date:=gv_branch_day;
          --записываем ФИО клиента
          insert into rep_sbl_rate(customer_name, check_message)
          select NAME_RUS3||' '||NAME_RUS1||' '||NAME_RUS2 as customer_name, lv_check_message as check_message
          from fcc.STTM_CUST_PERSONAL
          where customer_no=gv_customer_no;
          --если параметры нормальны, то формируем данные отчета
          lv_current_step:='Init fill FROM_DATE';
          BEGIN
          --определяем дату начала расписания для детального рассчета
          SELECT MAX(from_date) INTO ld_SCH_START_DATE FROM
             (SELECT a.SCHEDULE_ST_DATE from_date, a.SCHEDULE_DUE_DATE to_date, a.amount_due AM_DUE
                FROM fcc.CLTB_ACCOUNT_SCHEDULES  a
               WHERE a.ACCOUNT_NUMBER = pi_loan_account
                 AND a.COMPONENT_NAME = 'PRINCIPAL'
                 AND a.SCHEDULE_DUE_DATE < gv_branch_day)
                 WHERE AM_DUE <> 0;
          EXCEPTION WHEN NO_DATA_FOUND THEN
            ld_SCH_START_DATE:=null;
          END;
          --end new
          IF ld_SCH_START_DATE is null THEN
            SELECT min(c.SCHEDULE_ST_DATE) FROM_DATE INTO ld_first_FROM_DATE
            FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
            WHERE c.ACCOUNT_NUMBER  = pi_loan_account
            AND C.COMPONENT_NAME = 'PRINCIPAL'
            AND c.SCHEDULE_DUE_DATE < pi_payment_plan_date;
            --new credit
            --если по кредиту не было погашний ОД, то ставим дату валютирования кредита
            IF ld_first_FROM_DATE IS NULL THEN
                --set value date
                ld_first_FROM_DATE:=gd_max_val_date;
            END IF;
            IF ld_first_FROM_DATE IS NOT NULL THEN
                INSERT INTO rep_sbl_rate_sched (FROM_DATE) VALUES (ld_first_FROM_DATE);
            END IF;
          END IF;
          INSERT INTO rep_sbl_rate_sched (FROM_DATE)
            SELECT distinct c.SCHEDULE_DUE_DATE FROM_DATE
            FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
            WHERE c.ACCOUNT_NUMBER  = pi_loan_account
            AND C.COMPONENT_NAME = 'PRINCIPAL'
            AND (c.SCHEDULE_DUE_DATE >= ld_SCH_START_DATE OR ld_SCH_START_DATE is null)
            AND c.SCHEDULE_DUE_DATE <  pi_payment_plan_date;
            COMMIT;
           --формируем полность расписание для детального расчета
           lv_current_step:='Add fill FROM_DATE';
           --добавляем периоды платежей
           SELECT min (FROM_DATE) into ld_min_FROM_DATE FROM rep_sbl_rate_sched;
           IF ld_min_FROM_DATE is not null then
                INSERT INTO rep_sbl_rate_sched (FROM_DATE)
                    SELECT distinct c.VALUE_DATE  FROM_DATE
                    FROM fcc.CLTB_LIQ a, fcc.CLTB_ACCOUNT_EVENTS_PROCESSED b, fcc.cltb_event_entries c
                    WHERE a.ACCOUNT_NUMBER = b.ACCOUNT_NUMBER
                    AND a.ACCOUNT_NUMBER = c.ACCOUNT_NUMBER
                    AND a.EVENT_SEQ_NO = b.EVENT_SEQ_NO
                    AND a.EVENT_SEQ_NO = c.EVENT_SEQ_NO
                    AND a.ACCOUNT_NUMBER = pi_loan_account
                    AND a.INSTALLMENT_PAYMENT = 'N'
                    AND a.VALUE_DATE > ld_min_FROM_DATE
                    AND b.COMPONENT_NAME = 'PRINCIPAL'
                    AND b.EXECUTION_STATUS = 'P'
                    AND a.PAYMENT_STATUS = 'P'  --new
                    AND b.EVENT_CODE = 'MLIQ'
                    AND c.AMOUNT_TAG = 'PRINCIPAL_DLIQ'
                    AND c.VALUE_DATE not in (SELECT FROM_DATE FROM rep_sbl_rate_sched);
            lv_current_step:='Add fill FROM_DATE last date of the year';
            --добавляем переход через год
            FOR rec in (SELECT FROM_DATE FROM rep_sbl_rate_sched WHERE FROM_DATE IS NOT NULL) LOOP
                select add_months(trunc(rec.FROM_DATE, 'YEAR'), 12) - trunc(rec.FROM_DATE, 'YEAR') INTO ln_curr_year_days_cnt from dual;
                select add_months(trunc(add_months(rec.FROM_DATE,12), 'YEAR'), 12) - trunc(add_months(rec.FROM_DATE,12), 'YEAR') INTO ln_next_year_days_cnt from dual;
                IF ln_curr_year_days_cnt=366 or ln_next_year_days_cnt=366 THEN
                    SELECT max(FROM_DATE) into ld_max_FROM_DATE FROM rep_sbl_rate_sched;
                    ld_year_last_day:=least(ld_max_FROM_DATE, add_months(trunc(rec.FROM_DATE, 'YEAR'), 12)-1);
                    BEGIN
                        SELECT 'x' into lc_char1 FROM rep_sbl_rate_sched
                        WHERE FROM_DATE=ld_year_last_day;
                    EXCEPTION WHEN NO_DATA_FOUND THEN
                        INSERT INTO rep_sbl_rate_sched (FROM_DATE) VALUES (ld_year_last_day);
                        COMMIT;
                    END;
                END IF;
            END LOOP;
            --промежуточные максимальная и минимальные границы расписания определены, сохраняем их в переменные
            SELECT min (FROM_DATE), max(FROM_DATE) into ld_min_FROM_DATE, ld_max_FROM_DATE FROM rep_sbl_rate_sched;
            --добавляем периоды измененения процентной ставки
            lv_current_step:='Add fill FROM_DATE rate change dates';
            INSERT INTO rep_sbl_rate_sched (FROM_DATE)
            SELECT distinct EFFECTIVE_DATE FROM fcc.CLTB_ACCOUNT_UDE_VALUES
            WHERE ACCOUNT_NUMBER = pi_loan_account
            AND EFFECTIVE_DATE >= ld_min_FROM_DATE -- мин. дата FROM_DATE
            AND EFFECTIVE_DATE <= ld_max_FROM_DATE -- макс. дата FROM_DATE
            AND UDE_ID = 'INTEREST_RATE'
            AND EFFECTIVE_DATE not in (SELECT FROM_DATE FROM rep_sbl_rate_sched);  --korn 20130322
            COMMIT;
      --дата изменения ставки из параметров
      INSERT INTO rep_sbl_rate_sched (FROM_DATE)
            SELECT pi_new_int_rate_date FROM dual
            WHERE pi_new_int_rate_date not in (SELECT FROM_DATE FROM rep_sbl_rate_sched);  --korn 20130322
            COMMIT;
            --заполняем границы периодов
            lv_current_step:='Fill TO_DATE';
            update rep_sbl_rate_sched c2
            set c2.to_date = nvl((select min(c1.from_date) from rep_sbl_rate_sched c1 where c1.from_date > c2.from_date), null);
            COMMIT;
            update rep_sbl_rate_sched c2
            set c2.to_date = pi_payment_plan_date
            where from_date = (select max(from_date) from rep_sbl_rate_sched);
            COMMIT;
            --окончательные максимальная и минимальные границы расписания определены, пересохраняем их в переменные
            SELECT min (FROM_DATE), max(FROM_DATE) into ld_min_FROM_DATE, ld_max_FROM_DATE FROM rep_sbl_rate_sched;
            --для начала проставим признак того, что в to_date должен быть платеж ОД
            update rep_sbl_rate_sched c set
                    c.IS_PRINCIPAL_PAY = 'Y'
            WHERE EXISTS (
                SELECT 'X'
                 FROM fcc.cltb_account_schedules
                WHERE account_number = pi_loan_account
                AND component_name = 'PRINCIPAL'
                AND schedule_due_date=c.TO_DATE);
            COMMIT;
            --добавляем досрочно погашенные проценты
            lv_current_step:='Fill INT_PREPAID';
            FOR rec in (SELECT TO_DATE FROM rep_sbl_rate_sched WHERE TO_DATE IS NOT NULL ORDER BY TO_DATE) LOOP
                for cur_var in (SELECT a.VALUE_DATE VALUE_DATE, sum(c.AMOUNT) INT_PREPAID
                                 FROM fcc.CLTB_LIQ a, fcc.CLTB_ACCOUNT_EVENTS_PROCESSED b, fcc.cltb_event_entries c
                                 WHERE a.ACCOUNT_NUMBER = b.ACCOUNT_NUMBER
                                 AND a.ACCOUNT_NUMBER = c.ACCOUNT_NUMBER
                                 AND b.COMPONENT_NAME = c.COMPONENT_NAME
                                 AND a.EVENT_SEQ_NO = b.EVENT_SEQ_NO
                                 AND a.EVENT_SEQ_NO = c.EVENT_SEQ_NO
                                 AND a.ACCOUNT_NUMBER = pi_loan_account
                                 AND a.INSTALLMENT_PAYMENT = 'N'
                                 AND a.VALUE_DATE >=rec.TO_DATE
                                 --досрочка только между платежами
                                 AND a.VALUE_DATE not in (select TO_DATE from rep_sbl_rate_sched where IS_PRINCIPAL_PAY = 'Y')
                                 AND b.COMPONENT_NAME ='MAIN_INT'
                                 AND b.EXECUTION_STATUS = 'P'
                                 AND a.PAYMENT_STATUS = 'P'  --new
                                 AND c.AMOUNT_TAG = 'MAIN_INT_DLIQ'
                                 AND b.EVENT_CODE = 'MLIQ'
                                 group by a.VALUE_DATE
                                order by VALUE_DATE) loop
                    update rep_sbl_rate_sched set INT_PREPAID = cur_var.INT_PREPAID where TO_DATE = cur_var.VALUE_DATE;
                end loop;
            END LOOP;
            COMMIT;
            --если кредит выдавался несколькими траншами, то заполняем их значения
            lv_current_step:='Fill TRANCHE';
            FOR rec in (SELECT TO_DATE, FROM_DATE FROM rep_sbl_rate_sched WHERE TO_DATE IS NOT NULL ORDER BY TO_DATE) LOOP
                for cur_var in (select VALUE_DATE VALUE_DATE, sum(AMOUNT) TRANCHE from fcc.cltb_event_entries
                                WHERE ACCOUNT_NUMBER = pi_loan_account
                                AND EVENT_CODE = 'VAMI'
                                AND VALUE_DATE between rec.FROM_DATE and rec.TO_DATE
                                group by VALUE_DATE) loop
                    update rep_sbl_rate_sched set TRANCHE = cur_var.TRANCHE where TO_DATE = rec.TO_DATE;
                end loop;
            END LOOP;
            COMMIT;
            --заполняем периоды процентными ставками
            lv_current_step:='Fill RATE';
            FOR rec in (SELECT TO_DATE FROM rep_sbl_rate_sched WHERE TO_DATE IS NOT NULL ORDER BY TO_DATE) LOOP
                for cur_var in (SELECT EFFECTIVE_DATE, UDE_VALUE RATE FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                WHERE ACCOUNT_NUMBER = pi_loan_account
                                AND EFFECTIVE_DATE<=rec.TO_DATE
                                AND UDE_ID = 'INTEREST_RATE'
                                order by EFFECTIVE_DATE) loop
                    update rep_sbl_rate_sched set INT_RATE = cur_var.RATE where TO_DATE = rec.TO_DATE;
                end loop;
            END LOOP;
            COMMIT;
      update rep_sbl_rate_sched
      set INT_RATE=pi_new_int_rate
      WHERE FROM_DATE>=pi_new_int_rate_date;
            COMMIT;
      --сохраняем текущую ставку
            for cur_var in (SELECT EFFECTIVE_DATE, UDE_VALUE RATE FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                WHERE ACCOUNT_NUMBER = pi_loan_account
                                AND EFFECTIVE_DATE<=gv_branch_day
                                AND UDE_ID = 'INTEREST_RATE'
                                order by EFFECTIVE_DATE) loop
                    ln_current_rate:= cur_var.RATE;
            end loop;
            --заполняем количество оставшихся платежей для всех периодов, пригодится для аннуитета
            update rep_sbl_rate_sched с1
            set с1.EXP_PAY_CNT= (SELECT count(*)
                                FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
                                WHERE c.ACCOUNT_NUMBER  = pi_loan_account
                                AND c.COMPONENT_NAME = 'MAIN_INT'
                                AND c.schedule_due_date > с1.TO_DATE);
            --20140411 новая доработка для вычитания последнего платежа
            --получаем DUE_DATES_ON
            BEGIN
                select due_dates_on into ln_due_dates_on from CLTB_ACCOUNT_COMP_SCH s
                 where ACCOUNT_NUMBER = pi_loan_account
                 and component_name = 'MAIN_INT'
                 and sch_end_date in (select to_date from rep_sbl_rate_sched
                                    where EXP_PAY_CNT=1); --предпоследний платеж
            EXCEPTION when no_data_found THEN
                ln_due_dates_on:=null;
            END;
            SELECT  nvl(ln_due_dates_on, extract(DAY from value_date)),
                    extract(DAY from ORIGINAL_ST_DATE),
                    maturity_date
            INTO ln_due_dates_on, ln_orig_st_date, ld_maturity_date
            FROM CLTB_ACCOUNT_MASTER
            WHERE ACCOUNT_NUMBER = pi_loan_account;
--            SELECT count(*) INTO ln_near28_maturity_date
--                                FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
--                                WHERE c.ACCOUNT_NUMBER  = pi_loan_account
--                                AND c.COMPONENT_NAME = 'MAIN_INT'
--                                AND c.schedule_due_date >=ld_maturity_date-28
--                                AND c.schedule_due_date < ld_maturity_date;
            SELECT COUNT(DISTINCT pay_month) INTO ln_last2_pay_month
                FROM
                (SELECT trunc(max(c.schedule_due_date),'month') pay_month
                                    FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
                                    WHERE c.ACCOUNT_NUMBER  = pi_loan_account
                                    AND c.COMPONENT_NAME = 'MAIN_INT'
                                    AND c.schedule_due_date < ld_maturity_date
                UNION ALL
                SELECT trunc(ld_maturity_date, 'month') pay_month FROM dual);
            -- PRB22107 06.05.20 Вычитание последнего платежа только для случая, когда 2 последних платежа попадают на один месяц
            if ln_last2_pay_month=1 then ln_minus_paym:=1;
            else ln_minus_paym:=0;
            end if;
            --Если  DD в поле Original St. Date <= значения Due Dates On (по каким дням платить), и 2 последних платежа попадают на 1 месяц, то не учитываем последний платеж, если 2 последних платежа не попадают в 1 месяц, то платеж Maturity Date, учитывается при подсчете числа предстоящих платежей
            --Если  DD в поле Original St. Date > значения Due Dates On (по каким дням платить) и 2 последних платежа попадают на 1 месяц, то не учитываем последний платеж, если 2 последних платежа не попадают в 1 месяц, то:
                         --Если в течении 28 дней до даты Maturity Date, есть платеж, то платеж Maturity Date не учитывается при подсчете числа предстоящих платежей
                         --Если в течении 28 дней до даты Maturity Date, нет платежей, то платеж Maturity Date учитывается при подсчете числа предстоящих платежей
--            if ln_orig_st_date<=ln_due_dates_on then
--                if ln_last2_pay_month=1 then ln_minus_paym:=1;
--                else ln_minus_paym:=0;
--                end if;
--            elsif ln_orig_st_date>ln_due_dates_on then
--                if ln_last2_pay_month=1 then ln_minus_paym:=1;
--                else
--                    if ln_near28_maturity_date>0 then  ln_minus_paym:=1;
--                    else ln_minus_paym:=0;
--                    end if;
--                end if;
--            else  ln_minus_paym:=0;
--            end if;
            --end 20140411
      BEGIN
        select due_dates_on into ln_due_dates_on_rep from
        (select due_dates_on from CLTB_ACCOUNT_COMP_SCH s
                 where ACCOUNT_NUMBER = pi_loan_account
                 and component_name = 'MAIN_INT'
         and due_dates_on is not null
         order by sch_end_date desc)
        WHERE rownum=1;
            EXCEPTION when no_data_found THEN
                ln_due_dates_on_rep:=ln_due_dates_on;
            END;
        -- Убрала обнуление ln_minus_paym  Polischuk NA REQ000367527 210317
        --ln_minus_paym:=0; --korn20171030
        --немного прервемся на расчет просроченной задолженности
        lv_current_step:='Fill overdue info';
        ln_principal_overdue:=0;
        ln_interest_overdue:=0;
        ln_int_on_ovd_p_accrued:=0;
        ln_penalty_p:=0;
        ln_penalty_i:=0;
        IF pi_ovd_close_date IS NOT NULL THEN
          SELECT   NVL (
                        SUM(CASE
                            WHEN (component_name = 'PRINCIPAL'
                             AND schedule_due_date < pi_ovd_close_date) --до даты планового погашения просрочки
                             THEN
                                 amount_due - NVL (amount_settled, 0)
                             ELSE
                                 0
                             END),
                       0)
                  principal_overdue INTO ln_principal_overdue
            FROM   fcc.cltb_account_schedules
           WHERE   account_number = pi_loan_account;
                  ---------------------------------
                SELECT   NVL (
                             SUM(CASE
                                     WHEN (component_name = 'MAIN_INT'
                                           AND schedule_due_date < pi_ovd_close_date) --до даты планового погашения просрочки
                                     THEN
                                         NVL (accrued_amount, 0) - NVL (amount_settled, 0)
                                     ELSE
                                         0
                                 END),
                             0)
                             interest_overdue  INTO ln_interest_overdue
                  FROM   fcc.cltb_account_schedules
                 WHERE   account_number = pi_loan_account;
                  ---------------------------------
                SELECT   NVL (
                             SUM(CASE
                                     WHEN (component_name = 'INT_ON_OVD_P'
                                           AND schedule_due_date >= gv_branch_day) --после текущего опер дня
                                     THEN
                                         NVL (amount_due, 0) - NVL (amount_settled, 0)
                                     ELSE
                                         0
                                 END),
                             0)
                             int_on_ovd_p_accrued INTO ln_int_on_ovd_p_accrued
                  FROM   fcc.cltb_account_schedules
                 WHERE   account_number = pi_loan_account;
                  ---------------------------------
                SELECT   NVL (
                             SUM(CASE
                                     WHEN (component_name = 'PENALTY_P'
                                           AND schedule_due_date <= pi_ovd_close_date) --до даты планового погашения просрочки
                                     THEN
                                         NVL (amount_due, 0) - NVL (amount_settled, 0)
                                     ELSE
                                         0
                                 END),
                             0)
                             penalty_p INTO ln_penalty_p
                  FROM   fcc.cltb_account_schedules
                 WHERE   account_number = pi_loan_account;
                  ---------------------------------
                SELECT   NVL (
                             SUM(CASE
                                     WHEN (component_name = 'PENALTY_I'
                                           AND schedule_due_date <= pi_ovd_close_date)
                                     THEN
                                         NVL (amount_due, 0) - NVL (amount_settled, 0)
                                     ELSE
                                         0
                                 END),
                             0)
                             penalty_i INTO ln_penalty_i
                  FROM   fcc.cltb_account_schedules
                 WHERE   account_number = pi_loan_account;
                END IF;
            --Получаем ставки по кторым считаются штрафы
            BEGIN
                SELECT nvl(UDE_VALUE,0) RATE INTO ln_INT_OVD_RATE FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                         WHERE ACCOUNT_NUMBER = pi_loan_account
                                          AND EFFECTIVE_DATE=(SELECT max(EFFECTIVE_DATE) FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                                               WHERE ACCOUNT_NUMBER = pi_loan_account
                                                               AND EFFECTIVE_DATE<=pi_ovd_close_date
                                                               AND UDE_ID = 'INT_OVD_RATE')
                                         AND UDE_ID = 'INT_OVD_RATE';
            EXCEPTION WHEN NO_DATA_FOUND THEN
                ln_INT_OVD_RATE:=0;
            END;
            BEGIN
                SELECT nvl(UDE_VALUE,0) RATE INTO ln_PENALTY_RATE FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                         WHERE ACCOUNT_NUMBER = pi_loan_account
                                          AND EFFECTIVE_DATE=(SELECT max(EFFECTIVE_DATE) FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                                                               WHERE ACCOUNT_NUMBER = pi_loan_account
                                                               AND EFFECTIVE_DATE<=pi_ovd_close_date
                                                               AND UDE_ID = 'PENALTY_RATE')
                                         AND UDE_ID = 'PENALTY_RATE';
            EXCEPTION WHEN NO_DATA_FOUND THEN
                ln_PENALTY_RATE:=0;
            END;
            --посчитали просрочку для вывода в отчет
      go_PRINCIPAL_OVERDUE:=nvl(ln_principal_overdue,0);
      go_INTEREST_OVERDUE:=nvl(ln_interest_overdue,0);
      --Leila K. Izmailova - 28.09.2017 13:56
      go_INT_ON_OVD_P_ACCRUED:=null;
      ----------------------
      SELECT  count(*) into ln_row_cnt FROM fcc.cltb_account_schedules
      WHERE   account_number = pi_loan_account
      AND component_name='PENALTY_P';
            if ln_row_cnt=0 then
        go_PENALTY_P:=null;
      else
        go_PENALTY_P:=round(nvl(ln_penalty_p,0)+nvl(ln_principal_overdue,0)*(ln_PENALTY_RATE/100)*(pi_ovd_close_date-gv_branch_day),2);
      end if;
      ----------------------
      SELECT  count(*) into ln_row_cnt FROM fcc.cltb_account_schedules
      WHERE   account_number = pi_loan_account
      AND component_name='PENALTY_I';
            if ln_row_cnt=0 then
        go_PENALTY_I:=null;
      else
        go_PENALTY_I:=round(nvl(ln_penalty_i,0)+nvl(ln_interest_overdue,0)*(ln_PENALTY_RATE/100)*(pi_ovd_close_date-gv_branch_day),2);
      end if;
      --END Leila K. Izmailova - 28.09.2017 13:56

            --и забыли о ней до вывода)
            --самое сложное)
            --вычисляем минимальную дату ЧДП
            lv_current_step:='Fill PRINCIPAL before AVD_REP';
      gd_min_adv_rep_to_date:=pi_new_int_rate_date;
      gd_max_adv_rep_to_date:=pi_new_int_rate_date;
      --Для начала считаем платежи ОД для всех дат до первого ЧДП
      lv_current_step:='Fill PRINCIPAL';
      FOR rec in (SELECT a.TO_DATE FROM rep_sbl_rate_sched a
                   WHERE a.TO_DATE IS NOT NULL
                     AND a.TO_DATE<=gd_min_adv_rep_to_date--gv_branch_day
                   ORDER BY a.TO_DATE) LOOP
            --досрочка
        for cur_var in (SELECT a.VALUE_DATE VALUE_DATE, sum(c.AMOUNT) PRINCIPAL
                          FROM fcc.CLTB_LIQ a, fcc.CLTB_ACCOUNT_EVENTS_PROCESSED b, fcc.cltb_event_entries c
                         WHERE a.ACCOUNT_NUMBER = b.ACCOUNT_NUMBER
                           AND a.ACCOUNT_NUMBER = c.ACCOUNT_NUMBER
                           AND b.COMPONENT_NAME = c.COMPONENT_NAME
                           AND a.EVENT_SEQ_NO = b.EVENT_SEQ_NO
                           AND a.EVENT_SEQ_NO = c.EVENT_SEQ_NO
                           AND a.ACCOUNT_NUMBER = pi_loan_account
                         --AND a. INSTALLMENT_PAYMENT = 'N'
                           AND a. VALUE_DATE >= rec.TO_DATE
                           AND b.COMPONENT_NAME ='PRINCIPAL'
                           AND b.EXECUTION_STATUS = 'P'
                           AND a.PAYMENT_STATUS = 'P'  --new
                           AND c.AMOUNT_TAG = 'PRINCIPAL_DLIQ'
                         --AND b.EVENT_CODE = 'MLIQ'
                         group by a.VALUE_DATE --korn20130606
                         order by VALUE_DATE) loop
             update rep_sbl_rate_sched set PRINCIPAL = cur_var.PRINCIPAL where TO_DATE = cur_var.VALUE_DATE;
        end loop;
      END LOOP;
      COMMIT;
      --заполняем ВСЕ расписание как есть по данным FCC
      lv_current_step:='Fill EMI_AMOUNT before AVD_REP';
      FOR rec in (SELECT TO_DATE FROM rep_sbl_rate_sched
                   ORDER BY TO_DATE) LOOP
      --ставим текущий аннуитет и начисленные проценты
        for cur_var in (SELECT a.SCHEDULE_DUE_DATE, a.EMI_AMOUNT, a.AMOUNT_DUE
                          FROM fcc.CLTB_ACCOUNT_SCHEDULES a
                         WHERE a.ACCOUNT_NUMBER  = pi_loan_account
                           AND a.SCHEDULE_DUE_DATE >= rec.TO_DATE
                           AND a.SCHEDULE_DUE_DATE <= pi_payment_plan_date
                           AND a.COMPONENT_NAME = 'MAIN_INT'
                         order by a.SCHEDULE_DUE_DATE) loop
           update rep_sbl_rate_sched set EMI_AMOUNT = cur_var.EMI_AMOUNT,
                                         ACCR_INT   = cur_var.AMOUNT_DUE
            where TO_DATE = cur_var.SCHEDULE_DUE_DATE;
        end loop;
        --ставим текущие платежи по ОД
        for cur_var in (SELECT a.SCHEDULE_DUE_DATE, a.AMOUNT_DUE
                          FROM fcc.CLTB_ACCOUNT_SCHEDULES a
                         WHERE a.ACCOUNT_NUMBER  = pi_loan_account
                           AND a.SCHEDULE_DUE_DATE = rec.TO_DATE
                           AND a.COMPONENT_NAME = 'PRINCIPAL'
                         order by a.SCHEDULE_DUE_DATE) loop
            update rep_sbl_rate_sched set PRINCIPAL = cur_var.AMOUNT_DUE
            where TO_DATE = cur_var.SCHEDULE_DUE_DATE;
        end loop;
        --считаем ОД
        update rep_sbl_rate_sched set PRPL_EXPECTED = nvl(PRINCIPAL,0)+(SELECT nvl(b.balance,0)
          FROM fcc.CLTBS_ACCOUNT_COMP_BALANCES b
         WHERE b.account_number = pi_loan_account
           and b.component_name = 'PRINCIPAL_EXPECTED'
           AND b.val_date=(select max(val_date)
                             FROM   fcc.CLTBS_ACCOUNT_COMP_BALANCES b
                            WHERE   b.account_number = pi_loan_account
                              and b.component_name = 'PRINCIPAL_EXPECTED'
                              AND b.val_date<=rec.TO_DATE)
                           )

            where TO_DATE = rec.TO_DATE;
      END LOOP;
      COMMIT;
      ---korn20180226
      --пересчитываем все расписание до даты изменения ставки или разрыва периодов
      FOR rec in (SELECT FROM_DATE, TO_DATE, IS_PRINCIPAL_PAY, EXP_PAY_CNT, nvl(EMI_AMOUNT,0) EMI_AMOUNT FROM rep_sbl_rate_sched
                   where TO_DATE <= pi_new_int_rate_date
                   ORDER BY FROM_DATE) LOOP
        --считаем  начисленные проценты
        select add_months(trunc(rec.FROM_DATE+1, 'YEAR'), 12) - trunc(rec.FROM_DATE+1, 'YEAR') INTO ln_curr_year_days_cnt from dual;
        IF ln_curr_year_days_cnt=365 THEN ln_divisor:=36500;
        ELSE  ln_divisor:=36600;
        END IF;
        update rep_sbl_rate_sched set ACCR_INT = ROUND(PRPL_EXPECTED*INT_RATE*(TO_DATE-FROM_DATE)/ln_divisor,2) where FROM_DATE = rec.FROM_DATE;
        COMMIT;
        --получаем отложенные проценты из предыдущей даты
        begin
          select nvl(INT_EXPECTED,0) into ln_prev_INT_EXPECTED from rep_sbl_rate_sched where TO_DATE = rec.FROM_DATE;
        exception when no_data_found then
          ln_prev_INT_EXPECTED:=0;
        end;
        --получаем начисленные проценты за период с предыдущего платежа
        begin
          select nvl(ACCR_INT,0)+nvl(ln_prev_ACCR_INT,0), nvl(INT_PREPAID,0) into ln_curr_ACCR_INT, ln_curr_INT_PREPAID from rep_sbl_rate_sched where FROM_DATE = rec.FROM_DATE;
        exception when no_data_found then
          ln_curr_ACCR_INT:=0+nvl(ln_prev_ACCR_INT,0);
          ln_curr_INT_PREPAID:=0;
        end;
        --если есть платеж по ОД, то ставим INT_DUE
        if rec.IS_PRINCIPAL_PAY='Y' or rec.TO_DATE = pi_new_int_rate_date then
          --если начисленные проценты минус предоплаченные больше аннуитета, то естави его и разницу переносим в отложенные проценты
          ln_curr_INT_DUE:=nvl(ln_curr_ACCR_INT,0)+nvl(ln_prev_INT_EXPECTED,0)-nvl(ln_curr_INT_PREPAID,0);
          --если INT_DUE<0 ставим 0, переносим разинцу в следующий INT_PREPAID
          --если INT_DUE> аннуитета ставим его и переносим разницу в INT_EXPECTED
          --если меньше, то ставим INT_DUE
          if ln_curr_INT_DUE<0 then
            update rep_sbl_rate_sched
               set INT_DUE = 0,
                   INT_EXPECTED = 0
              where FROM_DATE = rec.FROM_DATE;
            update rep_sbl_rate_sched
               set INT_PREPAID = nvl(ln_curr_INT_PREPAID,0)-(nvl(ln_curr_ACCR_INT,0)+nvl(ln_prev_INT_EXPECTED,0))
             where FROM_DATE = rec.TO_DATE;
          else
             update rep_sbl_rate_sched
                set INT_DUE = case when ln_curr_INT_DUE>rec.EMI_AMOUNT
                              then rec.EMI_AMOUNT
                              else ln_curr_INT_DUE
                               end,
                    INT_EXPECTED = case when ln_curr_INT_DUE>rec.EMI_AMOUNT
                                   then ln_curr_INT_DUE-rec.EMI_AMOUNT
                                   else 0
                                    end
               where FROM_DATE = rec.FROM_DATE;
          end if;
          --меняем платеж по основному долгу
          update rep_sbl_rate_sched
             set PRINCIPAL = nvl(EMI_AMOUNT,0)-nvl(INT_DUE,0)
           where FROM_DATE = rec.FROM_DATE;
          ln_prev_ACCR_INT:=0;
        else
          --запоминаем ln_curr_ACCR_INT
          ln_prev_ACCR_INT:=nvl(ln_prev_ACCR_INT,0)+nvl(ln_curr_ACCR_INT,0);
        end if;
          --меняем остаток основного долга на следующую дату
          update rep_sbl_rate_sched
            set PRPL_EXPECTED = nvl((SELECT SUM (PRPL_EXPECTED)-SUM(nvl(PRINCIPAL,0))-SUM(nvl(ADV_REPAYMENT,0)) FROM rep_sbl_rate_sched WHERE FROM_DATE <> TO_DATE AND FROM_DATE = rec.FROM_DATE),0)
                                                                  +nvl(TRANCHE,0)
          where FROM_DATE = rec.TO_DATE;
      END LOOP;
      --ln_sum_hist_ADV_REPAYMENT:=0;

      -- Add Polischuk NA REQ000367527 210317
      -- Если кредит buy_back, то берем исходный последний платеж зафиксированный зибелем и вычитаем все сделанные ЧДП
      if gn_is_buy_back>0 then
        begin
          select SUM_LAST_PAY into ln_CALC_last_paym_sum from SIEBEL.SX_O@SBLREP.IMB.RU
           where CREDIT_NUM= pi_loan_account;
        exception when no_data_found then
           ln_CALC_last_paym_sum := pi_last_paym_sum;
        end;
      end if;
      --считаем ЧДП, которые клиент уже сделал ЧДП сделанные "задним числом"
      SELECT nvl((SELECT SUM(nvl(AMOUNT_PAID,0))
                    FROM fcc.CLTB_AMOUNT_PAID A
                   WHERE branch_code = gv_branch_code
                     AND ACCOUNT_NUMBER = pi_loan_account
                     AND COMPONENT_NAME = 'PRINCIPAL' AND PAID_STATUS = 'P'
                     AND paid_date <=gd_min_adv_rep_to_date
                     AND EXISTS (SELECT 1
                                   FROM fcc.cltb_liq B
                                    WHERE branch_code = A.BRANCH_CODE
                                      AND account_number = A.ACCOUNT_NUMBER
                                      AND EVENT_SEQ_NO = A.EVENT_SEQ_NO
                                      AND execution_date = gv_branch_day
                                      AND payment_status = 'P'
                                      AND auth_stat = 'A')),0)
               --ЧДП сделанные обычным способом до опердня
                +nvl((select sum(nvl(chpd.chdp_amount,0)-nvl(princ.princ_amount,0)) chdp_amount_cleared
                        from (SELECT a.VALUE_DATE, sum(nvl(c.AMOUNT,0)) chdp_amount
                               FROM fcc.CLTB_LIQ a, fcc.CLTB_ACCOUNT_EVENTS_PROCESSED b, fcc.cltb_event_entries c
                              WHERE a.ACCOUNT_NUMBER = b.ACCOUNT_NUMBER
                                AND a.ACCOUNT_NUMBER = c.ACCOUNT_NUMBER
                                AND a.EVENT_SEQ_NO = b.EVENT_SEQ_NO
                                AND a.EVENT_SEQ_NO = c.EVENT_SEQ_NO
                                AND a.ACCOUNT_NUMBER = pi_loan_account
                                AND a.INSTALLMENT_PAYMENT = 'N'
                                AND b.COMPONENT_NAME = 'PRINCIPAL'
                                AND b.EXECUTION_STATUS = 'P'
                                AND a.PAYMENT_STATUS = 'P'
                                AND b.EVENT_CODE = 'MLIQ'
                                AND c.AMOUNT_TAG = 'PRINCIPAL_DLIQ'
                                AND a.VALUE_DATE <gv_branch_day
                                GROUP BY a.VALUE_DATE) chpd
                              left join
                            (SELECT schedule_due_date VALUE_DATE, sum(nvl(amount_settled,0)) princ_amount
                               FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
                              WHERE c.ACCOUNT_NUMBER  = pi_loan_account
                                 AND c.COMPONENT_NAME = 'PRINCIPAL'
                               group by schedule_due_date) princ
                             on chpd.VALUE_DATE=princ.VALUE_DATE)
                     ,0)
         INTO ln_sum_hist_ADV_REPAYMENT
      FROM DUAL;
      --считаем новый аннуитет
      update rep_sbl_rate_sched c1 set EMI_AMOUNT = calc_emi (gn_is_buy_back,
                                                              c1.PRPL_EXPECTED,
                                                              c1.INT_RATE,
                                                              ln_CALC_last_paym_sum,
                                                              GREATEST(((select EXP_PAY_CNT FROM rep_sbl_rate_sched s where s.TO_DATE = c1.FROM_DATE) - ln_minus_paym),0), -- Polischuk 24112020 INC000682119
                                                              --ЧДП указанные в отчете
                                                              nvl((SELECT SUM(nvl(ADV_REPAYMENT,0)) FROM rep_sbl_rate_sched c
                                                                    WHERE c.TO_DATE <= c1.TO_DATE),0)
                                                               --ЧДП до опердня
                                                               +nvl(ln_sum_hist_ADV_REPAYMENT,0)
                                                              )
         where FROM_DATE = pi_new_int_rate_date;
      commit;
      --копируем его на все даты после
      update rep_sbl_rate_sched c1 set EMI_AMOUNT = (SELECT EMI_AMOUNT FROM rep_sbl_rate_sched where FROM_DATE = pi_new_int_rate_date)
            where FROM_DATE>pi_new_int_rate_date
      and IS_PRINCIPAL_PAY='Y';
            commit;
      --пересчитываем все расписание с даты изменения ставки или разрыва периодов
      FOR rec in (SELECT FROM_DATE, TO_DATE, IS_PRINCIPAL_PAY, EXP_PAY_CNT, nvl(EMI_AMOUNT,0) EMI_AMOUNT FROM rep_sbl_rate_sched
                  where FROM_DATE >= pi_new_int_rate_date
                  ORDER BY FROM_DATE) LOOP
        --считаем  начисленные проценты
        select add_months(trunc(rec.FROM_DATE+1, 'YEAR'), 12) - trunc(rec.FROM_DATE+1, 'YEAR') INTO ln_curr_year_days_cnt from dual;
        IF ln_curr_year_days_cnt=365 THEN ln_divisor:=36500;
        ELSE  ln_divisor:=36600;
        END IF;
        update rep_sbl_rate_sched set ACCR_INT = ROUND(PRPL_EXPECTED*INT_RATE*(TO_DATE-FROM_DATE)/ln_divisor,2) where FROM_DATE = rec.FROM_DATE;
        COMMIT;
        --получаем отложенные проценты из предыдущей даты
        begin
          select nvl(INT_EXPECTED,0) into ln_prev_INT_EXPECTED from rep_sbl_rate_sched where TO_DATE = rec.FROM_DATE;
        exception when no_data_found then
          ln_prev_INT_EXPECTED:=0;
        end;
        --получаем начисленные проценты за период с предыдущего платежа
        begin
          select nvl(ACCR_INT,0)+nvl(ln_prev_ACCR_INT,0), nvl(INT_PREPAID,0) into ln_curr_ACCR_INT, ln_curr_INT_PREPAID from rep_sbl_rate_sched where FROM_DATE = rec.FROM_DATE;
        exception when no_data_found then
          ln_curr_ACCR_INT:=0+nvl(ln_prev_ACCR_INT,0);
          ln_curr_INT_PREPAID:=0;
        end;
        --если есть платеж по ОД, то ставим INT_DUE
        if rec.IS_PRINCIPAL_PAY='Y' then
          --если начисленные проценты минус предоплаченные больше аннуитета, то естави его и разницу переносим в отложенные проценты
          ln_curr_INT_DUE:=nvl(ln_curr_ACCR_INT,0)+nvl(ln_prev_INT_EXPECTED,0)-nvl(ln_curr_INT_PREPAID,0);
          --если INT_DUE<0 ставим 0, переносим разинцу в следующий INT_PREPAID
          --если INT_DUE> аннуитета ставим его и переносим разницу в INT_EXPECTED
          --если меньше, то ставим INT_DUE
          if ln_curr_INT_DUE<0 then
            update rep_sbl_rate_sched
               set INT_DUE = 0,
                   INT_EXPECTED = 0
             where FROM_DATE = rec.FROM_DATE;
            update rep_sbl_rate_sched
               set INT_PREPAID = nvl(ln_curr_INT_PREPAID,0)-(nvl(ln_curr_ACCR_INT,0)+nvl(ln_prev_INT_EXPECTED,0))
             where FROM_DATE = rec.TO_DATE;
          else
            update rep_sbl_rate_sched
               set INT_DUE = case when ln_curr_INT_DUE>rec.EMI_AMOUNT
                             then rec.EMI_AMOUNT
                             else ln_curr_INT_DUE
                              end,
                   INT_EXPECTED = case when ln_curr_INT_DUE>rec.EMI_AMOUNT
                                  then ln_curr_INT_DUE-rec.EMI_AMOUNT
                                  else 0
                                   end
              where FROM_DATE = rec.FROM_DATE;
          end if;
          --меняем платеж по основному долгу
          update rep_sbl_rate_sched
             set PRINCIPAL = nvl(EMI_AMOUNT,0)-nvl(INT_DUE,0)
           where FROM_DATE = rec.FROM_DATE;
          ln_prev_ACCR_INT:=0;
        else
          --запоминаем ln_curr_ACCR_INT
            ln_prev_ACCR_INT:=nvl(ln_prev_ACCR_INT,0)+nvl(ln_curr_ACCR_INT,0);
        end if;
        --меняем остаток основного долга на следующую дату
        update rep_sbl_rate_sched
           set PRPL_EXPECTED = nvl((SELECT SUM (PRPL_EXPECTED)-SUM(nvl(PRINCIPAL,0))-SUM(nvl(ADV_REPAYMENT,0)) FROM rep_sbl_rate_sched WHERE FROM_DATE <> TO_DATE AND FROM_DATE = rec.FROM_DATE),0)
                                                                  +nvl(TRANCHE,0)
        where FROM_DATE = rec.TO_DATE;
      END LOOP;
      ---новая проверка
      DELETE FROM rep_sbl_rate_sched
       WHERE PRPL_EXPECTED<0;
      COMMIT;
      --формируем итоги
      INSERT INTO rep_sbl_rate
           (account_number,
             prpl_expected,
             int_expected,
             principal_overdue,
             interest_overdue,
             int_on_ovd_p_accrued,
             penalty_p,
             penalty_i,
             exp_pay_cnt,
             due_date_on,
             new_emi,
             last_paym_contr,
             last_paym_calc,
             int_rate,
             new_int_rate,
             new_int_rate_date
            )
      VALUES
            (pi_loan_account, --account_number
             /*nvl((SELECT sum(nvl(PRPL_EXPECTED,0))
                FROM rep_sbl_rate_sched
                WHERE from_date=gd_max_adv_rep_to_date),0),*/ --prpl_expected
             nvl((SELECT sum(nvl(PRPL_EXPECTED,0))
                FROM rep_sbl_rate_sched
                WHERE to_date=pi_new_int_rate_date),0), --prpl_expected
             nvl((SELECT sum(nvl(ACCR_INT,0))
                FROM rep_sbl_rate_sched
                WHERE to_date=pi_new_int_rate_date),0), -- int_expected
             --вместо процентов будем выподить последнюю процентную ставку
             --nvl((SELECT max(nvl(INT_RATE,0))
             --   FROM rep_sbl_rate_sched
             --   WHERE from_date=gd_max_adv_rep_to_date/*(SELECT max(from_date) FROM rep_sbl_rate_sched)*/),0), --inr_rate
             /*nvl((SELECT sum(nvl(INT_EXPECTED,0))
                FROM rep_sbl_rate_sched
                WHERE from_date=ld_max_FROM_DATE),0), --int_expected*/
             go_PRINCIPAL_OVERDUE, --principal_overdue
             go_INTEREST_OVERDUE, --interest_overdue
             go_INT_ON_OVD_P_ACCRUED, --int_on_ovd_p_accrued
             go_PENALTY_P, --penalty_p
             go_PENALTY_I, --penalty_i
             /*(SELECT count(*)
                FROM fcc.CLTB_ACCOUNT_SCHEDULES  c
                WHERE c.ACCOUNT_NUMBER  = pi_loan_account
                AND c.COMPONENT_NAME = 'MAIN_INT'
                AND c.schedule_due_date >= gd_max_adv_rep_to_date--pi_payment_plan_date
                ),*/ --exp_pay_cnt
             nvl((select exp_pay_cnt from rep_sbl_rate_sched
                    where to_date=gd_max_adv_rep_to_date),0),  --exp_pay_cnt
             ln_due_dates_on_rep,
             nvl((SELECT sum(nvl(EMI_AMOUNT,0))
                    FROM rep_sbl_rate_sched
                   WHERE from_date=gd_max_adv_rep_to_date --EMI_AMOUNT
             /*(SELECT max(from_date) FROM rep_sbl_rate_sched WHERE nvl(EMI_AMOUNT,0)>0)*/),0), --new_emi
             pi_last_paym_sum, --last_paym_contr
             null, --last_paym_calc
       ln_current_rate, --int_rate
       pi_new_int_rate, --new_int_rate
       pi_new_int_rate_date --new_int_rate_date
       );
      COMMIT;
      UPDATE rep_sbl_rate
         SET TOTAL= nvl(round(PRPL_EXPECTED,2),0)+
                    nvl(round(INT_EXPECTED,2),0)+
                    nvl(round(PRINCIPAL_OVERDUE,2),0)+
                    nvl(round(INTEREST_OVERDUE,2),0)+
                    nvl(round(INT_ON_OVD_P_ACCRUED,2),0)+
                    nvl(round(PENALTY_P,2),0)+
                    nvl(round(PENALTY_I,2),0)
         WHERE PRPL_EXPECTED is not null;
         COMMIT;
         --DBMS_OUTPUT.Put_Line('gn_is_buy_back='||to_char(gn_is_buy_back));
         /*IF gn_is_buy_back>0 THEN
            SELECT SUM(nvl(ADV_REPAYMENT,0)) INTO ln_sum_ADV_REPAYMENT
             FROM rep_sbl_rate_sched;
             UPDATE rep_sbl_rate
                SET LAST_PAYM_CALC= case when
                nvl(round(PRPL_EXPECTED,2),0)>=nvl(round(LAST_PAYM_CONTR,2),0)-nvl(ln_sum_ADV_REPAYMENT,0)
                then greatest(nvl(round(LAST_PAYM_CONTR,2),0),nvl(ln_sum_ADV_REPAYMENT,0))-nvl(ln_sum_ADV_REPAYMENT,0) --чтобы не было отрицательных значений
                else nvl(round(PRPL_EXPECTED,2),0)
                end
             WHERE PRPL_EXPECTED is not null;
             COMMIT;
         ELSE
            UPDATE rep_sbl_rate
                SET LAST_PAYM_CONTR=NULL;
             COMMIT;
         END IF;*/

         --для вывода сложим суммы
         UPDATE rep_sbl_rate_sched
         SET PRINCIPAL=nvl(PRINCIPAL,0)+nvl(ADV_REPAYMENT,0),
             INT_DUE=case when IS_PRINCIPAL_PAY='Y' then nvl(INT_DUE,EMI_AMOUNT)  else null end
         WHERE nvl(ADV_REPAYMENT,0)>0;
         COMMIT;
         --для вывода удалим отложенные проценты за даты где не было платежа
         UPDATE rep_sbl_rate_sched
         SET INT_EXPECTED=null
         WHERE nvl(IS_PRINCIPAL_PAY,0)<>'Y';
         COMMIT;
         UPDATE rep_sbl_rate
                SET customer_name=to_char(gd_max_adv_rep_to_date+1,'DD.MM.RRRR')
         WHERE PRPL_EXPECTED is not null;
         COMMIT;
         --последний платеж в расписании
         --korn20171030
         /*UPDATE rep_sbl_rate_sched
         SET int_expected=case when nvl(int_expected,0)=0 then 0 else nvl(int_expected,0)+nvl(EMI_AMOUNT,0) end  --отложенные % в последнем платеже не гасятся аннуитетом
         WHERE exp_pay_cnt=0;*/
         UPDATE rep_sbl_rate_sched
         SET PRINCIPAL=nvl(prpl_expected,0),
             EMI_AMOUNT=nvl(prpl_expected,0)+case when nvl(int_expected,0)>0 then nvl(int_expected,0) else nvl(accr_int,0) end
         WHERE exp_pay_cnt=0;
         COMMIT;
         UPDATE rep_sbl_rate
                SET LAST_PAYM_CALC=(select nvl(prpl_expected,0)+case when nvl(int_expected,0)>0 then nvl(int_expected,0) else nvl(accr_int,0) end
                                        from rep_sbl_rate_sched
                                        where to_date=(select max(to_date) from rep_sbl_rate_sched))
         WHERE PRPL_EXPECTED is not null;
         COMMIT;
         END IF;
     ELSE
         insert into rep_sbl_rate(account_number,check_message)
         values(pi_loan_account, lv_check_message);
         COMMIT;
     end if;
     COMMIT;
   END fill_percent_rate_SBL;

   FUNCTION SBL_PREPAY_RATE(pi_loan_account IN VARCHAR2,
              pi_new_int_rate_date IN DATE,
                            pi_new_int_rate  IN NUMBER,
                            pi_last_paym_sum  IN NUMBER) return rep_sbl_rate_nt PIPELINED IS
    lv_REPORT_WARN  varchar2(500);
    lv_REPORT_WARN2  varchar2(4000);
    ln_PSK  number;
   BEGIN
      rep_sbl_pkg.fill_percent_rate_SBL(pi_loan_account,
                            pi_new_int_rate_date,
                            pi_new_int_rate,
                            pi_last_paym_sum);
    lv_REPORT_WARN:=null;
--  Убрана проверка сторнирующих операций по согласованию с Завгородней Е. 06.05.20  PRB22107
--      begin
--      SELECT   CASE WHEN COUNT (*)>0 THEN 'Выполнялось сторнирование операций' ELSE null END
--        INTO lv_REPORT_WARN
--        FROM   fcc.cltb_account_events_processed
--       WHERE       account_number =pi_loan_account
--           AND event_date > (SELECT   MIN (from_date) FROM rep_sbl_rate_sched)
--           AND (EVENT_CODE = 'REVV' OR EVENT_CODE = 'REVP');
--      exception when no_data_found then
--      lv_REPORT_WARN:=null;
--      end;
      ln_PSK:=rep_sbl_pkg.get_psk_rate(pi_loan_account,0.0001,pi_new_int_rate_date)*100;
      /*lv_REPORT_WARN2:=substr(bo_helios_353_pkg.checking_amounts_f(pi_loan_account),1,4000);
      if lv_REPORT_WARN2 is not null then
        --lv_REPORT_WARN2:=substr(lv_REPORT_WARN2,1,instr(lv_REPORT_WARN2,'Направьте')-1);
        lv_REPORT_WARN2:='По указанному кредиту на текущую дату уже есть заявка на ЧДП';
        lv_REPORT_WARN:=substr(trim(nvl(lv_REPORT_WARN,'')||' '||nvl(lv_REPORT_WARN2,'')),1,500);
      end if;*/
    for rec in (SELECT   max(decode(check_message,null,account_number,null)) account_number,
               max(decode(check_message,null,prpl_expected,null)) prpl_expected,
               max(decode(check_message,null,int_expected,null)) int_expected,
                           max(decode(check_message,null,principal_overdue,null)) principal_overdue,
               max(decode(check_message,null,interest_overdue,null)) interest_overdue,
               max(decode(check_message,null,int_on_ovd_p_accrued,null)) int_on_ovd_p_accrued,
                           max(decode(check_message,null,penalty_p,null)) penalty_p,
               max(decode(check_message,null,penalty_i,null)) penalty_i,
               max(decode(check_message,null,exp_pay_cnt,null)) exp_pay_cnt,
               max(decode(check_message,null,due_date_on,null)) due_date_on,
               max(decode(check_message,null,new_emi,null)) new_emi,
                           max(decode(check_message,null,last_paym_contr,null)) last_paym_contr,
               max(decode(check_message,null,last_paym_calc,null)) last_paym_calc,
               max(decode(check_message,null,total,null)) total,
               max(decode(check_message,null,int_rate,null)) int_rate,
               max(decode(check_message,null,new_int_rate,null)) new_int_rate,
               max(decode(check_message,null,new_int_rate_date,null)) new_int_rate_date,
               max(decode(check_message,null,null,customer_name)) customer_name,
                           max(decode(check_message,null,null,trim(check_message))) check_message
                          FROM rep_sbl_rate) loop
         if rec.check_message is not null and lv_REPORT_WARN is null then
          lv_REPORT_WARN:=rec.check_message;
         elsif rec.check_message='OK' and lv_REPORT_WARN is not null then
          lv_REPORT_WARN:=trim(lv_REPORT_WARN);
         elsif rec.check_message<>'OK' and lv_REPORT_WARN is not null then
          lv_REPORT_WARN:=trim(nvl(rec.check_message,'')||' '||nvl(lv_REPORT_WARN,''));
         end if;
         --lv_REPORT_WARN:=rec.check_message;
               pipe row(rep_sbl_rate_t(rec.account_number,
                                               rec.prpl_expected,
                                               rec.int_expected,
                                               rec.principal_overdue,
                                               rec.interest_overdue,
                                               rec.int_on_ovd_p_accrued,
                                               rec.penalty_p,
                                               rec.penalty_i,
                                               rec.exp_pay_cnt,
                         rec.due_date_on,
                                               rec.new_emi,
                         round(ln_PSK,5),
                                               rec.last_paym_contr,
                                               rec.last_paym_calc,
                                               rec.total,
                         rec.int_rate,
                         rec.new_int_rate,
                         rec.new_int_rate_date,
                                               rec.customer_name,
                                               lv_REPORT_WARN));
      end loop;
      RETURN;
   END SBL_PREPAY_RATE;

   FUNCTION SBL_PREPAY_CHECK(pi_loan_account IN VARCHAR2) return rep_sbl_check_nt PIPELINED IS
  ld_branch_date DATE;
    lv_is_int_prepayed CHAR(1);
    ln_int_prepayed_amt NUMBER;
    lv_is_new_rate CHAR(1);
    ld_new_rate_date DATE;
    ln_new_rate_amt NUMBER;
  lv_branch_code CLTB_ACCOUNT_MASTER.Branch_code%TYPE;
   BEGIN
     begin
       SELECT Branch_code
       INTO lv_branch_code
       FROM CLTB_ACCOUNT_MASTER
       WHERE ACCOUNT_NUMBER = pi_loan_account;
       --get today for branch
       SELECT today INTO ld_branch_date FROM fcc.sttm_dates
       WHERE Branch_code = lv_branch_code;
     exception when no_data_found then
      ld_branch_date:=null;
     end;
     lv_is_new_rate:='N';
     for rec in (SELECT EFFECTIVE_DATE, UDE_VALUE RATE FROM fcc.CLTB_ACCOUNT_UDE_VALUES
                            WHERE ACCOUNT_NUMBER = pi_loan_account
                            AND EFFECTIVE_DATE>=ld_branch_date
                            AND UDE_ID = 'INTEREST_RATE'
                            order by EFFECTIVE_DATE desc) loop
            lv_is_new_rate:='Y';
          ld_new_rate_date:=rec.EFFECTIVE_DATE;
          ln_new_rate_amt:=rec.RATE;
    end loop;
    /*SELECT sum(c.AMOUNT) INTO ln_int_prepayed_amt
                             FROM fcc.CLTB_LIQ a, fcc.CLTB_ACCOUNT_EVENTS_PROCESSED b, fcc.cltb_event_entries c
                             WHERE a.ACCOUNT_NUMBER = b.ACCOUNT_NUMBER
                             AND a.ACCOUNT_NUMBER = c.ACCOUNT_NUMBER
                             AND b.COMPONENT_NAME = c.COMPONENT_NAME
                             AND a.EVENT_SEQ_NO = b.EVENT_SEQ_NO
                             AND a.EVENT_SEQ_NO = c.EVENT_SEQ_NO
                             AND a.ACCOUNT_NUMBER = pi_loan_account
                             AND a.INSTALLMENT_PAYMENT = 'N'
                             AND a.VALUE_DATE >=ld_branch_date
                             AND b.COMPONENT_NAME ='MAIN_INT'
                             AND b.EXECUTION_STATUS = 'P'
                             AND a.PAYMENT_STATUS = 'P'  --new
                             AND c.AMOUNT_TAG = 'MAIN_INT_DLIQ'
                             AND b.EVENT_CODE = 'MLIQ'*/
    SELECT sum(a.AMOUNT_SETTLED) INTO ln_int_prepayed_amt
         FROM fcc.CLTB_ACCOUNT_SCHEDULES a,
          fcc.CLTB_ACCOUNT_MASTER am
     WHERE a.ACCOUNT_NUMBER  = am.ACCOUNT_NUMBER
     AND am.ACCOUNT_STATUS='A'
     AND a.ACCOUNT_NUMBER  = pi_loan_account
     AND a.SCHEDULE_DUE_DATE >=ld_branch_date
     AND a.COMPONENT_NAME = 'MAIN_INT';
    if nvl(ln_int_prepayed_amt,0)>0 then lv_is_int_prepayed:='Y'; else lv_is_int_prepayed:='N'; end if;
        pipe row(rep_sbl_check_t(pi_loan_account,
                                        ld_branch_date,
                                        lv_is_int_prepayed,
                                        ln_int_prepayed_amt,
                    lv_is_new_rate,
                    ld_new_rate_date,
                    ln_new_rate_amt));
      RETURN;
   END SBL_PREPAY_CHECK;

function SBL_PREPAY_RATE_SCHED(p_loan_id IN VARCHAR2,p_new_int_rate_date IN DATE) return rep_sbl_rate_sched_nt pipelined is
   gv_branch_code fcc.CLTB_ACCOUNT_MASTER.Branch_code%TYPE;
   gv_branch_day fcc.sttm_dates.today%TYPE;
begin
    SELECT max(Branch_code) INTO gv_branch_code FROM fcc.CLTB_ACCOUNT_MASTER
    WHERE ACCOUNT_NUMBER = p_loan_id;
    select today INTO gv_branch_day from fcc.sttm_dates where Branch_code = gv_branch_code;
    for rec in (SELECT FROM_DATE,
      TO_DATE,
      INT_RATE,
      ACCR_INT,
      INT_EXPECTED,
      INT_PREPAID,
      ADV_REPAYMENT,
      INT_DUE,
      EMI_AMOUNT,
      IS_PRINCIPAL_PAY,
      PRINCIPAL,
      /*case when p_new_int_rate_date<=gv_branch_day then
      case when TO_DATE>gv_branch_day then nvl(PRPL_EXPECTED,0)-nvl(PRINCIPAL,0) else PRPL_EXPECTED end
      else case when TO_DATE=p_new_int_rate_date and IS_PRINCIPAL_PAY<>'Y' then PRPL_EXPECTED else nvl(PRPL_EXPECTED,0)-nvl(PRINCIPAL,0) end
      end*/ nvl(PRPL_EXPECTED,0)-nvl(PRINCIPAL,0) PRPL_EXPECTED,
      TRANCHE,
      EXP_PAY_CNT
    FROM rep_sbl_rate_sched
    ORDER BY FROM_DATE)
    loop
      pipe row (rep_sbl_rate_sched_t (rec.FROM_DATE,
                    rec.TO_DATE,
                      rec.INT_RATE,
                      rec.ACCR_INT,
                      rec.INT_EXPECTED,
                      rec.INT_PREPAID,
                      rec.ADV_REPAYMENT,
                      rec.INT_DUE,
                      rec.EMI_AMOUNT,
                      rec.IS_PRINCIPAL_PAY,
                      rec.PRINCIPAL,
                      rec.PRPL_EXPECTED,
                      rec.TRANCHE,
                      rec.EXP_PAY_CNT));
    end loop;
    return;
end SBL_PREPAY_RATE_SCHED;

FUNCTION SBL_PREPAY_RATE_UDF(pi_loan_account IN VARCHAR2,
              pi_new_int_rate_date IN DATE,
                            pi_new_int_rate  IN NUMBER) return rep_sbl_rate_udf_nt PIPELINED IS

   BEGIN
        pipe row(rep_sbl_rate_udf_t(pi_loan_account,
                                    pi_new_int_rate_date,
                                    'INTEREST_RATE',
                                    pi_new_int_rate));
    for rec in (select k.ACCOUNT_NUMBER, k.EFFECTIVE_DATE, k.UDE_ID, k.UDE_VALUE from
            (SELECT v.*, max(effective_date) over (partition by ude_id) max_dt FROM fcc.CLTB_ACCOUNT_UDE_VALUES v
            where ACCOUNT_NUMBER = pi_loan_account
            and UDE_ID<>'INTEREST_RATE') k
          where k.max_dt = k.effective_date
          and nvl(k.UDE_VALUE,0)<>0)
    loop
      pipe row(rep_sbl_rate_udf_t(pi_loan_account,
                                        rec.EFFECTIVE_DATE,
                                        rec.UDE_ID,
                                        rec.UDE_VALUE));
    end loop;
      RETURN;
END SBL_PREPAY_RATE_UDF;
--
PROCEDURE sbl_prepay_rate_wrap(p_loan_id           IN VARCHAR2,
                               p_new_int_rate_date IN DATE,
                               p_new_int_rate      IN NUMBER,
                               p_last_paym_sum     IN NUMBER,
                               p_cursor           OUT SYS_REFCURSOR,
                               p_schedule         OUT SYS_REFCURSOR/*, p_udf OUT SYS_REFCURSOR*/
                              )
IS
 v_new_int_rate_date    DATE;
 v_new_int_rate         NUMBER;
 v_insert_time          TIMESTAMP(6);
 v_process_time         TIMESTAMP(6);
 v_is_log               BO_SETTINGS.PARAM_VALUE%TYPE;
 v_row                  REP_SBL_PKG_LOG%ROWTYPE;
 v_request_id           NUMBER;
BEGIN
  v_is_log:=Get_Setting('REP_SBL_PKG.SBL_PREPAY_RATE_WRAP');

  if (v_is_log = 'Y')
  then
   -- Logging
   v_insert_time:=SYSTIMESTAMP;
   v_request_id:=Get_Request_ID;
   v_row.insert_time:=v_insert_time;
   v_row.request_id:=v_request_id;

   -- IN parameters
   v_row.proc_name:='REP_SBL_PKG.SBL_PREPAY_RATE_WRAP';
   v_row.param_type:='IN';
   v_row.loan_id:=p_loan_id;
   v_row.new_int_rate_date:=v_new_int_rate_date;
   v_row.new_int_rate:=v_new_int_rate;

   insert into REP_SBL_PKG_LOG
   values v_row;

   v_row:=NULL;

   -- OUT parameters
   v_row.proc_name:='REP_SBL_PKG.SBL_PREPAY_PDP_WRAP';
   v_row.param_type:='OUT';

   insert into REP_SBL_PKG_LOG
   (proc_name
   ,param_type
   ,insert_time
   ,request_id
   ,account_number
   ,prpl_expected
   ,int_expected
   ,principal_overdue
   ,interest_overdue
   ,int_on_ovd_p_accrued
   ,penalty_p
   ,penalty_i
   ,exp_pay_cnt
   ,due_date_on
   ,new_emi
   ,new_psk
   ,last_paym_contr
   ,last_paym_calc
   ,total
   ,int_rate
   ,new_int_rate
   ,new_int_rate_date
   ,customer_name
   ,check_message
   )
   select v_row.proc_name
         ,v_row.param_type
         ,v_insert_time
		 ,v_request_id
         ,account_number
         ,prpl_expected
         ,int_expected
         ,principal_overdue
         ,interest_overdue
         ,int_on_ovd_p_accrued
         ,penalty_p
         ,penalty_i
         ,exp_pay_cnt
         ,due_date_on
         ,new_emi
         ,new_psk
         ,last_paym_contr
         ,last_paym_calc
         ,total
         ,int_rate
         ,new_int_rate
         ,new_int_rate_date
         ,customer_name
         ,check_message
   from table (rep_sbl_pkg.SBL_PREPAY_RATE (p_loan_id,
                         p_new_int_rate_date,
                         p_new_int_rate,
                         p_last_paym_sum));
  end if;

  OPEN p_cursor FOR
    SELECT account_number
      ,prpl_expected
      ,int_expected
      ,principal_overdue
      ,interest_overdue
      ,int_on_ovd_p_accrued
      ,penalty_p
      ,penalty_i
      ,exp_pay_cnt
      ,due_date_on
      ,new_emi
      ,new_psk
      ,last_paym_contr
      ,last_paym_calc
      ,total
      ,int_rate
      ,new_int_rate
      ,new_int_rate_date
      ,customer_name
      ,check_message
    FROM TABLE (rep_sbl_pkg.SBL_PREPAY_RATE (p_loan_id,
                          p_new_int_rate_date,
                          p_new_int_rate,
                          p_last_paym_sum));
  OPEN p_schedule FOR
  SELECT FROM_DATE,
      TO_DATE,
      INT_RATE,
      ACCR_INT,
      INT_EXPECTED,
      INT_PREPAID,
      ADV_REPAYMENT,
      INT_DUE,
      EMI_AMOUNT,
      IS_PRINCIPAL_PAY,
      PRINCIPAL,
      PRPL_EXPECTED,
      TRANCHE,
      EXP_PAY_CNT
    FROM TABLE (rep_sbl_pkg.SBL_PREPAY_RATE_SCHED(p_loan_id,p_new_int_rate_date));

/*  -------------------------

  OPEN p_udf FOR
  SELECT account_number,
         effective_date,
         ude_id,
         ude_value
  FROM TABLE (rep_sbl_pkg.SBL_PREPAY_RATE_UDF(p_loan_id,
                                              p_new_int_rate_date,
                                              p_new_int_rate));

---------------------- */

 if (v_is_log = 'Y')
 then
   v_process_time:=SYSTIMESTAMP;

   update REP_SBL_PKG_LOG
   set process_time = v_process_time
   where request_id = v_request_id;
   commit;
 end if;

END sbl_prepay_rate_wrap;

PROCEDURE sbl_prepay_check_wrap (
  p_loan_id IN VARCHAR2,
  p_cursor OUT SYS_REFCURSOR
) IS
BEGIN
  OPEN p_cursor FOR
        SELECT
          account_number
          ,branch_date
          ,is_int_prepayed
          ,int_prepayed_amt
          ,is_new_rate
          ,new_rate_date
          ,new_rate_amt
    FROM TABLE (rep_sbl_pkg.SBL_PREPAY_CHECK (p_loan_id));
END sbl_prepay_check_wrap;
END;
